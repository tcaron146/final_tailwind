"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/protobufjs";
exports.ids = ["vendor-chunks/protobufjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/protobufjs/ext/descriptor/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/protobufjs/ext/descriptor/index.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nvar $protobuf = __webpack_require__(/*! ../.. */ \"(ssr)/./node_modules/protobufjs/index.js\");\nmodule.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(__webpack_require__(/*! ../../google/protobuf/descriptor.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/descriptor.json\")).lookup(\".google.protobuf\");\nvar Namespace = $protobuf.Namespace, Root = $protobuf.Root, Enum = $protobuf.Enum, Type = $protobuf.Type, Field = $protobuf.Field, MapField = $protobuf.MapField, OneOf = $protobuf.OneOf, Service = $protobuf.Service, Method = $protobuf.Method;\n// --- Root ---\n/**\n * Properties of a FileDescriptorSet message.\n * @interface IFileDescriptorSet\n * @property {IFileDescriptorProto[]} file Files\n */ /**\n * Properties of a FileDescriptorProto message.\n * @interface IFileDescriptorProto\n * @property {string} [name] File name\n * @property {string} [package] Package\n * @property {*} [dependency] Not supported\n * @property {*} [publicDependency] Not supported\n * @property {*} [weakDependency] Not supported\n * @property {IDescriptorProto[]} [messageType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IServiceDescriptorProto[]} [service] Nested services\n * @property {IFieldDescriptorProto[]} [extension] Nested extension fields\n * @property {IFileOptions} [options] Options\n * @property {*} [sourceCodeInfo] Not supported\n * @property {string} [syntax=\"proto2\"] Syntax\n */ /**\n * Properties of a FileOptions message.\n * @interface IFileOptions\n * @property {string} [javaPackage]\n * @property {string} [javaOuterClassname]\n * @property {boolean} [javaMultipleFiles]\n * @property {boolean} [javaGenerateEqualsAndHash]\n * @property {boolean} [javaStringCheckUtf8]\n * @property {IFileOptionsOptimizeMode} [optimizeFor=1]\n * @property {string} [goPackage]\n * @property {boolean} [ccGenericServices]\n * @property {boolean} [javaGenericServices]\n * @property {boolean} [pyGenericServices]\n * @property {boolean} [deprecated]\n * @property {boolean} [ccEnableArenas]\n * @property {string} [objcClassPrefix]\n * @property {string} [csharpNamespace]\n */ /**\n * Values of he FileOptions.OptimizeMode enum.\n * @typedef IFileOptionsOptimizeMode\n * @type {number}\n * @property {number} SPEED=1\n * @property {number} CODE_SIZE=2\n * @property {number} LITE_RUNTIME=3\n */ /**\n * Creates a root from a descriptor set.\n * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor\n * @returns {Root} Root instance\n */ Root.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.FileDescriptorSet.decode(descriptor);\n    var root = new Root();\n    if (descriptor.file) {\n        var fileDescriptor, filePackage;\n        for(var j = 0, i; j < descriptor.file.length; ++j){\n            filePackage = root;\n            if ((fileDescriptor = descriptor.file[j])[\"package\"] && fileDescriptor[\"package\"].length) filePackage = root.define(fileDescriptor[\"package\"]);\n            if (fileDescriptor.name && fileDescriptor.name.length) root.files.push(filePackage.filename = fileDescriptor.name);\n            if (fileDescriptor.messageType) for(i = 0; i < fileDescriptor.messageType.length; ++i)filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));\n            if (fileDescriptor.enumType) for(i = 0; i < fileDescriptor.enumType.length; ++i)filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));\n            if (fileDescriptor.extension) for(i = 0; i < fileDescriptor.extension.length; ++i)filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));\n            if (fileDescriptor.service) for(i = 0; i < fileDescriptor.service.length; ++i)filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));\n            var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);\n            if (opts) {\n                var ks = Object.keys(opts);\n                for(i = 0; i < ks.length; ++i)filePackage.setOption(ks[i], opts[ks[i]]);\n            }\n        }\n    }\n    return root;\n};\n/**\n * Converts a root to a descriptor set.\n * @returns {Message<IFileDescriptorSet>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */ Root.prototype.toDescriptor = function toDescriptor(syntax) {\n    var set = exports.FileDescriptorSet.create();\n    Root_toDescriptorRecursive(this, set.file, syntax);\n    return set;\n};\n// Traverses a namespace and assembles the descriptor set\nfunction Root_toDescriptorRecursive(ns, files, syntax) {\n    // Create a new file\n    var file = exports.FileDescriptorProto.create({\n        name: ns.filename || (ns.fullName.substring(1).replace(/\\./g, \"_\") || \"root\") + \".proto\"\n    });\n    if (syntax) file.syntax = syntax;\n    if (!(ns instanceof Root)) file[\"package\"] = ns.fullName.substring(1);\n    // Add nested types\n    for(var i = 0, nested; i < ns.nestedArray.length; ++i)if ((nested = ns._nestedArray[i]) instanceof Type) file.messageType.push(nested.toDescriptor(syntax));\n    else if (nested instanceof Enum) file.enumType.push(nested.toDescriptor());\n    else if (nested instanceof Field) file.extension.push(nested.toDescriptor(syntax));\n    else if (nested instanceof Service) file.service.push(nested.toDescriptor());\n    else if (nested instanceof /* plain */ Namespace) Root_toDescriptorRecursive(nested, files, syntax); // requires new file\n    // Keep package-level options\n    file.options = toDescriptorOptions(ns.options, exports.FileOptions);\n    // And keep the file only if there is at least one nested object\n    if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length) files.push(file);\n}\n// --- Type ---\n/**\n * Properties of a DescriptorProto message.\n * @interface IDescriptorProto\n * @property {string} [name] Message type name\n * @property {IFieldDescriptorProto[]} [field] Fields\n * @property {IFieldDescriptorProto[]} [extension] Extension fields\n * @property {IDescriptorProto[]} [nestedType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges\n * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs\n * @property {IMessageOptions} [options] Not supported\n * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges\n * @property {string[]} [reservedName] Reserved names\n */ /**\n * Properties of a MessageOptions message.\n * @interface IMessageOptions\n * @property {boolean} [mapEntry=false] Whether this message is a map entry\n */ /**\n * Properties of an ExtensionRange message.\n * @interface IDescriptorProtoExtensionRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */ /**\n * Properties of a ReservedRange message.\n * @interface IDescriptorProtoReservedRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */ var unnamedMessageIndex = 0;\n/**\n * Creates a type from a descriptor.\n * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Type} Type instance\n */ Type.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor);\n    // Create the message type\n    var type = new Type(descriptor.name.length ? descriptor.name : \"Type\" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)), i;\n    /* Oneofs */ if (descriptor.oneofDecl) for(i = 0; i < descriptor.oneofDecl.length; ++i)type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));\n    /* Fields */ if (descriptor.field) for(i = 0; i < descriptor.field.length; ++i){\n        var field = Field.fromDescriptor(descriptor.field[i], syntax);\n        type.add(field);\n        if (descriptor.field[i].hasOwnProperty(\"oneofIndex\")) type.oneofsArray[descriptor.field[i].oneofIndex].add(field);\n    }\n    /* Extension fields */ if (descriptor.extension) for(i = 0; i < descriptor.extension.length; ++i)type.add(Field.fromDescriptor(descriptor.extension[i], syntax));\n    /* Nested types */ if (descriptor.nestedType) for(i = 0; i < descriptor.nestedType.length; ++i){\n        type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));\n        if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry) type.setOption(\"map_entry\", true);\n    }\n    /* Nested enums */ if (descriptor.enumType) for(i = 0; i < descriptor.enumType.length; ++i)type.add(Enum.fromDescriptor(descriptor.enumType[i]));\n    /* Extension ranges */ if (descriptor.extensionRange && descriptor.extensionRange.length) {\n        type.extensions = [];\n        for(i = 0; i < descriptor.extensionRange.length; ++i)type.extensions.push([\n            descriptor.extensionRange[i].start,\n            descriptor.extensionRange[i].end\n        ]);\n    }\n    /* Reserved... */ if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {\n        type.reserved = [];\n        /* Ranges */ if (descriptor.reservedRange) for(i = 0; i < descriptor.reservedRange.length; ++i)type.reserved.push([\n            descriptor.reservedRange[i].start,\n            descriptor.reservedRange[i].end\n        ]);\n        /* Names */ if (descriptor.reservedName) for(i = 0; i < descriptor.reservedName.length; ++i)type.reserved.push(descriptor.reservedName[i]);\n    }\n    return type;\n};\n/**\n * Converts a type to a descriptor.\n * @returns {Message<IDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */ Type.prototype.toDescriptor = function toDescriptor(syntax) {\n    var descriptor = exports.DescriptorProto.create({\n        name: this.name\n    }), i;\n    /* Fields */ for(i = 0; i < this.fieldsArray.length; ++i){\n        var fieldDescriptor;\n        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));\n        if (this._fieldsArray[i] instanceof MapField) {\n            var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType), valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType), valueTypeName = valueType === /* type */ 11 || valueType === /* enum */ 14 ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type : undefined;\n            descriptor.nestedType.push(exports.DescriptorProto.create({\n                name: fieldDescriptor.typeName,\n                field: [\n                    exports.FieldDescriptorProto.create({\n                        name: \"key\",\n                        number: 1,\n                        label: 1,\n                        type: keyType\n                    }),\n                    exports.FieldDescriptorProto.create({\n                        name: \"value\",\n                        number: 2,\n                        label: 1,\n                        type: valueType,\n                        typeName: valueTypeName\n                    })\n                ],\n                options: exports.MessageOptions.create({\n                    mapEntry: true\n                })\n            }));\n        }\n    }\n    /* Oneofs */ for(i = 0; i < this.oneofsArray.length; ++i)descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());\n    /* Nested... */ for(i = 0; i < this.nestedArray.length; ++i){\n        /* Extension fields */ if (this._nestedArray[i] instanceof Field) descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));\n        else if (this._nestedArray[i] instanceof Type) descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));\n        else if (this._nestedArray[i] instanceof Enum) descriptor.enumType.push(this._nestedArray[i].toDescriptor());\n    // plain nested namespaces become packages instead in Root#toDescriptor\n    }\n    /* Extension ranges */ if (this.extensions) for(i = 0; i < this.extensions.length; ++i)descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({\n        start: this.extensions[i][0],\n        end: this.extensions[i][1]\n    }));\n    /* Reserved... */ if (this.reserved) for(i = 0; i < this.reserved.length; ++i)/* Names */ if (typeof this.reserved[i] === \"string\") descriptor.reservedName.push(this.reserved[i]);\n    else descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({\n        start: this.reserved[i][0],\n        end: this.reserved[i][1]\n    }));\n    descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);\n    return descriptor;\n};\n// --- Field ---\n/**\n * Properties of a FieldDescriptorProto message.\n * @interface IFieldDescriptorProto\n * @property {string} [name] Field name\n * @property {number} [number] Field id\n * @property {IFieldDescriptorProtoLabel} [label] Field rule\n * @property {IFieldDescriptorProtoType} [type] Field basic type\n * @property {string} [typeName] Field type name\n * @property {string} [extendee] Extended type name\n * @property {string} [defaultValue] Literal default value\n * @property {number} [oneofIndex] Oneof index if part of a oneof\n * @property {*} [jsonName] Not supported\n * @property {IFieldOptions} [options] Field options\n */ /**\n * Values of the FieldDescriptorProto.Label enum.\n * @typedef IFieldDescriptorProtoLabel\n * @type {number}\n * @property {number} LABEL_OPTIONAL=1\n * @property {number} LABEL_REQUIRED=2\n * @property {number} LABEL_REPEATED=3\n */ /**\n * Values of the FieldDescriptorProto.Type enum.\n * @typedef IFieldDescriptorProtoType\n * @type {number}\n * @property {number} TYPE_DOUBLE=1\n * @property {number} TYPE_FLOAT=2\n * @property {number} TYPE_INT64=3\n * @property {number} TYPE_UINT64=4\n * @property {number} TYPE_INT32=5\n * @property {number} TYPE_FIXED64=6\n * @property {number} TYPE_FIXED32=7\n * @property {number} TYPE_BOOL=8\n * @property {number} TYPE_STRING=9\n * @property {number} TYPE_GROUP=10\n * @property {number} TYPE_MESSAGE=11\n * @property {number} TYPE_BYTES=12\n * @property {number} TYPE_UINT32=13\n * @property {number} TYPE_ENUM=14\n * @property {number} TYPE_SFIXED32=15\n * @property {number} TYPE_SFIXED64=16\n * @property {number} TYPE_SINT32=17\n * @property {number} TYPE_SINT64=18\n */ /**\n * Properties of a FieldOptions message.\n * @interface IFieldOptions\n * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)\n * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)\n */ /**\n * Values of the FieldOptions.JSType enum.\n * @typedef IFieldOptionsJSType\n * @type {number}\n * @property {number} JS_NORMAL=0\n * @property {number} JS_STRING=1\n * @property {number} JS_NUMBER=2\n */ // copied here from parse.js\nvar numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;\n/**\n * Creates a field from a descriptor.\n * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Field} Field instance\n */ Field.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor);\n    if (typeof descriptor.number !== \"number\") throw Error(\"missing field id\");\n    // Rewire field type\n    var fieldType;\n    if (descriptor.typeName && descriptor.typeName.length) fieldType = descriptor.typeName;\n    else fieldType = fromDescriptorType(descriptor.type);\n    // Rewire field rule\n    var fieldRule;\n    switch(descriptor.label){\n        // 0 is reserved for errors\n        case 1:\n            fieldRule = undefined;\n            break;\n        case 2:\n            fieldRule = \"required\";\n            break;\n        case 3:\n            fieldRule = \"repeated\";\n            break;\n        default:\n            throw Error(\"illegal label: \" + descriptor.label);\n    }\n    var extendee = descriptor.extendee;\n    if (descriptor.extendee !== undefined) {\n        extendee = extendee.length ? extendee : undefined;\n    }\n    var field = new Field(descriptor.name.length ? descriptor.name : \"field\" + descriptor.number, descriptor.number, fieldType, fieldRule, extendee);\n    field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);\n    if (descriptor.defaultValue && descriptor.defaultValue.length) {\n        var defaultValue = descriptor.defaultValue;\n        switch(defaultValue){\n            case \"true\":\n            case \"TRUE\":\n                defaultValue = true;\n                break;\n            case \"false\":\n            case \"FALSE\":\n                defaultValue = false;\n                break;\n            default:\n                var match = numberRe.exec(defaultValue);\n                if (match) defaultValue = parseInt(defaultValue); // eslint-disable-line radix\n                break;\n        }\n        field.setOption(\"default\", defaultValue);\n    }\n    if (packableDescriptorType(descriptor.type)) {\n        if (syntax === \"proto3\") {\n            if (descriptor.options && !descriptor.options.packed) field.setOption(\"packed\", false);\n        } else if (!(descriptor.options && descriptor.options.packed)) field.setOption(\"packed\", false);\n    }\n    return field;\n};\n/**\n * Converts a field to a descriptor.\n * @returns {Message<IFieldDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */ Field.prototype.toDescriptor = function toDescriptor(syntax) {\n    var descriptor = exports.FieldDescriptorProto.create({\n        name: this.name,\n        number: this.id\n    });\n    if (this.map) {\n        descriptor.type = 11; // message\n        descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)\n        descriptor.label = 3; // repeated\n    } else {\n        // Rewire field type\n        switch(descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)){\n            case 10:\n            case 11:\n            case 14:\n                descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;\n                break;\n        }\n        // Rewire field rule\n        switch(this.rule){\n            case \"repeated\":\n                descriptor.label = 3;\n                break;\n            case \"required\":\n                descriptor.label = 2;\n                break;\n            default:\n                descriptor.label = 1;\n                break;\n        }\n    }\n    // Handle extension field\n    descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;\n    // Handle part of oneof\n    if (this.partOf) {\n        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0) throw Error(\"missing oneof\");\n    }\n    if (this.options) {\n        descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);\n        if (this.options[\"default\"] != null) descriptor.defaultValue = String(this.options[\"default\"]);\n    }\n    if (syntax === \"proto3\") {\n        if (!this.packed) (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;\n    } else if (this.packed) (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;\n    return descriptor;\n};\n// --- Enum ---\n/**\n * Properties of an EnumDescriptorProto message.\n * @interface IEnumDescriptorProto\n * @property {string} [name] Enum name\n * @property {IEnumValueDescriptorProto[]} [value] Enum values\n * @property {IEnumOptions} [options] Enum options\n */ /**\n * Properties of an EnumValueDescriptorProto message.\n * @interface IEnumValueDescriptorProto\n * @property {string} [name] Name\n * @property {number} [number] Value\n * @property {*} [options] Not supported\n */ /**\n * Properties of an EnumOptions message.\n * @interface IEnumOptions\n * @property {boolean} [allowAlias] Whether aliases are allowed\n * @property {boolean} [deprecated]\n */ var unnamedEnumIndex = 0;\n/**\n * Creates an enum from a descriptor.\n * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Enum} Enum instance\n */ Enum.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.EnumDescriptorProto.decode(descriptor);\n    // Construct values object\n    var values = {};\n    if (descriptor.value) for(var i = 0; i < descriptor.value.length; ++i){\n        var name = descriptor.value[i].name, value = descriptor.value[i].number || 0;\n        values[name && name.length ? name : \"NAME\" + value] = value;\n    }\n    return new Enum(descriptor.name && descriptor.name.length ? descriptor.name : \"Enum\" + unnamedEnumIndex++, values, fromDescriptorOptions(descriptor.options, exports.EnumOptions));\n};\n/**\n * Converts an enum to a descriptor.\n * @returns {Message<IEnumDescriptorProto>} Descriptor\n */ Enum.prototype.toDescriptor = function toDescriptor() {\n    // Values\n    var values = [];\n    for(var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)values.push(exports.EnumValueDescriptorProto.create({\n        name: ks[i],\n        number: this.values[ks[i]]\n    }));\n    return exports.EnumDescriptorProto.create({\n        name: this.name,\n        value: values,\n        options: toDescriptorOptions(this.options, exports.EnumOptions)\n    });\n};\n// --- OneOf ---\n/**\n * Properties of a OneofDescriptorProto message.\n * @interface IOneofDescriptorProto\n * @property {string} [name] Oneof name\n * @property {*} [options] Not supported\n */ var unnamedOneofIndex = 0;\n/**\n * Creates a oneof from a descriptor.\n * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {OneOf} OneOf instance\n */ OneOf.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.OneofDescriptorProto.decode(descriptor);\n    return new OneOf(// unnamedOneOfIndex is global, not per type, because we have no ref to a type here\n    descriptor.name && descriptor.name.length ? descriptor.name : \"oneof\" + unnamedOneofIndex++);\n};\n/**\n * Converts a oneof to a descriptor.\n * @returns {Message<IOneofDescriptorProto>} Descriptor\n */ OneOf.prototype.toDescriptor = function toDescriptor() {\n    return exports.OneofDescriptorProto.create({\n        name: this.name\n    });\n};\n// --- Service ---\n/**\n * Properties of a ServiceDescriptorProto message.\n * @interface IServiceDescriptorProto\n * @property {string} [name] Service name\n * @property {IMethodDescriptorProto[]} [method] Methods\n * @property {IServiceOptions} [options] Options\n */ /**\n * Properties of a ServiceOptions message.\n * @interface IServiceOptions\n * @property {boolean} [deprecated]\n */ var unnamedServiceIndex = 0;\n/**\n * Creates a service from a descriptor.\n * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Service} Service instance\n */ Service.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.ServiceDescriptorProto.decode(descriptor);\n    var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : \"Service\" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));\n    if (descriptor.method) for(var i = 0; i < descriptor.method.length; ++i)service.add(Method.fromDescriptor(descriptor.method[i]));\n    return service;\n};\n/**\n * Converts a service to a descriptor.\n * @returns {Message<IServiceDescriptorProto>} Descriptor\n */ Service.prototype.toDescriptor = function toDescriptor() {\n    // Methods\n    var methods = [];\n    for(var i = 0; i < this.methodsArray.length; ++i)methods.push(this._methodsArray[i].toDescriptor());\n    return exports.ServiceDescriptorProto.create({\n        name: this.name,\n        method: methods,\n        options: toDescriptorOptions(this.options, exports.ServiceOptions)\n    });\n};\n// --- Method ---\n/**\n * Properties of a MethodDescriptorProto message.\n * @interface IMethodDescriptorProto\n * @property {string} [name] Method name\n * @property {string} [inputType] Request type name\n * @property {string} [outputType] Response type name\n * @property {IMethodOptions} [options] Not supported\n * @property {boolean} [clientStreaming=false] Whether requests are streamed\n * @property {boolean} [serverStreaming=false] Whether responses are streamed\n */ /**\n * Properties of a MethodOptions message.\n * @interface IMethodOptions\n * @property {boolean} [deprecated]\n */ var unnamedMethodIndex = 0;\n/**\n * Creates a method from a descriptor.\n * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Method} Reflected method instance\n */ Method.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.MethodDescriptorProto.decode(descriptor);\n    return new Method(// unnamedMethodIndex is global, not per service, because we have no ref to a service here\n    descriptor.name && descriptor.name.length ? descriptor.name : \"Method\" + unnamedMethodIndex++, \"rpc\", descriptor.inputType, descriptor.outputType, Boolean(descriptor.clientStreaming), Boolean(descriptor.serverStreaming), fromDescriptorOptions(descriptor.options, exports.MethodOptions));\n};\n/**\n * Converts a method to a descriptor.\n * @returns {Message<IMethodDescriptorProto>} Descriptor\n */ Method.prototype.toDescriptor = function toDescriptor() {\n    return exports.MethodDescriptorProto.create({\n        name: this.name,\n        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,\n        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,\n        clientStreaming: this.requestStream,\n        serverStreaming: this.responseStream,\n        options: toDescriptorOptions(this.options, exports.MethodOptions)\n    });\n};\n// --- utility ---\n// Converts a descriptor type to a protobuf.js basic type\nfunction fromDescriptorType(type) {\n    switch(type){\n        // 0 is reserved for errors\n        case 1:\n            return \"double\";\n        case 2:\n            return \"float\";\n        case 3:\n            return \"int64\";\n        case 4:\n            return \"uint64\";\n        case 5:\n            return \"int32\";\n        case 6:\n            return \"fixed64\";\n        case 7:\n            return \"fixed32\";\n        case 8:\n            return \"bool\";\n        case 9:\n            return \"string\";\n        case 12:\n            return \"bytes\";\n        case 13:\n            return \"uint32\";\n        case 15:\n            return \"sfixed32\";\n        case 16:\n            return \"sfixed64\";\n        case 17:\n            return \"sint32\";\n        case 18:\n            return \"sint64\";\n    }\n    throw Error(\"illegal type: \" + type);\n}\n// Tests if a descriptor type is packable\nfunction packableDescriptorType(type) {\n    switch(type){\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 13:\n        case 14:\n        case 15:\n        case 16:\n        case 17:\n        case 18:\n            return true;\n    }\n    return false;\n}\n// Converts a protobuf.js basic type to a descriptor type\nfunction toDescriptorType(type, resolvedType) {\n    switch(type){\n        // 0 is reserved for errors\n        case \"double\":\n            return 1;\n        case \"float\":\n            return 2;\n        case \"int64\":\n            return 3;\n        case \"uint64\":\n            return 4;\n        case \"int32\":\n            return 5;\n        case \"fixed64\":\n            return 6;\n        case \"fixed32\":\n            return 7;\n        case \"bool\":\n            return 8;\n        case \"string\":\n            return 9;\n        case \"bytes\":\n            return 12;\n        case \"uint32\":\n            return 13;\n        case \"sfixed32\":\n            return 15;\n        case \"sfixed64\":\n            return 16;\n        case \"sint32\":\n            return 17;\n        case \"sint64\":\n            return 18;\n    }\n    if (resolvedType instanceof Enum) return 14;\n    if (resolvedType instanceof Type) return resolvedType.group ? 10 : 11;\n    throw Error(\"illegal type: \" + type);\n}\n// Converts descriptor options to an options object\nfunction fromDescriptorOptions(options, type) {\n    if (!options) return undefined;\n    var out = [];\n    for(var i = 0, field, key, val; i < type.fieldsArray.length; ++i)if ((key = (field = type._fieldsArray[i]).name) !== \"uninterpretedOption\") {\n        if (options.hasOwnProperty(key)) {\n            val = options[key];\n            if (field.resolvedType instanceof Enum && typeof val === \"number\" && field.resolvedType.valuesById[val] !== undefined) val = field.resolvedType.valuesById[val];\n            out.push(underScore(key), val);\n        }\n    }\n    return out.length ? $protobuf.util.toObject(out) : undefined;\n}\n// Converts an options object to descriptor options\nfunction toDescriptorOptions(options, type) {\n    if (!options) return undefined;\n    var out = [];\n    for(var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i){\n        val = options[key = ks[i]];\n        if (key === \"default\") continue;\n        var field = type.fields[key];\n        if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)])) continue;\n        out.push(key, val);\n    }\n    return out.length ? type.fromObject($protobuf.util.toObject(out)) : undefined;\n}\n// Calculates the shortest relative path from `from` to `to`.\nfunction shortname(from, to) {\n    var fromPath = from.fullName.split(\".\"), toPath = to.fullName.split(\".\"), i = 0, j = 0, k = toPath.length - 1;\n    if (!(from instanceof Root) && to instanceof Namespace) while(i < fromPath.length && j < k && fromPath[i] === toPath[j]){\n        var other = to.lookup(fromPath[i++], true);\n        if (other !== null && other !== to) break;\n        ++j;\n    }\n    else for(; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);\n    return toPath.slice(j).join(\".\");\n}\n// copied here from cli/targets/proto.js\nfunction underScore(str) {\n    return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) {\n        return \"_\" + $1.toLowerCase();\n    });\n} // --- exports ---\n /**\n * Reflected file descriptor set.\n * @name FileDescriptorSet\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected file descriptor proto.\n * @name FileDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected descriptor proto.\n * @name DescriptorProto\n * @type {Type}\n * @property {Type} ExtensionRange\n * @property {Type} ReservedRange\n * @const\n * @tstype $protobuf.Type & {\n *     ExtensionRange: $protobuf.Type,\n *     ReservedRange: $protobuf.Type\n * }\n */  /**\n * Reflected field descriptor proto.\n * @name FieldDescriptorProto\n * @type {Type}\n * @property {Enum} Label\n * @property {Enum} Type\n * @const\n * @tstype $protobuf.Type & {\n *     Label: $protobuf.Enum,\n *     Type: $protobuf.Enum\n * }\n */  /**\n * Reflected oneof descriptor proto.\n * @name OneofDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum descriptor proto.\n * @name EnumDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected service descriptor proto.\n * @name ServiceDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum value descriptor proto.\n * @name EnumValueDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected method descriptor proto.\n * @name MethodDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected file options.\n * @name FileOptions\n * @type {Type}\n * @property {Enum} OptimizeMode\n * @const\n * @tstype $protobuf.Type & {\n *     OptimizeMode: $protobuf.Enum\n * }\n */  /**\n * Reflected message options.\n * @name MessageOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected field options.\n * @name FieldOptions\n * @type {Type}\n * @property {Enum} CType\n * @property {Enum} JSType\n * @const\n * @tstype $protobuf.Type & {\n *     CType: $protobuf.Enum,\n *     JSType: $protobuf.Enum\n * }\n */  /**\n * Reflected oneof options.\n * @name OneofOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum options.\n * @name EnumOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum value options.\n * @name EnumValueOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected service options.\n * @name ServiceOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected method options.\n * @name MethodOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected uninterpretet option.\n * @name UninterpretedOption\n * @type {Type}\n * @property {Type} NamePart\n * @const\n * @tstype $protobuf.Type & {\n *     NamePart: $protobuf.Type\n * }\n */  /**\n * Reflected source code info.\n * @name SourceCodeInfo\n * @type {Type}\n * @property {Type} Location\n * @const\n * @tstype $protobuf.Type & {\n *     Location: $protobuf.Type\n * }\n */  /**\n * Reflected generated code info.\n * @name GeneratedCodeInfo\n * @type {Type}\n * @property {Type} Annotation\n * @const\n * @tstype $protobuf.Type & {\n *     Annotation: $protobuf.Type\n * }\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9leHQvZGVzY3JpcHRvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFlBQVlDLG1CQUFPQSxDQUFDLHVEQUFPO0FBQy9CQyxPQUFPQyxPQUFPLEdBQUdBLFVBQVVILFVBQVVJLFVBQVUsR0FBR0osVUFBVUssSUFBSSxDQUFDQyxRQUFRLENBQUNMLG1CQUFPQSxDQUFDLDhHQUF1QyxHQUFHTSxNQUFNLENBQUM7QUFFbkksSUFBSUMsWUFBWVIsVUFBVVEsU0FBUyxFQUMvQkgsT0FBWUwsVUFBVUssSUFBSSxFQUMxQkksT0FBWVQsVUFBVVMsSUFBSSxFQUMxQkMsT0FBWVYsVUFBVVUsSUFBSSxFQUMxQkMsUUFBWVgsVUFBVVcsS0FBSyxFQUMzQkMsV0FBWVosVUFBVVksUUFBUSxFQUM5QkMsUUFBWWIsVUFBVWEsS0FBSyxFQUMzQkMsVUFBWWQsVUFBVWMsT0FBTyxFQUM3QkMsU0FBWWYsVUFBVWUsTUFBTTtBQUVoQyxlQUFlO0FBRWY7Ozs7Q0FJQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUVEOzs7Ozs7O0NBT0MsR0FFRDs7OztDQUlDLEdBQ0RWLEtBQUtXLGNBQWMsR0FBRyxTQUFTQSxlQUFlWixVQUFVO0lBRXBELDBEQUEwRDtJQUMxRCxJQUFJLE9BQU9BLFdBQVdhLE1BQU0sS0FBSyxVQUM3QmIsYUFBYUQsUUFBUWUsaUJBQWlCLENBQUNDLE1BQU0sQ0FBQ2Y7SUFFbEQsSUFBSWdCLE9BQU8sSUFBSWY7SUFFZixJQUFJRCxXQUFXaUIsSUFBSSxFQUFFO1FBQ2pCLElBQUlDLGdCQUNBQztRQUNKLElBQUssSUFBSUMsSUFBSSxHQUFHQyxHQUFHRCxJQUFJcEIsV0FBV2lCLElBQUksQ0FBQ0osTUFBTSxFQUFFLEVBQUVPLEVBQUc7WUFDaERELGNBQWNIO1lBQ2QsSUFBSSxDQUFDRSxpQkFBaUJsQixXQUFXaUIsSUFBSSxDQUFDRyxF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LEdBQUc7SUFDbkIsT0FBT0EsSUFBSW5ILFNBQVMsQ0FBQyxHQUFFLEtBQ2hCbUgsSUFBSW5ILFNBQVMsQ0FBQyxHQUNUQyxPQUFPLENBQUMsdUJBQXVCLFNBQVNtSCxFQUFFLEVBQUVDLEVBQUU7UUFBSSxPQUFPLE1BQU1BLEdBQUdDLFdBQVc7SUFBSTtBQUNqRyxFQUVBLGtCQUFrQjtDQUVsQjs7Ozs7O0NBTUMsSUFFRDs7Ozs7O0NBTUMsSUFFRDs7Ozs7Ozs7Ozs7Q0FXQyxJQUVEOzs7Ozs7Ozs7OztDQVdDLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7Ozs7OztDQVNDLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7Ozs7Ozs7O0NBV0MsSUFFRDs7Ozs7O0NBTUMsSUFFRDs7Ozs7O0NBTUMsSUFFRDs7Ozs7O0NBTUMsSUFFRDs7Ozs7O0NBTUMsSUFFRDs7Ozs7O0NBTUMsSUFFRDs7Ozs7Ozs7O0NBU0MsSUFFRDs7Ozs7Ozs7O0NBU0MsSUFFRDs7Ozs7Ozs7O0NBU0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvZXh0L2Rlc2NyaXB0b3IvaW5kZXguanM/NzhjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciAkcHJvdG9idWYgPSByZXF1aXJlKFwiLi4vLi5cIik7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSAkcHJvdG9idWYuZGVzY3JpcHRvciA9ICRwcm90b2J1Zi5Sb290LmZyb21KU09OKHJlcXVpcmUoXCIuLi8uLi9nb29nbGUvcHJvdG9idWYvZGVzY3JpcHRvci5qc29uXCIpKS5sb29rdXAoXCIuZ29vZ2xlLnByb3RvYnVmXCIpO1xuXG52YXIgTmFtZXNwYWNlID0gJHByb3RvYnVmLk5hbWVzcGFjZSxcbiAgICBSb290ICAgICAgPSAkcHJvdG9idWYuUm9vdCxcbiAgICBFbnVtICAgICAgPSAkcHJvdG9idWYuRW51bSxcbiAgICBUeXBlICAgICAgPSAkcHJvdG9idWYuVHlwZSxcbiAgICBGaWVsZCAgICAgPSAkcHJvdG9idWYuRmllbGQsXG4gICAgTWFwRmllbGQgID0gJHByb3RvYnVmLk1hcEZpZWxkLFxuICAgIE9uZU9mICAgICA9ICRwcm90b2J1Zi5PbmVPZixcbiAgICBTZXJ2aWNlICAgPSAkcHJvdG9idWYuU2VydmljZSxcbiAgICBNZXRob2QgICAgPSAkcHJvdG9idWYuTWV0aG9kO1xuXG4vLyAtLS0gUm9vdCAtLS1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgRmlsZURlc2NyaXB0b3JTZXQgbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSUZpbGVEZXNjcmlwdG9yU2V0XG4gKiBAcHJvcGVydHkge0lGaWxlRGVzY3JpcHRvclByb3RvW119IGZpbGUgRmlsZXNcbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBGaWxlRGVzY3JpcHRvclByb3RvIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElGaWxlRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIEZpbGUgbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwYWNrYWdlXSBQYWNrYWdlXG4gKiBAcHJvcGVydHkgeyp9IFtkZXBlbmRlbmN5XSBOb3Qgc3VwcG9ydGVkXG4gKiBAcHJvcGVydHkgeyp9IFtwdWJsaWNEZXBlbmRlbmN5XSBOb3Qgc3VwcG9ydGVkXG4gKiBAcHJvcGVydHkgeyp9IFt3ZWFrRGVwZW5kZW5jeV0gTm90IHN1cHBvcnRlZFxuICogQHByb3BlcnR5IHtJRGVzY3JpcHRvclByb3RvW119IFttZXNzYWdlVHlwZV0gTmVzdGVkIG1lc3NhZ2UgdHlwZXNcbiAqIEBwcm9wZXJ0eSB7SUVudW1EZXNjcmlwdG9yUHJvdG9bXX0gW2VudW1UeXBlXSBOZXN0ZWQgZW51bXNcbiAqIEBwcm9wZXJ0eSB7SVNlcnZpY2VEZXNjcmlwdG9yUHJvdG9bXX0gW3NlcnZpY2VdIE5lc3RlZCBzZXJ2aWNlc1xuICogQHByb3BlcnR5IHtJRmllbGREZXNjcmlwdG9yUHJvdG9bXX0gW2V4dGVuc2lvbl0gTmVzdGVkIGV4dGVuc2lvbiBmaWVsZHNcbiAqIEBwcm9wZXJ0eSB7SUZpbGVPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9uc1xuICogQHByb3BlcnR5IHsqfSBbc291cmNlQ29kZUluZm9dIE5vdCBzdXBwb3J0ZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3ludGF4PVwicHJvdG8yXCJdIFN5bnRheFxuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIEZpbGVPcHRpb25zIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElGaWxlT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtqYXZhUGFja2FnZV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbamF2YU91dGVyQ2xhc3NuYW1lXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbamF2YU11bHRpcGxlRmlsZXNdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtqYXZhR2VuZXJhdGVFcXVhbHNBbmRIYXNoXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbamF2YVN0cmluZ0NoZWNrVXRmOF1cbiAqIEBwcm9wZXJ0eSB7SUZpbGVPcHRpb25zT3B0aW1pemVNb2RlfSBbb3B0aW1pemVGb3I9MV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ29QYWNrYWdlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbY2NHZW5lcmljU2VydmljZXNdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtqYXZhR2VuZXJpY1NlcnZpY2VzXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbcHlHZW5lcmljU2VydmljZXNdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZXByZWNhdGVkXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbY2NFbmFibGVBcmVuYXNdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW29iamNDbGFzc1ByZWZpeF1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY3NoYXJwTmFtZXNwYWNlXVxuICovXG5cbi8qKlxuICogVmFsdWVzIG9mIGhlIEZpbGVPcHRpb25zLk9wdGltaXplTW9kZSBlbnVtLlxuICogQHR5cGVkZWYgSUZpbGVPcHRpb25zT3B0aW1pemVNb2RlXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFNQRUVEPTFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBDT0RFX1NJWkU9MlxuICogQHByb3BlcnR5IHtudW1iZXJ9IExJVEVfUlVOVElNRT0zXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgcm9vdCBmcm9tIGEgZGVzY3JpcHRvciBzZXQuXG4gKiBAcGFyYW0ge0lGaWxlRGVzY3JpcHRvclNldHxSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7Um9vdH0gUm9vdCBpbnN0YW5jZVxuICovXG5Sb290LmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvcikge1xuXG4gICAgLy8gRGVjb2RlIHRoZSBkZXNjcmlwdG9yIG1lc3NhZ2UgaWYgc3BlY2lmaWVkIGFzIGEgYnVmZmVyOlxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGRlc2NyaXB0b3IgPSBleHBvcnRzLkZpbGVEZXNjcmlwdG9yU2V0LmRlY29kZShkZXNjcmlwdG9yKTtcblxuICAgIHZhciByb290ID0gbmV3IFJvb3QoKTtcblxuICAgIGlmIChkZXNjcmlwdG9yLmZpbGUpIHtcbiAgICAgICAgdmFyIGZpbGVEZXNjcmlwdG9yLFxuICAgICAgICAgICAgZmlsZVBhY2thZ2U7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBpOyBqIDwgZGVzY3JpcHRvci5maWxlLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBmaWxlUGFja2FnZSA9IHJvb3Q7XG4gICAgICAgICAgICBpZiAoKGZpbGVEZXNjcmlwdG9yID0gZGVzY3JpcHRvci5maWxlW2pdKVtcInBhY2thZ2VcIl0gJiYgZmlsZURlc2NyaXB0b3JbXCJwYWNrYWdlXCJdLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmaWxlUGFja2FnZSA9IHJvb3QuZGVmaW5lKGZpbGVEZXNjcmlwdG9yW1wicGFja2FnZVwiXSk7XG4gICAgICAgICAgICBpZiAoZmlsZURlc2NyaXB0b3IubmFtZSAmJiBmaWxlRGVzY3JpcHRvci5uYW1lLmxlbmd0aClcbiAgICAgICAgICAgICAgICByb290LmZpbGVzLnB1c2goZmlsZVBhY2thZ2UuZmlsZW5hbWUgPSBmaWxlRGVzY3JpcHRvci5uYW1lKTtcbiAgICAgICAgICAgIGlmIChmaWxlRGVzY3JpcHRvci5tZXNzYWdlVHlwZSlcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZURlc2NyaXB0b3IubWVzc2FnZVR5cGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYWNrYWdlLmFkZChUeXBlLmZyb21EZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yLm1lc3NhZ2VUeXBlW2ldLCBmaWxlRGVzY3JpcHRvci5zeW50YXgpKTtcbiAgICAgICAgICAgIGlmIChmaWxlRGVzY3JpcHRvci5lbnVtVHlwZSlcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZURlc2NyaXB0b3IuZW51bVR5cGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYWNrYWdlLmFkZChFbnVtLmZyb21EZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yLmVudW1UeXBlW2ldKSk7XG4gICAgICAgICAgICBpZiAoZmlsZURlc2NyaXB0b3IuZXh0ZW5zaW9uKVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWxlRGVzY3JpcHRvci5leHRlbnNpb24ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYWNrYWdlLmFkZChGaWVsZC5mcm9tRGVzY3JpcHRvcihmaWxlRGVzY3JpcHRvci5leHRlbnNpb25baV0pKTtcbiAgICAgICAgICAgIGlmIChmaWxlRGVzY3JpcHRvci5zZXJ2aWNlKVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWxlRGVzY3JpcHRvci5zZXJ2aWNlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBmaWxlUGFja2FnZS5hZGQoU2VydmljZS5mcm9tRGVzY3JpcHRvcihmaWxlRGVzY3JpcHRvci5zZXJ2aWNlW2ldKSk7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IGZyb21EZXNjcmlwdG9yT3B0aW9ucyhmaWxlRGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLkZpbGVPcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtzID0gT2JqZWN0LmtleXMob3B0cyk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBmaWxlUGFja2FnZS5zZXRPcHRpb24oa3NbaV0sIG9wdHNba3NbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByb290O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHJvb3QgdG8gYSBkZXNjcmlwdG9yIHNldC5cbiAqIEByZXR1cm5zIHtNZXNzYWdlPElGaWxlRGVzY3JpcHRvclNldD59IERlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3ludGF4PVwicHJvdG8yXCJdIFN5bnRheFxuICovXG5Sb290LnByb3RvdHlwZS50b0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiB0b0Rlc2NyaXB0b3Ioc3ludGF4KSB7XG4gICAgdmFyIHNldCA9IGV4cG9ydHMuRmlsZURlc2NyaXB0b3JTZXQuY3JlYXRlKCk7XG4gICAgUm9vdF90b0Rlc2NyaXB0b3JSZWN1cnNpdmUodGhpcywgc2V0LmZpbGUsIHN5bnRheCk7XG4gICAgcmV0dXJuIHNldDtcbn07XG5cbi8vIFRyYXZlcnNlcyBhIG5hbWVzcGFjZSBhbmQgYXNzZW1ibGVzIHRoZSBkZXNjcmlwdG9yIHNldFxuZnVuY3Rpb24gUm9vdF90b0Rlc2NyaXB0b3JSZWN1cnNpdmUobnMsIGZpbGVzLCBzeW50YXgpIHtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBmaWxlXG4gICAgdmFyIGZpbGUgPSBleHBvcnRzLkZpbGVEZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHsgbmFtZTogbnMuZmlsZW5hbWUgfHwgKG5zLmZ1bGxOYW1lLnN1YnN0cmluZygxKS5yZXBsYWNlKC9cXC4vZywgXCJfXCIpIHx8IFwicm9vdFwiKSArIFwiLnByb3RvXCIgfSk7XG4gICAgaWYgKHN5bnRheClcbiAgICAgICAgZmlsZS5zeW50YXggPSBzeW50YXg7XG4gICAgaWYgKCEobnMgaW5zdGFuY2VvZiBSb290KSlcbiAgICAgICAgZmlsZVtcInBhY2thZ2VcIl0gPSBucy5mdWxsTmFtZS5zdWJzdHJpbmcoMSk7XG5cbiAgICAvLyBBZGQgbmVzdGVkIHR5cGVzXG4gICAgZm9yICh2YXIgaSA9IDAsIG5lc3RlZDsgaSA8IG5zLm5lc3RlZEFycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoKG5lc3RlZCA9IG5zLl9uZXN0ZWRBcnJheVtpXSkgaW5zdGFuY2VvZiBUeXBlKVxuICAgICAgICAgICAgZmlsZS5tZXNzYWdlVHlwZS5wdXNoKG5lc3RlZC50b0Rlc2NyaXB0b3Ioc3ludGF4KSk7XG4gICAgICAgIGVsc2UgaWYgKG5lc3RlZCBpbnN0YW5jZW9mIEVudW0pXG4gICAgICAgICAgICBmaWxlLmVudW1UeXBlLnB1c2gobmVzdGVkLnRvRGVzY3JpcHRvcigpKTtcbiAgICAgICAgZWxzZSBpZiAobmVzdGVkIGluc3RhbmNlb2YgRmllbGQpXG4gICAgICAgICAgICBmaWxlLmV4dGVuc2lvbi5wdXNoKG5lc3RlZC50b0Rlc2NyaXB0b3Ioc3ludGF4KSk7XG4gICAgICAgIGVsc2UgaWYgKG5lc3RlZCBpbnN0YW5jZW9mIFNlcnZpY2UpXG4gICAgICAgICAgICBmaWxlLnNlcnZpY2UucHVzaChuZXN0ZWQudG9EZXNjcmlwdG9yKCkpO1xuICAgICAgICBlbHNlIGlmIChuZXN0ZWQgaW5zdGFuY2VvZiAvKiBwbGFpbiAqLyBOYW1lc3BhY2UpXG4gICAgICAgICAgICBSb290X3RvRGVzY3JpcHRvclJlY3Vyc2l2ZShuZXN0ZWQsIGZpbGVzLCBzeW50YXgpOyAvLyByZXF1aXJlcyBuZXcgZmlsZVxuXG4gICAgLy8gS2VlcCBwYWNrYWdlLWxldmVsIG9wdGlvbnNcbiAgICBmaWxlLm9wdGlvbnMgPSB0b0Rlc2NyaXB0b3JPcHRpb25zKG5zLm9wdGlvbnMsIGV4cG9ydHMuRmlsZU9wdGlvbnMpO1xuXG4gICAgLy8gQW5kIGtlZXAgdGhlIGZpbGUgb25seSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbmVzdGVkIG9iamVjdFxuICAgIGlmIChmaWxlLm1lc3NhZ2VUeXBlLmxlbmd0aCArIGZpbGUuZW51bVR5cGUubGVuZ3RoICsgZmlsZS5leHRlbnNpb24ubGVuZ3RoICsgZmlsZS5zZXJ2aWNlLmxlbmd0aClcbiAgICAgICAgZmlsZXMucHVzaChmaWxlKTtcbn1cblxuLy8gLS0tIFR5cGUgLS0tXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIERlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIE1lc3NhZ2UgdHlwZSBuYW1lXG4gKiBAcHJvcGVydHkge0lGaWVsZERlc2NyaXB0b3JQcm90b1tdfSBbZmllbGRdIEZpZWxkc1xuICogQHByb3BlcnR5IHtJRmllbGREZXNjcmlwdG9yUHJvdG9bXX0gW2V4dGVuc2lvbl0gRXh0ZW5zaW9uIGZpZWxkc1xuICogQHByb3BlcnR5IHtJRGVzY3JpcHRvclByb3RvW119IFtuZXN0ZWRUeXBlXSBOZXN0ZWQgbWVzc2FnZSB0eXBlc1xuICogQHByb3BlcnR5IHtJRW51bURlc2NyaXB0b3JQcm90b1tdfSBbZW51bVR5cGVdIE5lc3RlZCBlbnVtc1xuICogQHByb3BlcnR5IHtJRGVzY3JpcHRvclByb3RvRXh0ZW5zaW9uUmFuZ2VbXX0gW2V4dGVuc2lvblJhbmdlXSBFeHRlbnNpb24gcmFuZ2VzXG4gKiBAcHJvcGVydHkge0lPbmVvZkRlc2NyaXB0b3JQcm90b1tdfSBbb25lb2ZEZWNsXSBPbmVvZnNcbiAqIEBwcm9wZXJ0eSB7SU1lc3NhZ2VPcHRpb25zfSBbb3B0aW9uc10gTm90IHN1cHBvcnRlZFxuICogQHByb3BlcnR5IHtJRGVzY3JpcHRvclByb3RvUmVzZXJ2ZWRSYW5nZVtdfSBbcmVzZXJ2ZWRSYW5nZV0gUmVzZXJ2ZWQgcmFuZ2VzXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBbcmVzZXJ2ZWROYW1lXSBSZXNlcnZlZCBuYW1lc1xuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIE1lc3NhZ2VPcHRpb25zIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElNZXNzYWdlT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbbWFwRW50cnk9ZmFsc2VdIFdoZXRoZXIgdGhpcyBtZXNzYWdlIGlzIGEgbWFwIGVudHJ5XG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGFuIEV4dGVuc2lvblJhbmdlIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElEZXNjcmlwdG9yUHJvdG9FeHRlbnNpb25SYW5nZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzdGFydF0gU3RhcnQgZmllbGQgaWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZW5kXSBFbmQgZmllbGQgaWRcbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBSZXNlcnZlZFJhbmdlIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElEZXNjcmlwdG9yUHJvdG9SZXNlcnZlZFJhbmdlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N0YXJ0XSBTdGFydCBmaWVsZCBpZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtlbmRdIEVuZCBmaWVsZCBpZFxuICovXG5cbnZhciB1bm5hbWVkTWVzc2FnZUluZGV4ID0gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgdHlwZSBmcm9tIGEgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SURlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N5bnRheD1cInByb3RvMlwiXSBTeW50YXhcbiAqIEByZXR1cm5zIHtUeXBlfSBUeXBlIGluc3RhbmNlXG4gKi9cblR5cGUuZnJvbURlc2NyaXB0b3IgPSBmdW5jdGlvbiBmcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLCBzeW50YXgpIHtcblxuICAgIC8vIERlY29kZSB0aGUgZGVzY3JpcHRvciBtZXNzYWdlIGlmIHNwZWNpZmllZCBhcyBhIGJ1ZmZlcjpcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICBkZXNjcmlwdG9yID0gZXhwb3J0cy5EZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBtZXNzYWdlIHR5cGVcbiAgICB2YXIgdHlwZSA9IG5ldyBUeXBlKGRlc2NyaXB0b3IubmFtZS5sZW5ndGggPyBkZXNjcmlwdG9yLm5hbWUgOiBcIlR5cGVcIiArIHVubmFtZWRNZXNzYWdlSW5kZXgrKywgZnJvbURlc2NyaXB0b3JPcHRpb25zKGRlc2NyaXB0b3Iub3B0aW9ucywgZXhwb3J0cy5NZXNzYWdlT3B0aW9ucykpLFxuICAgICAgICBpO1xuXG4gICAgLyogT25lb2ZzICovIGlmIChkZXNjcmlwdG9yLm9uZW9mRGVjbClcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlc2NyaXB0b3Iub25lb2ZEZWNsLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdHlwZS5hZGQoT25lT2YuZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvci5vbmVvZkRlY2xbaV0pKTtcbiAgICAvKiBGaWVsZHMgKi8gaWYgKGRlc2NyaXB0b3IuZmllbGQpXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLmZpZWxkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBGaWVsZC5mcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLmZpZWxkW2ldLCBzeW50YXgpO1xuICAgICAgICAgICAgdHlwZS5hZGQoZmllbGQpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IuZmllbGRbaV0uaGFzT3duUHJvcGVydHkoXCJvbmVvZkluZGV4XCIpKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICAgICAgIHR5cGUub25lb2ZzQXJyYXlbZGVzY3JpcHRvci5maWVsZFtpXS5vbmVvZkluZGV4XS5hZGQoZmllbGQpO1xuICAgICAgICB9XG4gICAgLyogRXh0ZW5zaW9uIGZpZWxkcyAqLyBpZiAoZGVzY3JpcHRvci5leHRlbnNpb24pXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLmV4dGVuc2lvbi5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHR5cGUuYWRkKEZpZWxkLmZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IuZXh0ZW5zaW9uW2ldLCBzeW50YXgpKTtcbiAgICAvKiBOZXN0ZWQgdHlwZXMgKi8gaWYgKGRlc2NyaXB0b3IubmVzdGVkVHlwZSlcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlc2NyaXB0b3IubmVzdGVkVHlwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdHlwZS5hZGQoVHlwZS5mcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLm5lc3RlZFR5cGVbaV0sIHN5bnRheCkpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IubmVzdGVkVHlwZVtpXS5vcHRpb25zICYmIGRlc2NyaXB0b3IubmVzdGVkVHlwZVtpXS5vcHRpb25zLm1hcEVudHJ5KVxuICAgICAgICAgICAgICAgIHR5cGUuc2V0T3B0aW9uKFwibWFwX2VudHJ5XCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgLyogTmVzdGVkIGVudW1zICovIGlmIChkZXNjcmlwdG9yLmVudW1UeXBlKVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVzY3JpcHRvci5lbnVtVHlwZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHR5cGUuYWRkKEVudW0uZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvci5lbnVtVHlwZVtpXSkpO1xuICAgIC8qIEV4dGVuc2lvbiByYW5nZXMgKi8gaWYgKGRlc2NyaXB0b3IuZXh0ZW5zaW9uUmFuZ2UgJiYgZGVzY3JpcHRvci5leHRlbnNpb25SYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgdHlwZS5leHRlbnNpb25zID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLmV4dGVuc2lvblJhbmdlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdHlwZS5leHRlbnNpb25zLnB1c2goWyBkZXNjcmlwdG9yLmV4dGVuc2lvblJhbmdlW2ldLnN0YXJ0LCBkZXNjcmlwdG9yLmV4dGVuc2lvblJhbmdlW2ldLmVuZCBdKTtcbiAgICB9XG4gICAgLyogUmVzZXJ2ZWQuLi4gKi8gaWYgKGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZSAmJiBkZXNjcmlwdG9yLnJlc2VydmVkUmFuZ2UubGVuZ3RoIHx8IGRlc2NyaXB0b3IucmVzZXJ2ZWROYW1lICYmIGRlc2NyaXB0b3IucmVzZXJ2ZWROYW1lLmxlbmd0aCkge1xuICAgICAgICB0eXBlLnJlc2VydmVkID0gW107XG4gICAgICAgIC8qIFJhbmdlcyAqLyBpZiAoZGVzY3JpcHRvci5yZXNlcnZlZFJhbmdlKVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB0eXBlLnJlc2VydmVkLnB1c2goWyBkZXNjcmlwdG9yLnJlc2VydmVkUmFuZ2VbaV0uc3RhcnQsIGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZVtpXS5lbmQgXSk7XG4gICAgICAgIC8qIE5hbWVzICovIGlmIChkZXNjcmlwdG9yLnJlc2VydmVkTmFtZSlcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLnJlc2VydmVkTmFtZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB0eXBlLnJlc2VydmVkLnB1c2goZGVzY3JpcHRvci5yZXNlcnZlZE5hbWVbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHR5cGUgdG8gYSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge01lc3NhZ2U8SURlc2NyaXB0b3JQcm90bz59IERlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3ludGF4PVwicHJvdG8yXCJdIFN5bnRheFxuICovXG5UeXBlLnByb3RvdHlwZS50b0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiB0b0Rlc2NyaXB0b3Ioc3ludGF4KSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBleHBvcnRzLkRlc2NyaXB0b3JQcm90by5jcmVhdGUoeyBuYW1lOiB0aGlzLm5hbWUgfSksXG4gICAgICAgIGk7XG5cbiAgICAvKiBGaWVsZHMgKi8gZm9yIChpID0gMDsgaSA8IHRoaXMuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkRGVzY3JpcHRvcjtcbiAgICAgICAgZGVzY3JpcHRvci5maWVsZC5wdXNoKGZpZWxkRGVzY3JpcHRvciA9IHRoaXMuX2ZpZWxkc0FycmF5W2ldLnRvRGVzY3JpcHRvcihzeW50YXgpKTtcbiAgICAgICAgaWYgKHRoaXMuX2ZpZWxkc0FycmF5W2ldIGluc3RhbmNlb2YgTWFwRmllbGQpIHsgLy8gbWFwIGZpZWxkcyBhcmUgcmVwZWF0ZWQgRmllbGROYW1lRW50cnlcbiAgICAgICAgICAgIHZhciBrZXlUeXBlID0gdG9EZXNjcmlwdG9yVHlwZSh0aGlzLl9maWVsZHNBcnJheVtpXS5rZXlUeXBlLCB0aGlzLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlZEtleVR5cGUpLFxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IHRvRGVzY3JpcHRvclR5cGUodGhpcy5fZmllbGRzQXJyYXlbaV0udHlwZSwgdGhpcy5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZWRUeXBlKSxcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGVOYW1lID0gdmFsdWVUeXBlID09PSAvKiB0eXBlICovIDExIHx8IHZhbHVlVHlwZSA9PT0gLyogZW51bSAqLyAxNFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmVkVHlwZSAmJiBzaG9ydG5hbWUodGhpcy5wYXJlbnQsIHRoaXMuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmVkVHlwZSkgfHwgdGhpcy5fZmllbGRzQXJyYXlbaV0udHlwZVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IubmVzdGVkVHlwZS5wdXNoKGV4cG9ydHMuRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogZmllbGREZXNjcmlwdG9yLnR5cGVOYW1lLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBbXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuRmllbGREZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHsgbmFtZTogXCJrZXlcIiwgbnVtYmVyOiAxLCBsYWJlbDogMSwgdHlwZToga2V5VHlwZSB9KSwgLy8gY2FuJ3QgcmVmZXJlbmNlIGEgdHlwZSBvciBlbnVtXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuRmllbGREZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHsgbmFtZTogXCJ2YWx1ZVwiLCBudW1iZXI6IDIsIGxhYmVsOiAxLCB0eXBlOiB2YWx1ZVR5cGUsIHR5cGVOYW1lOiB2YWx1ZVR5cGVOYW1lIH0pXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHBvcnRzLk1lc3NhZ2VPcHRpb25zLmNyZWF0ZSh7IG1hcEVudHJ5OiB0cnVlIH0pXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogT25lb2ZzICovIGZvciAoaSA9IDA7IGkgPCB0aGlzLm9uZW9mc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICBkZXNjcmlwdG9yLm9uZW9mRGVjbC5wdXNoKHRoaXMuX29uZW9mc0FycmF5W2ldLnRvRGVzY3JpcHRvcigpKTtcbiAgICAvKiBOZXN0ZWQuLi4gKi8gZm9yIChpID0gMDsgaSA8IHRoaXMubmVzdGVkQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgLyogRXh0ZW5zaW9uIGZpZWxkcyAqLyBpZiAodGhpcy5fbmVzdGVkQXJyYXlbaV0gaW5zdGFuY2VvZiBGaWVsZClcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZmllbGQucHVzaCh0aGlzLl9uZXN0ZWRBcnJheVtpXS50b0Rlc2NyaXB0b3Ioc3ludGF4KSk7XG4gICAgICAgIC8qIFR5cGVzICovIGVsc2UgaWYgKHRoaXMuX25lc3RlZEFycmF5W2ldIGluc3RhbmNlb2YgVHlwZSlcbiAgICAgICAgICAgIGRlc2NyaXB0b3IubmVzdGVkVHlwZS5wdXNoKHRoaXMuX25lc3RlZEFycmF5W2ldLnRvRGVzY3JpcHRvcihzeW50YXgpKTtcbiAgICAgICAgLyogRW51bXMgKi8gZWxzZSBpZiAodGhpcy5fbmVzdGVkQXJyYXlbaV0gaW5zdGFuY2VvZiBFbnVtKVxuICAgICAgICAgICAgZGVzY3JpcHRvci5lbnVtVHlwZS5wdXNoKHRoaXMuX25lc3RlZEFycmF5W2ldLnRvRGVzY3JpcHRvcigpKTtcbiAgICAgICAgLy8gcGxhaW4gbmVzdGVkIG5hbWVzcGFjZXMgYmVjb21lIHBhY2thZ2VzIGluc3RlYWQgaW4gUm9vdCN0b0Rlc2NyaXB0b3JcbiAgICB9XG4gICAgLyogRXh0ZW5zaW9uIHJhbmdlcyAqLyBpZiAodGhpcy5leHRlbnNpb25zKVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5leHRlbnNpb25zLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgZGVzY3JpcHRvci5leHRlbnNpb25SYW5nZS5wdXNoKGV4cG9ydHMuRGVzY3JpcHRvclByb3RvLkV4dGVuc2lvblJhbmdlLmNyZWF0ZSh7IHN0YXJ0OiB0aGlzLmV4dGVuc2lvbnNbaV1bMF0sIGVuZDogdGhpcy5leHRlbnNpb25zW2ldWzFdIH0pKTtcbiAgICAvKiBSZXNlcnZlZC4uLiAqLyBpZiAodGhpcy5yZXNlcnZlZClcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVzZXJ2ZWQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAvKiBOYW1lcyAqLyBpZiAodHlwZW9mIHRoaXMucmVzZXJ2ZWRbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5yZXNlcnZlZE5hbWUucHVzaCh0aGlzLnJlc2VydmVkW2ldKTtcbiAgICAgICAgICAgIC8qIFJhbmdlcyAqLyBlbHNlXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5yZXNlcnZlZFJhbmdlLnB1c2goZXhwb3J0cy5EZXNjcmlwdG9yUHJvdG8uUmVzZXJ2ZWRSYW5nZS5jcmVhdGUoeyBzdGFydDogdGhpcy5yZXNlcnZlZFtpXVswXSwgZW5kOiB0aGlzLnJlc2VydmVkW2ldWzFdIH0pKTtcblxuICAgIGRlc2NyaXB0b3Iub3B0aW9ucyA9IHRvRGVzY3JpcHRvck9wdGlvbnModGhpcy5vcHRpb25zLCBleHBvcnRzLk1lc3NhZ2VPcHRpb25zKTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxuLy8gLS0tIEZpZWxkIC0tLVxuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBGaWVsZERlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRmllbGREZXNjcmlwdG9yUHJvdG9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gRmllbGQgbmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtudW1iZXJdIEZpZWxkIGlkXG4gKiBAcHJvcGVydHkge0lGaWVsZERlc2NyaXB0b3JQcm90b0xhYmVsfSBbbGFiZWxdIEZpZWxkIHJ1bGVcbiAqIEBwcm9wZXJ0eSB7SUZpZWxkRGVzY3JpcHRvclByb3RvVHlwZX0gW3R5cGVdIEZpZWxkIGJhc2ljIHR5cGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZU5hbWVdIEZpZWxkIHR5cGUgbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtleHRlbmRlZV0gRXh0ZW5kZWQgdHlwZSBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2RlZmF1bHRWYWx1ZV0gTGl0ZXJhbCBkZWZhdWx0IHZhbHVlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29uZW9mSW5kZXhdIE9uZW9mIGluZGV4IGlmIHBhcnQgb2YgYSBvbmVvZlxuICogQHByb3BlcnR5IHsqfSBbanNvbk5hbWVdIE5vdCBzdXBwb3J0ZWRcbiAqIEBwcm9wZXJ0eSB7SUZpZWxkT3B0aW9uc30gW29wdGlvbnNdIEZpZWxkIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIFZhbHVlcyBvZiB0aGUgRmllbGREZXNjcmlwdG9yUHJvdG8uTGFiZWwgZW51bS5cbiAqIEB0eXBlZGVmIElGaWVsZERlc2NyaXB0b3JQcm90b0xhYmVsXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHByb3BlcnR5IHtudW1iZXJ9IExBQkVMX09QVElPTkFMPTFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMQUJFTF9SRVFVSVJFRD0yXG4gKiBAcHJvcGVydHkge251bWJlcn0gTEFCRUxfUkVQRUFURUQ9M1xuICovXG5cbi8qKlxuICogVmFsdWVzIG9mIHRoZSBGaWVsZERlc2NyaXB0b3JQcm90by5UeXBlIGVudW0uXG4gKiBAdHlwZWRlZiBJRmllbGREZXNjcmlwdG9yUHJvdG9UeXBlXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfRE9VQkxFPTFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0ZMT0FUPTJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0lOVDY0PTNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX1VJTlQ2ND00XG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9JTlQzMj01XG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9GSVhFRDY0PTZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0ZJWEVEMzI9N1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfQk9PTD04XG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9TVFJJTkc9OVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfR1JPVVA9MTBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX01FU1NBR0U9MTFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0JZVEVTPTEyXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9VSU5UMzI9MTNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0VOVU09MTRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX1NGSVhFRDMyPTE1XG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9TRklYRUQ2ND0xNlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfU0lOVDMyPTE3XG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9TSU5UNjQ9MThcbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBGaWVsZE9wdGlvbnMgbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSUZpZWxkT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbcGFja2VkXSBXaGV0aGVyIHBhY2tlZCBvciBub3QgKGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHByb3RvMiBhbmQgYHRydWVgIGZvciBwcm90bzMpXG4gKiBAcHJvcGVydHkge0lGaWVsZE9wdGlvbnNKU1R5cGV9IFtqc3R5cGVdIEphdmFTY3JpcHQgdmFsdWUgdHlwZSAobm90IHVzZWQgYnkgcHJvdG9idWYuanMpXG4gKi9cblxuLyoqXG4gKiBWYWx1ZXMgb2YgdGhlIEZpZWxkT3B0aW9ucy5KU1R5cGUgZW51bS5cbiAqIEB0eXBlZGVmIElGaWVsZE9wdGlvbnNKU1R5cGVcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJvcGVydHkge251bWJlcn0gSlNfTk9STUFMPTBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBKU19TVFJJTkc9MVxuICogQHByb3BlcnR5IHtudW1iZXJ9IEpTX05VTUJFUj0yXG4gKi9cblxuLy8gY29waWVkIGhlcmUgZnJvbSBwYXJzZS5qc1xudmFyIG51bWJlclJlID0gL14oPyFbZUVdKVswLTldKig/OlxcLlswLTldKik/KD86W2VFXVsrLV0/WzAtOV0rKT8kLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZmllbGQgZnJvbSBhIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lGaWVsZERlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N5bnRheD1cInByb3RvMlwiXSBTeW50YXhcbiAqIEByZXR1cm5zIHtGaWVsZH0gRmllbGQgaW5zdGFuY2VcbiAqL1xuRmllbGQuZnJvbURlc2NyaXB0b3IgPSBmdW5jdGlvbiBmcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLCBzeW50YXgpIHtcblxuICAgIC8vIERlY29kZSB0aGUgZGVzY3JpcHRvciBtZXNzYWdlIGlmIHNwZWNpZmllZCBhcyBhIGJ1ZmZlcjpcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICBkZXNjcmlwdG9yID0gZXhwb3J0cy5EZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xuXG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLm51bWJlciAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJtaXNzaW5nIGZpZWxkIGlkXCIpO1xuXG4gICAgLy8gUmV3aXJlIGZpZWxkIHR5cGVcbiAgICB2YXIgZmllbGRUeXBlO1xuICAgIGlmIChkZXNjcmlwdG9yLnR5cGVOYW1lICYmIGRlc2NyaXB0b3IudHlwZU5hbWUubGVuZ3RoKVxuICAgICAgICBmaWVsZFR5cGUgPSBkZXNjcmlwdG9yLnR5cGVOYW1lO1xuICAgIGVsc2VcbiAgICAgICAgZmllbGRUeXBlID0gZnJvbURlc2NyaXB0b3JUeXBlKGRlc2NyaXB0b3IudHlwZSk7XG5cbiAgICAvLyBSZXdpcmUgZmllbGQgcnVsZVxuICAgIHZhciBmaWVsZFJ1bGU7XG4gICAgc3dpdGNoIChkZXNjcmlwdG9yLmxhYmVsKSB7XG4gICAgICAgIC8vIDAgaXMgcmVzZXJ2ZWQgZm9yIGVycm9yc1xuICAgICAgICBjYXNlIDE6IGZpZWxkUnVsZSA9IHVuZGVmaW5lZDsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogZmllbGRSdWxlID0gXCJyZXF1aXJlZFwiOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBmaWVsZFJ1bGUgPSBcInJlcGVhdGVkXCI7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBFcnJvcihcImlsbGVnYWwgbGFiZWw6IFwiICsgZGVzY3JpcHRvci5sYWJlbCk7XG4gICAgfVxuXG5cdHZhciBleHRlbmRlZSA9IGRlc2NyaXB0b3IuZXh0ZW5kZWU7XG5cdGlmIChkZXNjcmlwdG9yLmV4dGVuZGVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRleHRlbmRlZSA9IGV4dGVuZGVlLmxlbmd0aCA/IGV4dGVuZGVlIDogdW5kZWZpbmVkO1xuXHR9XG4gICAgdmFyIGZpZWxkID0gbmV3IEZpZWxkKFxuICAgICAgICBkZXNjcmlwdG9yLm5hbWUubGVuZ3RoID8gZGVzY3JpcHRvci5uYW1lIDogXCJmaWVsZFwiICsgZGVzY3JpcHRvci5udW1iZXIsXG4gICAgICAgIGRlc2NyaXB0b3IubnVtYmVyLFxuICAgICAgICBmaWVsZFR5cGUsXG4gICAgICAgIGZpZWxkUnVsZSxcbiAgICAgICAgZXh0ZW5kZWVcbiAgICApO1xuXG4gICAgZmllbGQub3B0aW9ucyA9IGZyb21EZXNjcmlwdG9yT3B0aW9ucyhkZXNjcmlwdG9yLm9wdGlvbnMsIGV4cG9ydHMuRmllbGRPcHRpb25zKTtcblxuICAgIGlmIChkZXNjcmlwdG9yLmRlZmF1bHRWYWx1ZSAmJiBkZXNjcmlwdG9yLmRlZmF1bHRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGRlc2NyaXB0b3IuZGVmYXVsdFZhbHVlO1xuICAgICAgICBzd2l0Y2ggKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInRydWVcIjogY2FzZSBcIlRSVUVcIjpcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZhbHNlXCI6IGNhc2UgXCJGQUxTRVwiOlxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBudW1iZXJSZS5leGVjKGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwYXJzZUludChkZWZhdWx0VmFsdWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJhZGl4XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGQuc2V0T3B0aW9uKFwiZGVmYXVsdFwiLCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChwYWNrYWJsZURlc2NyaXB0b3JUeXBlKGRlc2NyaXB0b3IudHlwZSkpIHtcbiAgICAgICAgaWYgKHN5bnRheCA9PT0gXCJwcm90bzNcIikgeyAvLyBkZWZhdWx0cyB0byBwYWNrZWQ9dHJ1ZSAoaW50ZXJuYWwgcHJlc2V0IGlzIHBhY2tlZD10cnVlKVxuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Iub3B0aW9ucyAmJiAhZGVzY3JpcHRvci5vcHRpb25zLnBhY2tlZClcbiAgICAgICAgICAgICAgICBmaWVsZC5zZXRPcHRpb24oXCJwYWNrZWRcIiwgZmFsc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCEoZGVzY3JpcHRvci5vcHRpb25zICYmIGRlc2NyaXB0b3Iub3B0aW9ucy5wYWNrZWQpKSAvLyBkZWZhdWx0cyB0byBwYWNrZWQ9ZmFsc2VcbiAgICAgICAgICAgIGZpZWxkLnNldE9wdGlvbihcInBhY2tlZFwiLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGZpZWxkIHRvIGEgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtNZXNzYWdlPElGaWVsZERlc2NyaXB0b3JQcm90bz59IERlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3ludGF4PVwicHJvdG8yXCJdIFN5bnRheFxuICovXG5GaWVsZC5wcm90b3R5cGUudG9EZXNjcmlwdG9yID0gZnVuY3Rpb24gdG9EZXNjcmlwdG9yKHN5bnRheCkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gZXhwb3J0cy5GaWVsZERlc2NyaXB0b3JQcm90by5jcmVhdGUoeyBuYW1lOiB0aGlzLm5hbWUsIG51bWJlcjogdGhpcy5pZCB9KTtcblxuICAgIGlmICh0aGlzLm1hcCkge1xuXG4gICAgICAgIGRlc2NyaXB0b3IudHlwZSA9IDExOyAvLyBtZXNzYWdlXG4gICAgICAgIGRlc2NyaXB0b3IudHlwZU5hbWUgPSAkcHJvdG9idWYudXRpbC51Y0ZpcnN0KHRoaXMubmFtZSk7IC8vIGZpZWxkTmFtZSAtPiBGaWVsZE5hbWVFbnRyeSAoYnVpbHQgaW4gVHlwZSN0b0Rlc2NyaXB0b3IpXG4gICAgICAgIGRlc2NyaXB0b3IubGFiZWwgPSAzOyAvLyByZXBlYXRlZFxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBSZXdpcmUgZmllbGQgdHlwZVxuICAgICAgICBzd2l0Y2ggKGRlc2NyaXB0b3IudHlwZSA9IHRvRGVzY3JpcHRvclR5cGUodGhpcy50eXBlLCB0aGlzLnJlc29sdmUoKS5yZXNvbHZlZFR5cGUpKSB7XG4gICAgICAgICAgICBjYXNlIDEwOiAvLyBncm91cFxuICAgICAgICAgICAgY2FzZSAxMTogLy8gdHlwZVxuICAgICAgICAgICAgY2FzZSAxNDogLy8gZW51bVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IudHlwZU5hbWUgPSB0aGlzLnJlc29sdmVkVHlwZSA/IHNob3J0bmFtZSh0aGlzLnBhcmVudCwgdGhpcy5yZXNvbHZlZFR5cGUpIDogdGhpcy50eXBlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV3aXJlIGZpZWxkIHJ1bGVcbiAgICAgICAgc3dpdGNoICh0aGlzLnJ1bGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJyZXBlYXRlZFwiOiBkZXNjcmlwdG9yLmxhYmVsID0gMzsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjogZGVzY3JpcHRvci5sYWJlbCA9IDI7IGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogZGVzY3JpcHRvci5sYWJlbCA9IDE7IGJyZWFrO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZXh0ZW5zaW9uIGZpZWxkXG4gICAgZGVzY3JpcHRvci5leHRlbmRlZSA9IHRoaXMuZXh0ZW5zaW9uRmllbGQgPyB0aGlzLmV4dGVuc2lvbkZpZWxkLnBhcmVudC5mdWxsTmFtZSA6IHRoaXMuZXh0ZW5kO1xuXG4gICAgLy8gSGFuZGxlIHBhcnQgb2Ygb25lb2ZcbiAgICBpZiAodGhpcy5wYXJ0T2YpXG4gICAgICAgIGlmICgoZGVzY3JpcHRvci5vbmVvZkluZGV4ID0gdGhpcy5wYXJlbnQub25lb2ZzQXJyYXkuaW5kZXhPZih0aGlzLnBhcnRPZikpIDwgMClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibWlzc2luZyBvbmVvZlwiKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgZGVzY3JpcHRvci5vcHRpb25zID0gdG9EZXNjcmlwdG9yT3B0aW9ucyh0aGlzLm9wdGlvbnMsIGV4cG9ydHMuRmllbGRPcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tcImRlZmF1bHRcIl0gIT0gbnVsbClcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZGVmYXVsdFZhbHVlID0gU3RyaW5nKHRoaXMub3B0aW9uc1tcImRlZmF1bHRcIl0pO1xuICAgIH1cblxuICAgIGlmIChzeW50YXggPT09IFwicHJvdG8zXCIpIHsgLy8gZGVmYXVsdHMgdG8gcGFja2VkPXRydWVcbiAgICAgICAgaWYgKCF0aGlzLnBhY2tlZClcbiAgICAgICAgICAgIChkZXNjcmlwdG9yLm9wdGlvbnMgfHwgKGRlc2NyaXB0b3Iub3B0aW9ucyA9IGV4cG9ydHMuRmllbGRPcHRpb25zLmNyZWF0ZSgpKSkucGFja2VkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhY2tlZCkgLy8gZGVmYXVsdHMgdG8gcGFja2VkPWZhbHNlXG4gICAgICAgIChkZXNjcmlwdG9yLm9wdGlvbnMgfHwgKGRlc2NyaXB0b3Iub3B0aW9ucyA9IGV4cG9ydHMuRmllbGRPcHRpb25zLmNyZWF0ZSgpKSkucGFja2VkID0gdHJ1ZTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxuLy8gLS0tIEVudW0gLS0tXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhbiBFbnVtRGVzY3JpcHRvclByb3RvIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElFbnVtRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIEVudW0gbmFtZVxuICogQHByb3BlcnR5IHtJRW51bVZhbHVlRGVzY3JpcHRvclByb3RvW119IFt2YWx1ZV0gRW51bSB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7SUVudW1PcHRpb25zfSBbb3B0aW9uc10gRW51bSBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGFuIEVudW1WYWx1ZURlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRW51bVZhbHVlRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIE5hbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbnVtYmVyXSBWYWx1ZVxuICogQHByb3BlcnR5IHsqfSBbb3B0aW9uc10gTm90IHN1cHBvcnRlZFxuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhbiBFbnVtT3B0aW9ucyBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRW51bU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FsbG93QWxpYXNdIFdoZXRoZXIgYWxpYXNlcyBhcmUgYWxsb3dlZFxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVwcmVjYXRlZF1cbiAqL1xuXG52YXIgdW5uYW1lZEVudW1JbmRleCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbnVtIGZyb20gYSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJRW51bURlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7RW51bX0gRW51bSBpbnN0YW5jZVxuICovXG5FbnVtLmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvcikge1xuXG4gICAgLy8gRGVjb2RlIHRoZSBkZXNjcmlwdG9yIG1lc3NhZ2UgaWYgc3BlY2lmaWVkIGFzIGEgYnVmZmVyOlxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGRlc2NyaXB0b3IgPSBleHBvcnRzLkVudW1EZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xuXG4gICAgLy8gQ29uc3RydWN0IHZhbHVlcyBvYmplY3RcbiAgICB2YXIgdmFsdWVzID0ge307XG4gICAgaWYgKGRlc2NyaXB0b3IudmFsdWUpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVzY3JpcHRvci52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgID0gZGVzY3JpcHRvci52YWx1ZVtpXS5uYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVzY3JpcHRvci52YWx1ZVtpXS5udW1iZXIgfHwgMDtcbiAgICAgICAgICAgIHZhbHVlc1tuYW1lICYmIG5hbWUubGVuZ3RoID8gbmFtZSA6IFwiTkFNRVwiICsgdmFsdWVdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgIHJldHVybiBuZXcgRW51bShcbiAgICAgICAgZGVzY3JpcHRvci5uYW1lICYmIGRlc2NyaXB0b3IubmFtZS5sZW5ndGggPyBkZXNjcmlwdG9yLm5hbWUgOiBcIkVudW1cIiArIHVubmFtZWRFbnVtSW5kZXgrKyxcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLkVudW1PcHRpb25zKVxuICAgICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGVudW0gdG8gYSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge01lc3NhZ2U8SUVudW1EZXNjcmlwdG9yUHJvdG8+fSBEZXNjcmlwdG9yXG4gKi9cbkVudW0ucHJvdG90eXBlLnRvRGVzY3JpcHRvciA9IGZ1bmN0aW9uIHRvRGVzY3JpcHRvcigpIHtcblxuICAgIC8vIFZhbHVlc1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwga3MgPSBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcyk7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgdmFsdWVzLnB1c2goZXhwb3J0cy5FbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHsgbmFtZToga3NbaV0sIG51bWJlcjogdGhpcy52YWx1ZXNba3NbaV1dIH0pKTtcblxuICAgIHJldHVybiBleHBvcnRzLkVudW1EZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWVzLFxuICAgICAgICBvcHRpb25zOiB0b0Rlc2NyaXB0b3JPcHRpb25zKHRoaXMub3B0aW9ucywgZXhwb3J0cy5FbnVtT3B0aW9ucylcbiAgICB9KTtcbn07XG5cbi8vIC0tLSBPbmVPZiAtLS1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgT25lb2ZEZXNjcmlwdG9yUHJvdG8gbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSU9uZW9mRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIE9uZW9mIG5hbWVcbiAqIEBwcm9wZXJ0eSB7Kn0gW29wdGlvbnNdIE5vdCBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgdW5uYW1lZE9uZW9mSW5kZXggPSAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBvbmVvZiBmcm9tIGEgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SU9uZW9mRGVzY3JpcHRvclByb3RvfFJlYWRlcnxVaW50OEFycmF5fSBkZXNjcmlwdG9yIERlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtPbmVPZn0gT25lT2YgaW5zdGFuY2VcbiAqL1xuT25lT2YuZnJvbURlc2NyaXB0b3IgPSBmdW5jdGlvbiBmcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yKSB7XG5cbiAgICAvLyBEZWNvZGUgdGhlIGRlc2NyaXB0b3IgbWVzc2FnZSBpZiBzcGVjaWZpZWQgYXMgYSBidWZmZXI6XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgZGVzY3JpcHRvciA9IGV4cG9ydHMuT25lb2ZEZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xuXG4gICAgcmV0dXJuIG5ldyBPbmVPZihcbiAgICAgICAgLy8gdW5uYW1lZE9uZU9mSW5kZXggaXMgZ2xvYmFsLCBub3QgcGVyIHR5cGUsIGJlY2F1c2Ugd2UgaGF2ZSBubyByZWYgdG8gYSB0eXBlIGhlcmVcbiAgICAgICAgZGVzY3JpcHRvci5uYW1lICYmIGRlc2NyaXB0b3IubmFtZS5sZW5ndGggPyBkZXNjcmlwdG9yLm5hbWUgOiBcIm9uZW9mXCIgKyB1bm5hbWVkT25lb2ZJbmRleCsrXG4gICAgICAgIC8vIGZyb21EZXNjcmlwdG9yT3B0aW9ucyhkZXNjcmlwdG9yLm9wdGlvbnMsIGV4cG9ydHMuT25lb2ZPcHRpb25zKSAtIG9ubHkgdW5pbnRlcnByZXRlZF9vcHRpb25cbiAgICApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG9uZW9mIHRvIGEgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtNZXNzYWdlPElPbmVvZkRlc2NyaXB0b3JQcm90bz59IERlc2NyaXB0b3JcbiAqL1xuT25lT2YucHJvdG90eXBlLnRvRGVzY3JpcHRvciA9IGZ1bmN0aW9uIHRvRGVzY3JpcHRvcigpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5PbmVvZkRlc2NyaXB0b3JQcm90by5jcmVhdGUoe1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWVcbiAgICAgICAgLy8gb3B0aW9uczogdG9EZXNjcmlwdG9yT3B0aW9ucyh0aGlzLm9wdGlvbnMsIGV4cG9ydHMuT25lb2ZPcHRpb25zKSAtIG9ubHkgdW5pbnRlcnByZXRlZF9vcHRpb25cbiAgICB9KTtcbn07XG5cbi8vIC0tLSBTZXJ2aWNlIC0tLVxuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBTZXJ2aWNlRGVzY3JpcHRvclByb3RvIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElTZXJ2aWNlRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIFNlcnZpY2UgbmFtZVxuICogQHByb3BlcnR5IHtJTWV0aG9kRGVzY3JpcHRvclByb3RvW119IFttZXRob2RdIE1ldGhvZHNcbiAqIEBwcm9wZXJ0eSB7SVNlcnZpY2VPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9uc1xuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIFNlcnZpY2VPcHRpb25zIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElTZXJ2aWNlT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVwcmVjYXRlZF1cbiAqL1xuXG52YXIgdW5uYW1lZFNlcnZpY2VJbmRleCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNlcnZpY2UgZnJvbSBhIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lTZXJ2aWNlRGVzY3JpcHRvclByb3RvfFJlYWRlcnxVaW50OEFycmF5fSBkZXNjcmlwdG9yIERlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtTZXJ2aWNlfSBTZXJ2aWNlIGluc3RhbmNlXG4gKi9cblNlcnZpY2UuZnJvbURlc2NyaXB0b3IgPSBmdW5jdGlvbiBmcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yKSB7XG5cbiAgICAvLyBEZWNvZGUgdGhlIGRlc2NyaXB0b3IgbWVzc2FnZSBpZiBzcGVjaWZpZWQgYXMgYSBidWZmZXI6XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgZGVzY3JpcHRvciA9IGV4cG9ydHMuU2VydmljZURlc2NyaXB0b3JQcm90by5kZWNvZGUoZGVzY3JpcHRvcik7XG5cbiAgICB2YXIgc2VydmljZSA9IG5ldyBTZXJ2aWNlKGRlc2NyaXB0b3IubmFtZSAmJiBkZXNjcmlwdG9yLm5hbWUubGVuZ3RoID8gZGVzY3JpcHRvci5uYW1lIDogXCJTZXJ2aWNlXCIgKyB1bm5hbWVkU2VydmljZUluZGV4KyssIGZyb21EZXNjcmlwdG9yT3B0aW9ucyhkZXNjcmlwdG9yLm9wdGlvbnMsIGV4cG9ydHMuU2VydmljZU9wdGlvbnMpKTtcbiAgICBpZiAoZGVzY3JpcHRvci5tZXRob2QpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVzY3JpcHRvci5tZXRob2QubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBzZXJ2aWNlLmFkZChNZXRob2QuZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvci5tZXRob2RbaV0pKTtcblxuICAgIHJldHVybiBzZXJ2aWNlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNlcnZpY2UgdG8gYSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge01lc3NhZ2U8SVNlcnZpY2VEZXNjcmlwdG9yUHJvdG8+fSBEZXNjcmlwdG9yXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnRvRGVzY3JpcHRvciA9IGZ1bmN0aW9uIHRvRGVzY3JpcHRvcigpIHtcblxuICAgIC8vIE1ldGhvZHNcbiAgICB2YXIgbWV0aG9kcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tZXRob2RzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgIG1ldGhvZHMucHVzaCh0aGlzLl9tZXRob2RzQXJyYXlbaV0udG9EZXNjcmlwdG9yKCkpO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuU2VydmljZURlc2NyaXB0b3JQcm90by5jcmVhdGUoe1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kcyxcbiAgICAgICAgb3B0aW9uczogdG9EZXNjcmlwdG9yT3B0aW9ucyh0aGlzLm9wdGlvbnMsIGV4cG9ydHMuU2VydmljZU9wdGlvbnMpXG4gICAgfSk7XG59O1xuXG4vLyAtLS0gTWV0aG9kIC0tLVxuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBNZXRob2REZXNjcmlwdG9yUHJvdG8gbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSU1ldGhvZERlc2NyaXB0b3JQcm90b1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBNZXRob2QgbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtpbnB1dFR5cGVdIFJlcXVlc3QgdHlwZSBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW291dHB1dFR5cGVdIFJlc3BvbnNlIHR5cGUgbmFtZVxuICogQHByb3BlcnR5IHtJTWV0aG9kT3B0aW9uc30gW29wdGlvbnNdIE5vdCBzdXBwb3J0ZWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NsaWVudFN0cmVhbWluZz1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgc3RyZWFtZWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NlcnZlclN0cmVhbWluZz1mYWxzZV0gV2hldGhlciByZXNwb25zZXMgYXJlIHN0cmVhbWVkXG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgTWV0aG9kT3B0aW9ucyBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJTWV0aG9kT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVwcmVjYXRlZF1cbiAqL1xuXG52YXIgdW5uYW1lZE1ldGhvZEluZGV4ID0gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWV0aG9kIGZyb20gYSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJTWV0aG9kRGVzY3JpcHRvclByb3RvfFJlYWRlcnxVaW50OEFycmF5fSBkZXNjcmlwdG9yIERlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtNZXRob2R9IFJlZmxlY3RlZCBtZXRob2QgaW5zdGFuY2VcbiAqL1xuTWV0aG9kLmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvcikge1xuXG4gICAgLy8gRGVjb2RlIHRoZSBkZXNjcmlwdG9yIG1lc3NhZ2UgaWYgc3BlY2lmaWVkIGFzIGEgYnVmZmVyOlxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGRlc2NyaXB0b3IgPSBleHBvcnRzLk1ldGhvZERlc2NyaXB0b3JQcm90by5kZWNvZGUoZGVzY3JpcHRvcik7XG5cbiAgICByZXR1cm4gbmV3IE1ldGhvZChcbiAgICAgICAgLy8gdW5uYW1lZE1ldGhvZEluZGV4IGlzIGdsb2JhbCwgbm90IHBlciBzZXJ2aWNlLCBiZWNhdXNlIHdlIGhhdmUgbm8gcmVmIHRvIGEgc2VydmljZSBoZXJlXG4gICAgICAgIGRlc2NyaXB0b3IubmFtZSAmJiBkZXNjcmlwdG9yLm5hbWUubGVuZ3RoID8gZGVzY3JpcHRvci5uYW1lIDogXCJNZXRob2RcIiArIHVubmFtZWRNZXRob2RJbmRleCsrLFxuICAgICAgICBcInJwY1wiLFxuICAgICAgICBkZXNjcmlwdG9yLmlucHV0VHlwZSxcbiAgICAgICAgZGVzY3JpcHRvci5vdXRwdXRUeXBlLFxuICAgICAgICBCb29sZWFuKGRlc2NyaXB0b3IuY2xpZW50U3RyZWFtaW5nKSxcbiAgICAgICAgQm9vbGVhbihkZXNjcmlwdG9yLnNlcnZlclN0cmVhbWluZyksXG4gICAgICAgIGZyb21EZXNjcmlwdG9yT3B0aW9ucyhkZXNjcmlwdG9yLm9wdGlvbnMsIGV4cG9ydHMuTWV0aG9kT3B0aW9ucylcbiAgICApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG1ldGhvZCB0byBhIGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7TWVzc2FnZTxJTWV0aG9kRGVzY3JpcHRvclByb3RvPn0gRGVzY3JpcHRvclxuICovXG5NZXRob2QucHJvdG90eXBlLnRvRGVzY3JpcHRvciA9IGZ1bmN0aW9uIHRvRGVzY3JpcHRvcigpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5NZXRob2REZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBpbnB1dFR5cGU6IHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZSA/IHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZS5mdWxsTmFtZSA6IHRoaXMucmVxdWVzdFR5cGUsXG4gICAgICAgIG91dHB1dFR5cGU6IHRoaXMucmVzb2x2ZWRSZXNwb25zZVR5cGUgPyB0aGlzLnJlc29sdmVkUmVzcG9uc2VUeXBlLmZ1bGxOYW1lIDogdGhpcy5yZXNwb25zZVR5cGUsXG4gICAgICAgIGNsaWVudFN0cmVhbWluZzogdGhpcy5yZXF1ZXN0U3RyZWFtLFxuICAgICAgICBzZXJ2ZXJTdHJlYW1pbmc6IHRoaXMucmVzcG9uc2VTdHJlYW0sXG4gICAgICAgIG9wdGlvbnM6IHRvRGVzY3JpcHRvck9wdGlvbnModGhpcy5vcHRpb25zLCBleHBvcnRzLk1ldGhvZE9wdGlvbnMpXG4gICAgfSk7XG59O1xuXG4vLyAtLS0gdXRpbGl0eSAtLS1cblxuLy8gQ29udmVydHMgYSBkZXNjcmlwdG9yIHR5cGUgdG8gYSBwcm90b2J1Zi5qcyBiYXNpYyB0eXBlXG5mdW5jdGlvbiBmcm9tRGVzY3JpcHRvclR5cGUodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAvLyAwIGlzIHJlc2VydmVkIGZvciBlcnJvcnNcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gXCJkb3VibGVcIjtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gXCJmbG9hdFwiO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBcImludDY0XCI7XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIFwidWludDY0XCI7XG4gICAgICAgIGNhc2UgNTogcmV0dXJuIFwiaW50MzJcIjtcbiAgICAgICAgY2FzZSA2OiByZXR1cm4gXCJmaXhlZDY0XCI7XG4gICAgICAgIGNhc2UgNzogcmV0dXJuIFwiZml4ZWQzMlwiO1xuICAgICAgICBjYXNlIDg6IHJldHVybiBcImJvb2xcIjtcbiAgICAgICAgY2FzZSA5OiByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgY2FzZSAxMjogcmV0dXJuIFwiYnl0ZXNcIjtcbiAgICAgICAgY2FzZSAxMzogcmV0dXJuIFwidWludDMyXCI7XG4gICAgICAgIGNhc2UgMTU6IHJldHVybiBcInNmaXhlZDMyXCI7XG4gICAgICAgIGNhc2UgMTY6IHJldHVybiBcInNmaXhlZDY0XCI7XG4gICAgICAgIGNhc2UgMTc6IHJldHVybiBcInNpbnQzMlwiO1xuICAgICAgICBjYXNlIDE4OiByZXR1cm4gXCJzaW50NjRcIjtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdHlwZSk7XG59XG5cbi8vIFRlc3RzIGlmIGEgZGVzY3JpcHRvciB0eXBlIGlzIHBhY2thYmxlXG5mdW5jdGlvbiBwYWNrYWJsZURlc2NyaXB0b3JUeXBlKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAxOiAvLyBkb3VibGVcbiAgICAgICAgY2FzZSAyOiAvLyBmbG9hdFxuICAgICAgICBjYXNlIDM6IC8vIGludDY0XG4gICAgICAgIGNhc2UgNDogLy8gdWludDY0XG4gICAgICAgIGNhc2UgNTogLy8gaW50MzJcbiAgICAgICAgY2FzZSA2OiAvLyBmaXhlZDY0XG4gICAgICAgIGNhc2UgNzogLy8gZml4ZWQzMlxuICAgICAgICBjYXNlIDg6IC8vIGJvb2xcbiAgICAgICAgY2FzZSAxMzogLy8gdWludDMyXG4gICAgICAgIGNhc2UgMTQ6IC8vIGVudW0gKCEpXG4gICAgICAgIGNhc2UgMTU6IC8vIHNmaXhlZDMyXG4gICAgICAgIGNhc2UgMTY6IC8vIHNmaXhlZDY0XG4gICAgICAgIGNhc2UgMTc6IC8vIHNpbnQzMlxuICAgICAgICBjYXNlIDE4OiAvLyBzaW50NjRcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIENvbnZlcnRzIGEgcHJvdG9idWYuanMgYmFzaWMgdHlwZSB0byBhIGRlc2NyaXB0b3IgdHlwZVxuZnVuY3Rpb24gdG9EZXNjcmlwdG9yVHlwZSh0eXBlLCByZXNvbHZlZFR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgLy8gMCBpcyByZXNlcnZlZCBmb3IgZXJyb3JzXG4gICAgICAgIGNhc2UgXCJkb3VibGVcIjogcmV0dXJuIDE7XG4gICAgICAgIGNhc2UgXCJmbG9hdFwiOiByZXR1cm4gMjtcbiAgICAgICAgY2FzZSBcImludDY0XCI6IHJldHVybiAzO1xuICAgICAgICBjYXNlIFwidWludDY0XCI6IHJldHVybiA0O1xuICAgICAgICBjYXNlIFwiaW50MzJcIjogcmV0dXJuIDU7XG4gICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6IHJldHVybiA2O1xuICAgICAgICBjYXNlIFwiZml4ZWQzMlwiOiByZXR1cm4gNztcbiAgICAgICAgY2FzZSBcImJvb2xcIjogcmV0dXJuIDg7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIDk7XG4gICAgICAgIGNhc2UgXCJieXRlc1wiOiByZXR1cm4gMTI7XG4gICAgICAgIGNhc2UgXCJ1aW50MzJcIjogcmV0dXJuIDEzO1xuICAgICAgICBjYXNlIFwic2ZpeGVkMzJcIjogcmV0dXJuIDE1O1xuICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjogcmV0dXJuIDE2O1xuICAgICAgICBjYXNlIFwic2ludDMyXCI6IHJldHVybiAxNztcbiAgICAgICAgY2FzZSBcInNpbnQ2NFwiOiByZXR1cm4gMTg7XG4gICAgfVxuICAgIGlmIChyZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKVxuICAgICAgICByZXR1cm4gMTQ7XG4gICAgaWYgKHJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIFR5cGUpXG4gICAgICAgIHJldHVybiByZXNvbHZlZFR5cGUuZ3JvdXAgPyAxMCA6IDExO1xuICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHR5cGUpO1xufVxuXG4vLyBDb252ZXJ0cyBkZXNjcmlwdG9yIG9wdGlvbnMgdG8gYW4gb3B0aW9ucyBvYmplY3RcbmZ1bmN0aW9uIGZyb21EZXNjcmlwdG9yT3B0aW9ucyhvcHRpb25zLCB0eXBlKSB7XG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgZmllbGQsIGtleSwgdmFsOyBpIDwgdHlwZS5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKChrZXkgPSAoZmllbGQgPSB0eXBlLl9maWVsZHNBcnJheVtpXSkubmFtZSkgIT09IFwidW5pbnRlcnByZXRlZE9wdGlvblwiKVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICAgICAgIHZhbCA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSAmJiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmIGZpZWxkLnJlc29sdmVkVHlwZS52YWx1ZXNCeUlkW3ZhbF0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlc0J5SWRbdmFsXTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh1bmRlclNjb3JlKGtleSksIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgcmV0dXJuIG91dC5sZW5ndGggPyAkcHJvdG9idWYudXRpbC50b09iamVjdChvdXQpIDogdW5kZWZpbmVkO1xufVxuXG4vLyBDb252ZXJ0cyBhbiBvcHRpb25zIG9iamVjdCB0byBkZXNjcmlwdG9yIG9wdGlvbnNcbmZ1bmN0aW9uIHRvRGVzY3JpcHRvck9wdGlvbnMob3B0aW9ucywgdHlwZSkge1xuICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGtzID0gT2JqZWN0LmtleXMob3B0aW9ucyksIGtleSwgdmFsOyBpIDwga3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsID0gb3B0aW9uc1trZXkgPSBrc1tpXV07XG4gICAgICAgIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciBmaWVsZCA9IHR5cGUuZmllbGRzW2tleV07XG4gICAgICAgIGlmICghZmllbGQgJiYgIShmaWVsZCA9IHR5cGUuZmllbGRzW2tleSA9ICRwcm90b2J1Zi51dGlsLmNhbWVsQ2FzZShrZXkpXSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgb3V0LnB1c2goa2V5LCB2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0Lmxlbmd0aCA/IHR5cGUuZnJvbU9iamVjdCgkcHJvdG9idWYudXRpbC50b09iamVjdChvdXQpKSA6IHVuZGVmaW5lZDtcbn1cblxuLy8gQ2FsY3VsYXRlcyB0aGUgc2hvcnRlc3QgcmVsYXRpdmUgcGF0aCBmcm9tIGBmcm9tYCB0byBgdG9gLlxuZnVuY3Rpb24gc2hvcnRuYW1lKGZyb20sIHRvKSB7XG4gICAgdmFyIGZyb21QYXRoID0gZnJvbS5mdWxsTmFtZS5zcGxpdChcIi5cIiksXG4gICAgICAgIHRvUGF0aCA9IHRvLmZ1bGxOYW1lLnNwbGl0KFwiLlwiKSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGogPSAwLFxuICAgICAgICBrID0gdG9QYXRoLmxlbmd0aCAtIDE7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIFJvb3QpICYmIHRvIGluc3RhbmNlb2YgTmFtZXNwYWNlKVxuICAgICAgICB3aGlsZSAoaSA8IGZyb21QYXRoLmxlbmd0aCAmJiBqIDwgayAmJiBmcm9tUGF0aFtpXSA9PT0gdG9QYXRoW2pdKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSB0by5sb29rdXAoZnJvbVBhdGhbaSsrXSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAob3RoZXIgIT09IG51bGwgJiYgb3RoZXIgIT09IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgKytqO1xuICAgICAgICB9XG4gICAgZWxzZVxuICAgICAgICBmb3IgKDsgaSA8IGZyb21QYXRoLmxlbmd0aCAmJiBqIDwgayAmJiBmcm9tUGF0aFtpXSA9PT0gdG9QYXRoW2pdOyArK2ksICsraik7XG4gICAgcmV0dXJuIHRvUGF0aC5zbGljZShqKS5qb2luKFwiLlwiKTtcbn1cblxuLy8gY29waWVkIGhlcmUgZnJvbSBjbGkvdGFyZ2V0cy9wcm90by5qc1xuZnVuY3Rpb24gdW5kZXJTY29yZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLDEpXG4gICAgICAgICArIHN0ci5zdWJzdHJpbmcoMSlcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oW0EtWl0pKD89W2Etel18JCkvZywgZnVuY3Rpb24oJDAsICQxKSB7IHJldHVybiBcIl9cIiArICQxLnRvTG93ZXJDYXNlKCk7IH0pO1xufVxuXG4vLyAtLS0gZXhwb3J0cyAtLS1cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZmlsZSBkZXNjcmlwdG9yIHNldC5cbiAqIEBuYW1lIEZpbGVEZXNjcmlwdG9yU2V0XG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIGZpbGUgZGVzY3JpcHRvciBwcm90by5cbiAqIEBuYW1lIEZpbGVEZXNjcmlwdG9yUHJvdG9cbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZGVzY3JpcHRvciBwcm90by5cbiAqIEBuYW1lIERlc2NyaXB0b3JQcm90b1xuICogQHR5cGUge1R5cGV9XG4gKiBAcHJvcGVydHkge1R5cGV9IEV4dGVuc2lvblJhbmdlXG4gKiBAcHJvcGVydHkge1R5cGV9IFJlc2VydmVkUmFuZ2VcbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZSAmIHtcbiAqICAgICBFeHRlbnNpb25SYW5nZTogJHByb3RvYnVmLlR5cGUsXG4gKiAgICAgUmVzZXJ2ZWRSYW5nZTogJHByb3RvYnVmLlR5cGVcbiAqIH1cbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBmaWVsZCBkZXNjcmlwdG9yIHByb3RvLlxuICogQG5hbWUgRmllbGREZXNjcmlwdG9yUHJvdG9cbiAqIEB0eXBlIHtUeXBlfVxuICogQHByb3BlcnR5IHtFbnVtfSBMYWJlbFxuICogQHByb3BlcnR5IHtFbnVtfSBUeXBlXG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGUgJiB7XG4gKiAgICAgTGFiZWw6ICRwcm90b2J1Zi5FbnVtLFxuICogICAgIFR5cGU6ICRwcm90b2J1Zi5FbnVtXG4gKiB9XG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgb25lb2YgZGVzY3JpcHRvciBwcm90by5cbiAqIEBuYW1lIE9uZW9mRGVzY3JpcHRvclByb3RvXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIGVudW0gZGVzY3JpcHRvciBwcm90by5cbiAqIEBuYW1lIEVudW1EZXNjcmlwdG9yUHJvdG9cbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgc2VydmljZSBkZXNjcmlwdG9yIHByb3RvLlxuICogQG5hbWUgU2VydmljZURlc2NyaXB0b3JQcm90b1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBlbnVtIHZhbHVlIGRlc2NyaXB0b3IgcHJvdG8uXG4gKiBAbmFtZSBFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG9cbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgbWV0aG9kIGRlc2NyaXB0b3IgcHJvdG8uXG4gKiBAbmFtZSBNZXRob2REZXNjcmlwdG9yUHJvdG9cbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZmlsZSBvcHRpb25zLlxuICogQG5hbWUgRmlsZU9wdGlvbnNcbiAqIEB0eXBlIHtUeXBlfVxuICogQHByb3BlcnR5IHtFbnVtfSBPcHRpbWl6ZU1vZGVcbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZSAmIHtcbiAqICAgICBPcHRpbWl6ZU1vZGU6ICRwcm90b2J1Zi5FbnVtXG4gKiB9XG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgbWVzc2FnZSBvcHRpb25zLlxuICogQG5hbWUgTWVzc2FnZU9wdGlvbnNcbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZmllbGQgb3B0aW9ucy5cbiAqIEBuYW1lIEZpZWxkT3B0aW9uc1xuICogQHR5cGUge1R5cGV9XG4gKiBAcHJvcGVydHkge0VudW19IENUeXBlXG4gKiBAcHJvcGVydHkge0VudW19IEpTVHlwZVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlICYge1xuICogICAgIENUeXBlOiAkcHJvdG9idWYuRW51bSxcbiAqICAgICBKU1R5cGU6ICRwcm90b2J1Zi5FbnVtXG4gKiB9XG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgb25lb2Ygb3B0aW9ucy5cbiAqIEBuYW1lIE9uZW9mT3B0aW9uc1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBlbnVtIG9wdGlvbnMuXG4gKiBAbmFtZSBFbnVtT3B0aW9uc1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBlbnVtIHZhbHVlIG9wdGlvbnMuXG4gKiBAbmFtZSBFbnVtVmFsdWVPcHRpb25zXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIHNlcnZpY2Ugb3B0aW9ucy5cbiAqIEBuYW1lIFNlcnZpY2VPcHRpb25zXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIG1ldGhvZCBvcHRpb25zLlxuICogQG5hbWUgTWV0aG9kT3B0aW9uc1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCB1bmludGVycHJldGV0IG9wdGlvbi5cbiAqIEBuYW1lIFVuaW50ZXJwcmV0ZWRPcHRpb25cbiAqIEB0eXBlIHtUeXBlfVxuICogQHByb3BlcnR5IHtUeXBlfSBOYW1lUGFydFxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlICYge1xuICogICAgIE5hbWVQYXJ0OiAkcHJvdG9idWYuVHlwZVxuICogfVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIHNvdXJjZSBjb2RlIGluZm8uXG4gKiBAbmFtZSBTb3VyY2VDb2RlSW5mb1xuICogQHR5cGUge1R5cGV9XG4gKiBAcHJvcGVydHkge1R5cGV9IExvY2F0aW9uXG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGUgJiB7XG4gKiAgICAgTG9jYXRpb246ICRwcm90b2J1Zi5UeXBlXG4gKiB9XG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZ2VuZXJhdGVkIGNvZGUgaW5mby5cbiAqIEBuYW1lIEdlbmVyYXRlZENvZGVJbmZvXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBwcm9wZXJ0eSB7VHlwZX0gQW5ub3RhdGlvblxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlICYge1xuICogICAgIEFubm90YXRpb246ICRwcm90b2J1Zi5UeXBlXG4gKiB9XG4gKi9cbiJdLCJuYW1lcyI6WyIkcHJvdG9idWYiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlc2NyaXB0b3IiLCJSb290IiwiZnJvbUpTT04iLCJsb29rdXAiLCJOYW1lc3BhY2UiLCJFbnVtIiwiVHlwZSIsIkZpZWxkIiwiTWFwRmllbGQiLCJPbmVPZiIsIlNlcnZpY2UiLCJNZXRob2QiLCJmcm9tRGVzY3JpcHRvciIsImxlbmd0aCIsIkZpbGVEZXNjcmlwdG9yU2V0IiwiZGVjb2RlIiwicm9vdCIsImZpbGUiLCJmaWxlRGVzY3JpcHRvciIsImZpbGVQYWNrYWdlIiwiaiIsImkiLCJkZWZpbmUiLCJuYW1lIiwiZmlsZXMiLCJwdXNoIiwiZmlsZW5hbWUiLCJtZXNzYWdlVHlwZSIsImFkZCIsInN5bnRheCIsImVudW1UeXBlIiwiZXh0ZW5zaW9uIiwic2VydmljZSIsIm9wdHMiLCJmcm9tRGVzY3JpcHRvck9wdGlvbnMiLCJvcHRpb25zIiwiRmlsZU9wdGlvbnMiLCJrcyIsIk9iamVjdCIsImtleXMiLCJzZXRPcHRpb24iLCJwcm90b3R5cGUiLCJ0b0Rlc2NyaXB0b3IiLCJzZXQiLCJjcmVhdGUiLCJSb290X3RvRGVzY3JpcHRvclJlY3Vyc2l2ZSIsIm5zIiwiRmlsZURlc2NyaXB0b3JQcm90byIsImZ1bGxOYW1lIiwic3Vic3RyaW5nIiwicmVwbGFjZSIsIm5lc3RlZCIsIm5lc3RlZEFycmF5IiwiX25lc3RlZEFycmF5IiwidG9EZXNjcmlwdG9yT3B0aW9ucyIsInVubmFtZWRNZXNzYWdlSW5kZXgiLCJEZXNjcmlwdG9yUHJvdG8iLCJ0eXBlIiwiTWVzc2FnZU9wdGlvbnMiLCJvbmVvZkRlY2wiLCJmaWVsZCIsImhhc093blByb3BlcnR5Iiwib25lb2ZzQXJyYXkiLCJvbmVvZkluZGV4IiwibmVzdGVkVHlwZSIsIm1hcEVudHJ5IiwiZXh0ZW5zaW9uUmFuZ2UiLCJleHRlbnNpb25zIiwic3RhcnQiLCJlbmQiLCJyZXNlcnZlZFJhbmdlIiwicmVzZXJ2ZWROYW1lIiwicmVzZXJ2ZWQiLCJmaWVsZHNBcnJheSIsImZpZWxkRGVzY3JpcHRvciIsIl9maWVsZHNBcnJheSIsImtleVR5cGUiLCJ0b0Rlc2NyaXB0b3JUeXBlIiwicmVzb2x2ZWRLZXlUeXBlIiwidmFsdWVUeXBlIiwicmVzb2x2ZWRUeXBlIiwidmFsdWVUeXBlTmFtZSIsInNob3J0bmFtZSIsInBhcmVudCIsInVuZGVmaW5lZCIsInR5cGVOYW1lIiwiRmllbGREZXNjcmlwdG9yUHJvdG8iLCJudW1iZXIiLCJsYWJlbCIsIl9vbmVvZnNBcnJheSIsIkV4dGVuc2lvblJhbmdlIiwiUmVzZXJ2ZWRSYW5nZSIsIm51bWJlclJlIiwiRXJyb3IiLCJmaWVsZFR5cGUiLCJmcm9tRGVzY3JpcHRvclR5cGUiLCJmaWVsZFJ1bGUiLCJleHRlbmRlZSIsIkZpZWxkT3B0aW9ucyIsImRlZmF1bHRWYWx1ZSIsIm1hdGNoIiwiZXhlYyIsInBhcnNlSW50IiwicGFja2FibGVEZXNjcmlwdG9yVHlwZSIsInBhY2tlZCIsImlkIiwibWFwIiwidXRpbCIsInVjRmlyc3QiLCJyZXNvbHZlIiwicnVsZSIsImV4dGVuc2lvbkZpZWxkIiwiZXh0ZW5kIiwicGFydE9mIiwiaW5kZXhPZiIsIlN0cmluZyIsInVubmFtZWRFbnVtSW5kZXgiLCJFbnVtRGVzY3JpcHRvclByb3RvIiwidmFsdWVzIiwidmFsdWUiLCJFbnVtT3B0aW9ucyIsIkVudW1WYWx1ZURlc2NyaXB0b3JQcm90byIsInVubmFtZWRPbmVvZkluZGV4IiwiT25lb2ZEZXNjcmlwdG9yUHJvdG8iLCJ1bm5hbWVkU2VydmljZUluZGV4IiwiU2VydmljZURlc2NyaXB0b3JQcm90byIsIlNlcnZpY2VPcHRpb25zIiwibWV0aG9kIiwibWV0aG9kcyIsIm1ldGhvZHNBcnJheSIsIl9tZXRob2RzQXJyYXkiLCJ1bm5hbWVkTWV0aG9kSW5kZXgiLCJNZXRob2REZXNjcmlwdG9yUHJvdG8iLCJpbnB1dFR5cGUiLCJvdXRwdXRUeXBlIiwiQm9vbGVhbiIsImNsaWVudFN0cmVhbWluZyIsInNlcnZlclN0cmVhbWluZyIsIk1ldGhvZE9wdGlvbnMiLCJyZXNvbHZlZFJlcXVlc3RUeXBlIiwicmVxdWVzdFR5cGUiLCJyZXNvbHZlZFJlc3BvbnNlVHlwZSIsInJlc3BvbnNlVHlwZSIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsImdyb3VwIiwib3V0Iiwia2V5IiwidmFsIiwidmFsdWVzQnlJZCIsInVuZGVyU2NvcmUiLCJ0b09iamVjdCIsImZpZWxkcyIsImNhbWVsQ2FzZSIsImZyb21PYmplY3QiLCJmcm9tIiwidG8iLCJmcm9tUGF0aCIsInNwbGl0IiwidG9QYXRoIiwiayIsIm90aGVyIiwic2xpY2UiLCJqb2luIiwic3RyIiwiJDAiLCIkMSIsInRvTG93ZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/ext/descriptor/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/index.js":
/*!******************************************!*\
  !*** ./node_modules/protobufjs/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// full library entry point.\n\nmodule.exports = __webpack_require__(/*! ./src/index */ \"(ssr)/./node_modules/protobufjs/src/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSw0QkFBNEI7QUFFZjtBQUNiQSx1R0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvaW5kZXguanM/NGYyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdWxsIGxpYnJhcnkgZW50cnkgcG9pbnQuXG5cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zcmMvaW5kZXhcIik7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/common.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/common.js ***!
  \***********************************************/
/***/ ((module) => {

eval("\nmodule.exports = common;\nvar commonRe = /\\/|\\./;\n/**\n * Provides common type definitions.\n * Can also be used to provide additional google types or your own custom types.\n * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name\n * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition\n * @returns {undefined}\n * @property {INamespace} google/protobuf/any.proto Any\n * @property {INamespace} google/protobuf/duration.proto Duration\n * @property {INamespace} google/protobuf/empty.proto Empty\n * @property {INamespace} google/protobuf/field_mask.proto FieldMask\n * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue\n * @property {INamespace} google/protobuf/timestamp.proto Timestamp\n * @property {INamespace} google/protobuf/wrappers.proto Wrappers\n * @example\n * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)\n * protobuf.common(\"descriptor\", descriptorJson);\n *\n * // manually provides a custom definition (uses my.foo namespace)\n * protobuf.common(\"my/foo/bar.proto\", myFooBarJson);\n */ function common(name, json) {\n    if (!commonRe.test(name)) {\n        name = \"google/protobuf/\" + name + \".proto\";\n        json = {\n            nested: {\n                google: {\n                    nested: {\n                        protobuf: {\n                            nested: json\n                        }\n                    }\n                }\n            }\n        };\n    }\n    common[name] = json;\n}\n// Not provided because of limited use (feel free to discuss or to provide yourself):\n//\n// google/protobuf/descriptor.proto\n// google/protobuf/source_context.proto\n// google/protobuf/type.proto\n//\n// Stripped and pre-parsed versions of these non-bundled files are instead available as part of\n// the repository or package within the google/protobuf directory.\ncommon(\"any\", {\n    /**\n     * Properties of a google.protobuf.Any message.\n     * @interface IAny\n     * @type {Object}\n     * @property {string} [typeUrl]\n     * @property {Uint8Array} [bytes]\n     * @memberof common\n     */ Any: {\n        fields: {\n            type_url: {\n                type: \"string\",\n                id: 1\n            },\n            value: {\n                type: \"bytes\",\n                id: 2\n            }\n        }\n    }\n});\nvar timeType;\ncommon(\"duration\", {\n    /**\n     * Properties of a google.protobuf.Duration message.\n     * @interface IDuration\n     * @type {Object}\n     * @property {number|Long} [seconds]\n     * @property {number} [nanos]\n     * @memberof common\n     */ Duration: timeType = {\n        fields: {\n            seconds: {\n                type: \"int64\",\n                id: 1\n            },\n            nanos: {\n                type: \"int32\",\n                id: 2\n            }\n        }\n    }\n});\ncommon(\"timestamp\", {\n    /**\n     * Properties of a google.protobuf.Timestamp message.\n     * @interface ITimestamp\n     * @type {Object}\n     * @property {number|Long} [seconds]\n     * @property {number} [nanos]\n     * @memberof common\n     */ Timestamp: timeType\n});\ncommon(\"empty\", {\n    /**\n     * Properties of a google.protobuf.Empty message.\n     * @interface IEmpty\n     * @memberof common\n     */ Empty: {\n        fields: {}\n    }\n});\ncommon(\"struct\", {\n    /**\n     * Properties of a google.protobuf.Struct message.\n     * @interface IStruct\n     * @type {Object}\n     * @property {Object.<string,IValue>} [fields]\n     * @memberof common\n     */ Struct: {\n        fields: {\n            fields: {\n                keyType: \"string\",\n                type: \"Value\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.Value message.\n     * @interface IValue\n     * @type {Object}\n     * @property {string} [kind]\n     * @property {0} [nullValue]\n     * @property {number} [numberValue]\n     * @property {string} [stringValue]\n     * @property {boolean} [boolValue]\n     * @property {IStruct} [structValue]\n     * @property {IListValue} [listValue]\n     * @memberof common\n     */ Value: {\n        oneofs: {\n            kind: {\n                oneof: [\n                    \"nullValue\",\n                    \"numberValue\",\n                    \"stringValue\",\n                    \"boolValue\",\n                    \"structValue\",\n                    \"listValue\"\n                ]\n            }\n        },\n        fields: {\n            nullValue: {\n                type: \"NullValue\",\n                id: 1\n            },\n            numberValue: {\n                type: \"double\",\n                id: 2\n            },\n            stringValue: {\n                type: \"string\",\n                id: 3\n            },\n            boolValue: {\n                type: \"bool\",\n                id: 4\n            },\n            structValue: {\n                type: \"Struct\",\n                id: 5\n            },\n            listValue: {\n                type: \"ListValue\",\n                id: 6\n            }\n        }\n    },\n    NullValue: {\n        values: {\n            NULL_VALUE: 0\n        }\n    },\n    /**\n     * Properties of a google.protobuf.ListValue message.\n     * @interface IListValue\n     * @type {Object}\n     * @property {Array.<IValue>} [values]\n     * @memberof common\n     */ ListValue: {\n        fields: {\n            values: {\n                rule: \"repeated\",\n                type: \"Value\",\n                id: 1\n            }\n        }\n    }\n});\ncommon(\"wrappers\", {\n    /**\n     * Properties of a google.protobuf.DoubleValue message.\n     * @interface IDoubleValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ DoubleValue: {\n        fields: {\n            value: {\n                type: \"double\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.FloatValue message.\n     * @interface IFloatValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ FloatValue: {\n        fields: {\n            value: {\n                type: \"float\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.Int64Value message.\n     * @interface IInt64Value\n     * @type {Object}\n     * @property {number|Long} [value]\n     * @memberof common\n     */ Int64Value: {\n        fields: {\n            value: {\n                type: \"int64\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.UInt64Value message.\n     * @interface IUInt64Value\n     * @type {Object}\n     * @property {number|Long} [value]\n     * @memberof common\n     */ UInt64Value: {\n        fields: {\n            value: {\n                type: \"uint64\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.Int32Value message.\n     * @interface IInt32Value\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ Int32Value: {\n        fields: {\n            value: {\n                type: \"int32\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.UInt32Value message.\n     * @interface IUInt32Value\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ UInt32Value: {\n        fields: {\n            value: {\n                type: \"uint32\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.BoolValue message.\n     * @interface IBoolValue\n     * @type {Object}\n     * @property {boolean} [value]\n     * @memberof common\n     */ BoolValue: {\n        fields: {\n            value: {\n                type: \"bool\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.StringValue message.\n     * @interface IStringValue\n     * @type {Object}\n     * @property {string} [value]\n     * @memberof common\n     */ StringValue: {\n        fields: {\n            value: {\n                type: \"string\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.BytesValue message.\n     * @interface IBytesValue\n     * @type {Object}\n     * @property {Uint8Array} [value]\n     * @memberof common\n     */ BytesValue: {\n        fields: {\n            value: {\n                type: \"bytes\",\n                id: 1\n            }\n        }\n    }\n});\ncommon(\"field_mask\", {\n    /**\n     * Properties of a google.protobuf.FieldMask message.\n     * @interface IDoubleValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ FieldMask: {\n        fields: {\n            paths: {\n                rule: \"repeated\",\n                type: \"string\",\n                id: 1\n            }\n        }\n    }\n});\n/**\n * Gets the root definition of the specified common proto file.\n *\n * Bundled definitions are:\n * - google/protobuf/any.proto\n * - google/protobuf/duration.proto\n * - google/protobuf/empty.proto\n * - google/protobuf/field_mask.proto\n * - google/protobuf/struct.proto\n * - google/protobuf/timestamp.proto\n * - google/protobuf/wrappers.proto\n *\n * @param {string} file Proto file name\n * @returns {INamespace|null} Root definition or `null` if not defined\n */ common.get = function get(file) {\n    return common[file] || null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsV0FBVztBQUVmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ0QsU0FBU0QsT0FBT0UsSUFBSSxFQUFFQyxJQUFJO0lBQ3RCLElBQUksQ0FBQ0YsU0FBU0csSUFBSSxDQUFDRixPQUFPO1FBQ3RCQSxPQUFPLHFCQUFxQkEsT0FBTztRQUNuQ0MsT0FBTztZQUFFRSxRQUFRO2dCQUFFQyxRQUFRO29CQUFFRCxRQUFRO3dCQUFFRSxVQUFVOzRCQUFFRixRQUFRRjt3QkFBSztvQkFBRTtnQkFBRTtZQUFFO1FBQUU7SUFDNUU7SUFDQUgsTUFBTSxDQUFDRSxLQUFLLEdBQUdDO0FBQ25CO0FBRUEscUZBQXFGO0FBQ3JGLEVBQUU7QUFDRixtQ0FBbUM7QUFDbkMsdUNBQXVDO0FBQ3ZDLDZCQUE2QjtBQUM3QixFQUFFO0FBQ0YsK0ZBQStGO0FBQy9GLGtFQUFrRTtBQUVsRUgsT0FBTyxPQUFPO0lBRVY7Ozs7Ozs7S0FPQyxHQUNEUSxLQUFLO1FBQ0RDLFFBQVE7WUFDSkMsVUFBVTtnQkFDTkMsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1lBQ0FDLE9BQU87Z0JBQ0hGLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtRQUNKO0lBQ0o7QUFDSjtBQUVBLElBQUlFO0FBRUpkLE9BQU8sWUFBWTtJQUVmOzs7Ozs7O0tBT0MsR0FDRGUsVUFBVUQsV0FBVztRQUNqQkwsUUFBUTtZQUNKTyxTQUFTO2dCQUNMTCxNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7WUFDQUssT0FBTztnQkFDSE4sTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtBQUNKO0FBRUFaLE9BQU8sYUFBYTtJQUVoQjs7Ozs7OztLQU9DLEdBQ0RrQixXQUFXSjtBQUNmO0FBRUFkLE9BQU8sU0FBUztJQUVaOzs7O0tBSUMsR0FDRG1CLE9BQU87UUFDSFYsUUFBUSxDQUFDO0lBQ2I7QUFDSjtBQUVBVCxPQUFPLFVBQVU7SUFFYjs7Ozs7O0tBTUMsR0FDRG9CLFFBQVE7UUFDSlgsUUFBUTtZQUNKQSxRQUFRO2dCQUNKWSxTQUFTO2dCQUNUVixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0lBRUE7Ozs7Ozs7Ozs7OztLQVlDLEdBQ0RVLE9BQU87UUFDSEMsUUFBUTtZQUNKQyxNQUFNO2dCQUNGQyxPQUFPO29CQUNIO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO2lCQUNIO1lBQ0w7UUFDSjtRQUNBaEIsUUFBUTtZQUNKaUIsV0FBVztnQkFDUGYsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1lBQ0FlLGFBQWE7Z0JBQ1RoQixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7WUFDQWdCLGFBQWE7Z0JBQ1RqQixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7WUFDQWlCLFdBQVc7Z0JBQ1BsQixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7WUFDQWtCLGFBQWE7Z0JBQ1RuQixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7WUFDQW1CLFdBQVc7Z0JBQ1BwQixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0lBRUFvQixXQUFXO1FBQ1BDLFFBQVE7WUFDSkMsWUFBWTtRQUNoQjtJQUNKO0lBRUE7Ozs7OztLQU1DLEdBQ0RDLFdBQVc7UUFDUDFCLFFBQVE7WUFDSndCLFFBQVE7Z0JBQ0pHLE1BQU07Z0JBQ056QixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0FBQ0o7QUFFQVosT0FBTyxZQUFZO0lBRWY7Ozs7OztLQU1DLEdBQ0RxQyxhQUFhO1FBQ1Q1QixRQUFRO1lBQ0pJLE9BQU87Z0JBQ0hGLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtRQUNKO0lBQ0o7SUFFQTs7Ozs7O0tBTUMsR0FDRDBCLFlBQVk7UUFDUjdCLFFBQVE7WUFDSkksT0FBTztnQkFDSEYsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtJQUVBOzs7Ozs7S0FNQyxHQUNEMkIsWUFBWTtRQUNSOUIsUUFBUTtZQUNKSSxPQUFPO2dCQUNIRixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0lBRUE7Ozs7OztLQU1DLEdBQ0Q0QixhQUFhO1FBQ1QvQixRQUFRO1lBQ0pJLE9BQU87Z0JBQ0hGLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtRQUNKO0lBQ0o7SUFFQTs7Ozs7O0tBTUMsR0FDRDZCLFlBQVk7UUFDUmhDLFFBQVE7WUFDSkksT0FBTztnQkFDSEYsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtJQUVBOzs7Ozs7S0FNQyxHQUNEOEIsYUFBYTtRQUNUakMsUUFBUTtZQUNKSSxPQUFPO2dCQUNIRixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0lBRUE7Ozs7OztLQU1DLEdBQ0QrQixXQUFXO1FBQ1BsQyxRQUFRO1lBQ0pJLE9BQU87Z0JBQ0hGLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtRQUNKO0lBQ0o7SUFFQTs7Ozs7O0tBTUMsR0FDRGdDLGFBQWE7UUFDVG5DLFFBQVE7WUFDSkksT0FBTztnQkFDSEYsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtJQUVBOzs7Ozs7S0FNQyxHQUNEaUMsWUFBWTtRQUNScEMsUUFBUTtZQUNKSSxPQUFPO2dCQUNIRixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0FBQ0o7QUFFQVosT0FBTyxjQUFjO0lBRWpCOzs7Ozs7S0FNQyxHQUNEOEMsV0FBVztRQUNQckMsUUFBUTtZQUNKc0MsT0FBTztnQkFDSFgsTUFBTTtnQkFDTnpCLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtRQUNKO0lBQ0o7QUFDSjtBQUVBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0RaLE9BQU9nRCxHQUFHLEdBQUcsU0FBU0EsSUFBSUMsSUFBSTtJQUMxQixPQUFPakQsTUFBTSxDQUFDaUQsS0FBSyxJQUFJO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9jb21tb24uanM/Zjk2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gY29tbW9uO1xuXG52YXIgY29tbW9uUmUgPSAvXFwvfFxcLi87XG5cbi8qKlxuICogUHJvdmlkZXMgY29tbW9uIHR5cGUgZGVmaW5pdGlvbnMuXG4gKiBDYW4gYWxzbyBiZSB1c2VkIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBnb29nbGUgdHlwZXMgb3IgeW91ciBvd24gY3VzdG9tIHR5cGVzLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU2hvcnQgbmFtZSBhcyBpbiBgZ29vZ2xlL3Byb3RvYnVmL1tuYW1lXS5wcm90b2Agb3IgZnVsbCBmaWxlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGpzb24gSlNPTiBkZWZpbml0aW9uIHdpdGhpbiBgZ29vZ2xlLnByb3RvYnVmYCBpZiBhIHNob3J0IG5hbWUsIG90aGVyd2lzZSB0aGUgZmlsZSdzIHJvb3QgZGVmaW5pdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL2FueS5wcm90byBBbnlcbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvIER1cmF0aW9uXG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9lbXB0eS5wcm90byBFbXB0eVxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvZmllbGRfbWFzay5wcm90byBGaWVsZE1hc2tcbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL3N0cnVjdC5wcm90byBTdHJ1Y3QsIFZhbHVlLCBOdWxsVmFsdWUgYW5kIExpc3RWYWx1ZVxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLnByb3RvIFRpbWVzdGFtcFxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG8gV3JhcHBlcnNcbiAqIEBleGFtcGxlXG4gKiAvLyBtYW51YWxseSBwcm92aWRlcyBkZXNjcmlwdG9yLnByb3RvIChhc3N1bWVzIGdvb2dsZS9wcm90b2J1Zi8gbmFtZXNwYWNlIGFuZCAucHJvdG8gZXh0ZW5zaW9uKVxuICogcHJvdG9idWYuY29tbW9uKFwiZGVzY3JpcHRvclwiLCBkZXNjcmlwdG9ySnNvbik7XG4gKlxuICogLy8gbWFudWFsbHkgcHJvdmlkZXMgYSBjdXN0b20gZGVmaW5pdGlvbiAodXNlcyBteS5mb28gbmFtZXNwYWNlKVxuICogcHJvdG9idWYuY29tbW9uKFwibXkvZm9vL2Jhci5wcm90b1wiLCBteUZvb0Jhckpzb24pO1xuICovXG5mdW5jdGlvbiBjb21tb24obmFtZSwganNvbikge1xuICAgIGlmICghY29tbW9uUmUudGVzdChuYW1lKSkge1xuICAgICAgICBuYW1lID0gXCJnb29nbGUvcHJvdG9idWYvXCIgKyBuYW1lICsgXCIucHJvdG9cIjtcbiAgICAgICAganNvbiA9IHsgbmVzdGVkOiB7IGdvb2dsZTogeyBuZXN0ZWQ6IHsgcHJvdG9idWY6IHsgbmVzdGVkOiBqc29uIH0gfSB9IH0gfTtcbiAgICB9XG4gICAgY29tbW9uW25hbWVdID0ganNvbjtcbn1cblxuLy8gTm90IHByb3ZpZGVkIGJlY2F1c2Ugb2YgbGltaXRlZCB1c2UgKGZlZWwgZnJlZSB0byBkaXNjdXNzIG9yIHRvIHByb3ZpZGUgeW91cnNlbGYpOlxuLy9cbi8vIGdvb2dsZS9wcm90b2J1Zi9kZXNjcmlwdG9yLnByb3RvXG4vLyBnb29nbGUvcHJvdG9idWYvc291cmNlX2NvbnRleHQucHJvdG9cbi8vIGdvb2dsZS9wcm90b2J1Zi90eXBlLnByb3RvXG4vL1xuLy8gU3RyaXBwZWQgYW5kIHByZS1wYXJzZWQgdmVyc2lvbnMgb2YgdGhlc2Ugbm9uLWJ1bmRsZWQgZmlsZXMgYXJlIGluc3RlYWQgYXZhaWxhYmxlIGFzIHBhcnQgb2Zcbi8vIHRoZSByZXBvc2l0b3J5IG9yIHBhY2thZ2Ugd2l0aGluIHRoZSBnb29nbGUvcHJvdG9idWYgZGlyZWN0b3J5LlxuXG5jb21tb24oXCJhbnlcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5BbnkgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElBbnlcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZVVybF1cbiAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IFtieXRlc11cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgQW55OiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdHlwZV91cmw6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVzXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgdGltZVR5cGU7XG5cbmNvbW1vbihcImR1cmF0aW9uXCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuRHVyYXRpb24gbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElEdXJhdGlvblxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ30gW3NlY29uZHNdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtuYW5vc11cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgRHVyYXRpb246IHRpbWVUeXBlID0ge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHNlY29uZHM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludDY0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW5vczoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50MzJcIixcbiAgICAgICAgICAgICAgICBpZDogMlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNvbW1vbihcInRpbWVzdGFtcFwiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSVRpbWVzdGFtcFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ30gW3NlY29uZHNdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtuYW5vc11cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgVGltZXN0YW1wOiB0aW1lVHlwZVxufSk7XG5cbmNvbW1vbihcImVtcHR5XCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuRW1wdHkgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElFbXB0eVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBFbXB0eToge1xuICAgICAgICBmaWVsZHM6IHt9XG4gICAgfVxufSk7XG5cbmNvbW1vbihcInN0cnVjdFwiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSVN0cnVjdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxJVmFsdWU+fSBbZmllbGRzXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBTdHJ1Y3Q6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgICBrZXlUeXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtraW5kXVxuICAgICAqIEBwcm9wZXJ0eSB7MH0gW251bGxWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW251bWJlclZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3RyaW5nVmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYm9vbFZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7SVN0cnVjdH0gW3N0cnVjdFZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7SUxpc3RWYWx1ZX0gW2xpc3RWYWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgVmFsdWU6IHtcbiAgICAgICAgb25lb2ZzOiB7XG4gICAgICAgICAgICBraW5kOiB7XG4gICAgICAgICAgICAgICAgb25lb2Y6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJudWxsVmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJudW1iZXJWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1ZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYm9vbFZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3RydWN0VmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaXN0VmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBudWxsVmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIk51bGxWYWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbnVtYmVyVmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRvdWJsZVwiLFxuICAgICAgICAgICAgICAgIGlkOiAyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RyaW5nVmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGlkOiAzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9vbFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJ1Y3RWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiU3RydWN0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IDVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaXN0VmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkxpc3RWYWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlkOiA2XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgTnVsbFZhbHVlOiB7XG4gICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgTlVMTF9WQUxVRTogMFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuTGlzdFZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJTGlzdFZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxJVmFsdWU+fSBbdmFsdWVzXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBMaXN0VmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBydWxlOiBcInJlcGVhdGVkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29tbW9uKFwid3JhcHBlcnNcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5Eb3VibGVWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSURvdWJsZVZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBEb3VibGVWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkb3VibGVcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuRmxvYXRWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUZsb2F0VmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEZsb2F0VmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUludDY0VmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgSW50NjRWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5VSW50NjRWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSVVJbnQ2NFZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFVJbnQ2NFZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQ2NFwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJSW50MzJWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgSW50MzJWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnQzMlwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSVVJbnQzMlZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBVSW50MzJWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MzJcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuQm9vbFZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJQm9vbFZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgQm9vbFZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuU3RyaW5nVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElTdHJpbmdWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgU3RyaW5nVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElCeXRlc1ZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgQnl0ZXNWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJieXRlc1wiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29tbW9uKFwiZmllbGRfbWFza1wiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFzayBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSURvdWJsZVZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBGaWVsZE1hc2s6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBwYXRoczoge1xuICAgICAgICAgICAgICAgIHJ1bGU6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBHZXRzIHRoZSByb290IGRlZmluaXRpb24gb2YgdGhlIHNwZWNpZmllZCBjb21tb24gcHJvdG8gZmlsZS5cbiAqXG4gKiBCdW5kbGVkIGRlZmluaXRpb25zIGFyZTpcbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL2FueS5wcm90b1xuICogLSBnb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJvdG9cbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL2VtcHR5LnByb3RvXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9maWVsZF9tYXNrLnByb3RvXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9zdHJ1Y3QucHJvdG9cbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5wcm90b1xuICogLSBnb29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZSBQcm90byBmaWxlIG5hbWVcbiAqIEByZXR1cm5zIHtJTmFtZXNwYWNlfG51bGx9IFJvb3QgZGVmaW5pdGlvbiBvciBgbnVsbGAgaWYgbm90IGRlZmluZWRcbiAqL1xuY29tbW9uLmdldCA9IGZ1bmN0aW9uIGdldChmaWxlKSB7XG4gICAgcmV0dXJuIGNvbW1vbltmaWxlXSB8fCBudWxsO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiY29tbW9uIiwiY29tbW9uUmUiLCJuYW1lIiwianNvbiIsInRlc3QiLCJuZXN0ZWQiLCJnb29nbGUiLCJwcm90b2J1ZiIsIkFueSIsImZpZWxkcyIsInR5cGVfdXJsIiwidHlwZSIsImlkIiwidmFsdWUiLCJ0aW1lVHlwZSIsIkR1cmF0aW9uIiwic2Vjb25kcyIsIm5hbm9zIiwiVGltZXN0YW1wIiwiRW1wdHkiLCJTdHJ1Y3QiLCJrZXlUeXBlIiwiVmFsdWUiLCJvbmVvZnMiLCJraW5kIiwib25lb2YiLCJudWxsVmFsdWUiLCJudW1iZXJWYWx1ZSIsInN0cmluZ1ZhbHVlIiwiYm9vbFZhbHVlIiwic3RydWN0VmFsdWUiLCJsaXN0VmFsdWUiLCJOdWxsVmFsdWUiLCJ2YWx1ZXMiLCJOVUxMX1ZBTFVFIiwiTGlzdFZhbHVlIiwicnVsZSIsIkRvdWJsZVZhbHVlIiwiRmxvYXRWYWx1ZSIsIkludDY0VmFsdWUiLCJVSW50NjRWYWx1ZSIsIkludDMyVmFsdWUiLCJVSW50MzJWYWx1ZSIsIkJvb2xWYWx1ZSIsIlN0cmluZ1ZhbHVlIiwiQnl0ZXNWYWx1ZSIsIkZpZWxkTWFzayIsInBhdGhzIiwiZ2V0IiwiZmlsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/converter.js":
/*!**************************************************!*\
  !*** ./node_modules/protobufjs/src/converter.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Runtime message from/to plain object converters.\n * @namespace\n */ var converter = exports;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/protobufjs/src/enum.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\");\n/**\n * Generates a partial value fromObject conveter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genValuePartial_fromObject(gen, field, fieldIndex, prop) {\n    var defaultAlreadyEmitted = false;\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) {\n            gen(\"switch(d%s){\", prop);\n            for(var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i){\n                // enum unknown values passthrough\n                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) {\n                    gen(\"default:\")('if(typeof(d%s)===\"number\"){m%s=d%s;break}', prop, prop, prop);\n                    if (!field.repeated) gen // fallback to default value only for\n                    (\"break\"); // for non-repeated fields, just ignore\n                    defaultAlreadyEmitted = true;\n                }\n                gen(\"case%j:\", keys[i])(\"case %i:\", values[keys[i]])(\"m%s=%j\", prop, values[keys[i]])(\"break\");\n            }\n            gen(\"}\");\n        } else gen('if(typeof d%s!==\"object\")', prop)(\"throw TypeError(%j)\", field.fullName + \": object expected\")(\"m%s=types[%i].fromObject(d%s)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch(field.type){\n            case \"double\":\n            case \"float\":\n                gen(\"m%s=Number(d%s)\", prop, prop); // also catches \"NaN\", \"Infinity\"\n                break;\n            case \"uint32\":\n            case \"fixed32\":\n                gen(\"m%s=d%s>>>0\", prop, prop);\n                break;\n            case \"int32\":\n            case \"sint32\":\n            case \"sfixed32\":\n                gen(\"m%s=d%s|0\", prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n            // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                gen(\"if(util.Long)\")(\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", prop, prop, isUnsigned)('else if(typeof d%s===\"string\")', prop)(\"m%s=parseInt(d%s,10)\", prop, prop)('else if(typeof d%s===\"number\")', prop)(\"m%s=d%s\", prop, prop)('else if(typeof d%s===\"object\")', prop)(\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", prop, prop, prop, isUnsigned ? \"true\" : \"\");\n                break;\n            case \"bytes\":\n                gen('if(typeof d%s===\"string\")', prop)(\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", prop, prop, prop)(\"else if(d%s.length >= 0)\", prop)(\"m%s=d%s\", prop, prop);\n                break;\n            case \"string\":\n                gen(\"m%s=String(d%s)\", prop, prop);\n                break;\n            case \"bool\":\n                gen(\"m%s=Boolean(d%s)\", prop, prop);\n                break;\n        }\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ }\n/**\n * Generates a plain object to runtime message converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ converter.fromObject = function fromObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ var fields = mtype.fieldsArray;\n    var gen = util.codegen([\n        \"d\"\n    ], mtype.name + \"$fromObject\")(\"if(d instanceof this.ctor)\")(\"return d\");\n    if (!fields.length) return gen(\"return new this.ctor\");\n    gen(\"var m=new this.ctor\");\n    for(var i = 0; i < fields.length; ++i){\n        var field = fields[i].resolve(), prop = util.safeProp(field.name);\n        // Map fields\n        if (field.map) {\n            gen(\"if(d%s){\", prop)('if(typeof d%s!==\"object\")', prop)(\"throw TypeError(%j)\", field.fullName + \": object expected\")(\"m%s={}\", prop)(\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[ks[i]]\")(\"}\")(\"}\");\n        // Repeated fields\n        } else if (field.repeated) {\n            gen(\"if(d%s){\", prop)(\"if(!Array.isArray(d%s))\", prop)(\"throw TypeError(%j)\", field.fullName + \": array expected\")(\"m%s=[]\", prop)(\"for(var i=0;i<d%s.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[i]\")(\"}\")(\"}\");\n        // Non-repeated fields\n        } else {\n            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)\n            (\"if(d%s!=null){\", prop); // !== undefined && !== null\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);\n            if (!(field.resolvedType instanceof Enum)) gen(\"}\");\n        }\n    }\n    return gen(\"return m\");\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ };\n/**\n * Generates a partial value toObject converter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genValuePartial_toObject(gen, field, fieldIndex, prop) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) gen(\"d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s\", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);\n        else gen(\"d%s=types[%i].toObject(m%s,o)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch(field.type){\n            case \"double\":\n            case \"float\":\n                gen(\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", prop, prop, prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n            // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                gen('if(typeof m%s===\"number\")', prop)(\"d%s=o.longs===String?String(m%s):m%s\", prop, prop, prop)(\"else\") // Long-like\n                (\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", prop, prop, prop, prop, isUnsigned ? \"true\" : \"\", prop);\n                break;\n            case \"bytes\":\n                gen(\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", prop, prop, prop, prop, prop);\n                break;\n            default:\n                gen(\"d%s=m%s\", prop, prop);\n                break;\n        }\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ }\n/**\n * Generates a runtime message to plain object converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ converter.toObject = function toObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    if (!fields.length) return util.codegen()(\"return {}\");\n    var gen = util.codegen([\n        \"m\",\n        \"o\"\n    ], mtype.name + \"$toObject\")(\"if(!o)\")(\"o={}\")(\"var d={}\");\n    var repeatedFields = [], mapFields = [], normalFields = [], i = 0;\n    for(; i < fields.length; ++i)if (!fields[i].partOf) (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);\n    if (repeatedFields.length) {\n        gen(\"if(o.arrays||o.defaults){\");\n        for(i = 0; i < repeatedFields.length; ++i)gen(\"d%s=[]\", util.safeProp(repeatedFields[i].name));\n        gen(\"}\");\n    }\n    if (mapFields.length) {\n        gen(\"if(o.objects||o.defaults){\");\n        for(i = 0; i < mapFields.length; ++i)gen(\"d%s={}\", util.safeProp(mapFields[i].name));\n        gen(\"}\");\n    }\n    if (normalFields.length) {\n        gen(\"if(o.defaults){\");\n        for(i = 0; i < normalFields.length; ++i){\n            var field = normalFields[i], prop = util.safeProp(field.name);\n            if (field.resolvedType instanceof Enum) gen(\"d%s=o.enums===String?%j:%j\", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);\n            else if (field.long) gen(\"if(util.Long){\")(\"var n=new util.Long(%i,%i,%j)\", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)(\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", prop)(\"}else\")(\"d%s=o.longs===String?%j:%i\", prop, field.typeDefault.toString(), field.typeDefault.toNumber());\n            else if (field.bytes) {\n                var arrayDefault = \"[\" + Array.prototype.slice.call(field.typeDefault).join(\",\") + \"]\";\n                gen(\"if(o.bytes===String)d%s=%j\", prop, String.fromCharCode.apply(String, field.typeDefault))(\"else{\")(\"d%s=%s\", prop, arrayDefault)(\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", prop, prop)(\"}\");\n            } else gen(\"d%s=%j\", prop, field.typeDefault); // also messages (=null)\n        }\n        gen(\"}\");\n    }\n    var hasKs2 = false;\n    for(i = 0; i < fields.length; ++i){\n        var field = fields[i], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);\n        if (field.map) {\n            if (!hasKs2) {\n                hasKs2 = true;\n                gen(\"var ks2\");\n            }\n            gen(\"if(m%s&&(ks2=Object.keys(m%s)).length){\", prop, prop)(\"d%s={}\", prop)(\"for(var j=0;j<ks2.length;++j){\");\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[ks2[j]]\")(\"}\");\n        } else if (field.repeated) {\n            gen(\"if(m%s&&m%s.length){\", prop, prop)(\"d%s=[]\", prop)(\"for(var j=0;j<m%s.length;++j){\", prop);\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[j]\")(\"}\");\n        } else {\n            gen(\"if(m%s!=null&&m.hasOwnProperty(%j)){\", prop, field.name); // !== undefined && !== null\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop);\n            if (field.partOf) gen(\"if(o.oneofs)\")(\"d%s=%j\", util.safeProp(field.partOf.name), field.name);\n        }\n        gen(\"}\");\n    }\n    return gen(\"return d\");\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvY29udmVydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7OztDQUdDLEdBQ0QsSUFBSUEsWUFBWUM7QUFFaEIsSUFBSUMsT0FBT0MsbUJBQU9BLENBQUMsMkRBQVEsR0FDdkJDLE9BQU9ELG1CQUFPQSxDQUFDLDJEQUFRO0FBRTNCOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0UsMkJBQTJCQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxJQUFJO0lBQzVELElBQUlDLHdCQUF3QjtJQUM1QiwwRUFBMEUsR0FDMUUsSUFBSUgsTUFBTUksWUFBWSxFQUFFO1FBQ3BCLElBQUlKLE1BQU1JLFlBQVksWUFBWVQsTUFBTTtZQUFFSSxJQUNyQyxnQkFBZ0JHO1lBQ2pCLElBQUssSUFBSUcsU0FBU0wsTUFBTUksWUFBWSxDQUFDQyxNQUFNLEVBQUVDLE9BQU9DLE9BQU9ELElBQUksQ0FBQ0QsU0FBU0csSUFBSSxHQUFHQSxJQUFJRixLQUFLRyxNQUFNLEVBQUUsRUFBRUQsRUFBRztnQkFDbEcsa0NBQWtDO2dCQUNsQyxJQUFJSCxNQUFNLENBQUNDLElBQUksQ0FBQ0UsRUFBRSxDQUFDLEtBQUtSLE1BQU1VLFdBQVcsSUFBSSxDQUFDUCx1QkFBdUI7b0JBQUVKLElBQ2xFLFlBQ0ksNkNBQStDRyxNQUFNQSxNQUFNQTtvQkFDaEUsSUFBSSxDQUFDRixNQUFNVyxRQUFRLEVBQUVaLElBQUkscUNBQXFDO3FCQUV6RCxVQUFvQix1Q0FBdUM7b0JBQ2hFSSx3QkFBd0I7Z0JBQzVCO2dCQUNBSixJQUNDLFdBQVdPLElBQUksQ0FBQ0UsRUFBRSxFQUNsQixZQUFZSCxNQUFNLENBQUNDLElBQUksQ0FBQ0UsRUFBRSxDQUFDLEVBQ3ZCLFVBQVVOLE1BQU1HLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDRSxFQUFFLENBQUMsRUFDL0I7WUFDVDtZQUFFVCxJQUNEO1FBQ0wsT0FBT0EsSUFDRiw2QkFBK0JHLE1BQzNCLHVC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O1lBQUVBLElBQ1QsMkNBQTJDRyxNQUFNQSxNQUM3QyxVQUFVQSxNQUNWO1lBQ0dzQix5QkFBeUJ6QixLQUFLQyxPQUFPLFVBQVUsR0FBR21ELE9BQU9qRCxPQUFPLFlBQ25FO1FBQ0QsT0FBTyxJQUFJRixNQUFNVyxRQUFRLEVBQUU7WUFBRVosSUFDaEMsd0JBQXdCRyxNQUFNQSxNQUMxQixVQUFVQSxNQUNWLGtDQUFrQ0E7WUFDL0JzQix5QkFBeUJ6QixLQUFLQyxPQUFPLFVBQVUsR0FBR21ELE9BQU9qRCxPQUFPLE9BQ25FO1FBQ0QsT0FBTztZQUFFSCxJQUNaLHdDQUF3Q0csTUFBTUYsTUFBTW9CLElBQUksR0FBRyw0QkFBNEI7WUFDcEZJLHlCQUF5QnpCLEtBQUtDLE9BQU8sVUFBVSxHQUFHbUQsT0FBT2pEO1lBQ3pELElBQUlGLE1BQU1nQyxNQUFNLEVBQUVqQyxJQUNqQixnQkFDSSxVQUFVRixLQUFLeUIsUUFBUSxDQUFDdEIsTUFBTWdDLE1BQU0sQ0FBQ1osSUFBSSxHQUFHcEIsTUFBTW9CLElBQUk7UUFDM0Q7UUFDQXJCLElBQ0g7SUFDRDtJQUNBLE9BQU9BLElBQ047QUFDRCx5RUFBeUUsR0FDN0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2NvbnZlcnRlci5qcz83Y2ZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBSdW50aW1lIG1lc3NhZ2UgZnJvbS90byBwbGFpbiBvYmplY3QgY29udmVydGVycy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIGNvbnZlcnRlciA9IGV4cG9ydHM7XG5cbnZhciBFbnVtID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIHZhbHVlIGZyb21PYmplY3QgY29udmV0ZXIuXG4gKiBAcGFyYW0ge0NvZGVnZW59IGdlbiBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBSZWZsZWN0ZWQgZmllbGRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZEluZGV4IEZpZWxkIGluZGV4XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSByZWZlcmVuY2VcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0KGdlbiwgZmllbGQsIGZpZWxkSW5kZXgsIHByb3ApIHtcbiAgICB2YXIgZGVmYXVsdEFscmVhZHlFbWl0dGVkID0gZmFsc2U7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xuICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUpIHtcbiAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIHsgZ2VuXG4gICAgICAgICAgICAoXCJzd2l0Y2goZCVzKXtcIiwgcHJvcCk7XG4gICAgICAgICAgICBmb3IgKHZhciB2YWx1ZXMgPSBmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzLCBrZXlzID0gT2JqZWN0LmtleXModmFsdWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgLy8gZW51bSB1bmtub3duIHZhbHVlcyBwYXNzdGhyb3VnaFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5c1tpXV0gPT09IGZpZWxkLnR5cGVEZWZhdWx0ICYmICFkZWZhdWx0QWxyZWFkeUVtaXR0ZWQpIHsgZ2VuXG4gICAgICAgICAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJpZih0eXBlb2YoZCVzKT09PVxcXCJudW1iZXJcXFwiKXttJXM9ZCVzO2JyZWFrfVwiLCBwcm9wLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZC5yZXBlYXRlZCkgZ2VuIC8vIGZhbGxiYWNrIHRvIGRlZmF1bHQgdmFsdWUgb25seSBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFycmF5cywgdG8gYXZvaWQgbGVhdmluZyBob2xlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpOyAgICAgICAgICAgLy8gZm9yIG5vbi1yZXBlYXRlZCBmaWVsZHMsIGp1c3QgaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRBbHJlYWR5RW1pdHRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgIChcImNhc2UlajpcIiwga2V5c1tpXSlcbiAgICAgICAgICAgICAgICAoXCJjYXNlICVpOlwiLCB2YWx1ZXNba2V5c1tpXV0pXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz0lalwiLCBwcm9wLCB2YWx1ZXNba2V5c1tpXV0pXG4gICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpO1xuICAgICAgICAgICAgfSBnZW5cbiAgICAgICAgICAgIChcIn1cIik7XG4gICAgICAgIH0gZWxzZSBnZW5cbiAgICAgICAgICAgIChcImlmKHR5cGVvZiBkJXMhPT1cXFwib2JqZWN0XFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAoXCJ0aHJvdyBUeXBlRXJyb3IoJWopXCIsIGZpZWxkLmZ1bGxOYW1lICsgXCI6IG9iamVjdCBleHBlY3RlZFwiKVxuICAgICAgICAgICAgKFwibSVzPXR5cGVzWyVpXS5mcm9tT2JqZWN0KGQlcylcIiwgcHJvcCwgZmllbGRJbmRleCwgcHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlzVW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmxvYXRcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwibSVzPU51bWJlcihkJXMpXCIsIHByb3AsIHByb3ApOyAvLyBhbHNvIGNhdGNoZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQzMlwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzPj4+MFwiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDMyXCI6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1kJXN8MFwiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgICAgICAgICBpc1Vuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcImZpeGVkNjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZih1dGlsLkxvbmcpXCIpXG4gICAgICAgICAgICAgICAgICAgIChcIihtJXM9dXRpbC5Mb25nLmZyb21WYWx1ZShkJXMpKS51bnNpZ25lZD0lalwiLCBwcm9wLCBwcm9wLCBpc1Vuc2lnbmVkKVxuICAgICAgICAgICAgICAgIChcImVsc2UgaWYodHlwZW9mIGQlcz09PVxcXCJzdHJpbmdcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9cGFyc2VJbnQoZCVzLDEwKVwiLCBwcm9wLCBwcm9wKVxuICAgICAgICAgICAgICAgIChcImVsc2UgaWYodHlwZW9mIGQlcz09PVxcXCJudW1iZXJcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzXCIsIHByb3AsIHByb3ApXG4gICAgICAgICAgICAgICAgKFwiZWxzZSBpZih0eXBlb2YgZCVzPT09XFxcIm9iamVjdFxcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz1uZXcgdXRpbC5Mb25nQml0cyhkJXMubG93Pj4+MCxkJXMuaGlnaD4+PjApLnRvTnVtYmVyKCVzKVwiLCBwcm9wLCBwcm9wLCBwcm9wLCBpc1Vuc2lnbmVkID8gXCJ0cnVlXCIgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZih0eXBlb2YgZCVzPT09XFxcInN0cmluZ1xcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgICAgIChcInV0aWwuYmFzZTY0LmRlY29kZShkJXMsbSVzPXV0aWwubmV3QnVmZmVyKHV0aWwuYmFzZTY0Lmxlbmd0aChkJXMpKSwwKVwiLCBwcm9wLCBwcm9wLCBwcm9wKVxuICAgICAgICAgICAgICAgIChcImVsc2UgaWYoZCVzLmxlbmd0aCA+PSAwKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9U3RyaW5nKGQlcylcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9Qm9vbGVhbihkJXMpXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogZGVmYXVsdDogZ2VuXG4gICAgICAgICAgICAgICAgKFwibSVzPWQlc1wiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhazsgKi9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VuO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBsYWluIG9iamVjdCB0byBydW50aW1lIG1lc3NhZ2UgY29udmVydGVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmNvbnZlcnRlci5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbiAgICB2YXIgZmllbGRzID0gbXR5cGUuZmllbGRzQXJyYXk7XG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJkXCJdLCBtdHlwZS5uYW1lICsgXCIkZnJvbU9iamVjdFwiKVxuICAgIChcImlmKGQgaW5zdGFuY2VvZiB0aGlzLmN0b3IpXCIpXG4gICAgICAgIChcInJldHVybiBkXCIpO1xuICAgIGlmICghZmllbGRzLmxlbmd0aCkgcmV0dXJuIGdlblxuICAgIChcInJldHVybiBuZXcgdGhpcy5jdG9yXCIpO1xuICAgIGdlblxuICAgIChcInZhciBtPW5ldyB0aGlzLmN0b3JcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkICA9IGZpZWxkc1tpXS5yZXNvbHZlKCksXG4gICAgICAgICAgICBwcm9wICAgPSB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xuXG4gICAgICAgIC8vIE1hcCBmaWVsZHNcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkgeyBnZW5cbiAgICAoXCJpZihkJXMpe1wiLCBwcm9wKVxuICAgICAgICAoXCJpZih0eXBlb2YgZCVzIT09XFxcIm9iamVjdFxcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAoXCJ0aHJvdyBUeXBlRXJyb3IoJWopXCIsIGZpZWxkLmZ1bGxOYW1lICsgXCI6IG9iamVjdCBleHBlY3RlZFwiKVxuICAgICAgICAoXCJtJXM9e31cIiwgcHJvcClcbiAgICAgICAgKFwiZm9yKHZhciBrcz1PYmplY3Qua2V5cyhkJXMpLGk9MDtpPGtzLmxlbmd0aDsrK2kpe1wiLCBwcm9wKTtcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0KGdlbiwgZmllbGQsIC8qIG5vdCBzb3J0ZWQgKi8gaSwgcHJvcCArIFwiW2tzW2ldXVwiKVxuICAgICAgICAoXCJ9XCIpXG4gICAgKFwifVwiKTtcblxuICAgICAgICAvLyBSZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgeyBnZW5cbiAgICAoXCJpZihkJXMpe1wiLCBwcm9wKVxuICAgICAgICAoXCJpZighQXJyYXkuaXNBcnJheShkJXMpKVwiLCBwcm9wKVxuICAgICAgICAgICAgKFwidGhyb3cgVHlwZUVycm9yKCVqKVwiLCBmaWVsZC5mdWxsTmFtZSArIFwiOiBhcnJheSBleHBlY3RlZFwiKVxuICAgICAgICAoXCJtJXM9W11cIiwgcHJvcClcbiAgICAgICAgKFwiZm9yKHZhciBpPTA7aTxkJXMubGVuZ3RoOysraSl7XCIsIHByb3ApO1xuICAgICAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QoZ2VuLCBmaWVsZCwgLyogbm90IHNvcnRlZCAqLyBpLCBwcm9wICsgXCJbaV1cIilcbiAgICAgICAgKFwifVwiKVxuICAgIChcIn1cIik7XG5cbiAgICAgICAgLy8gTm9uLXJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkpIGdlbiAvLyBubyBuZWVkIHRvIHRlc3QgZm9yIG51bGwvdW5kZWZpbmVkIGlmIGFuIGVudW0gKHVzZXMgc3dpdGNoKVxuICAgIChcImlmKGQlcyE9bnVsbCl7XCIsIHByb3ApOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG4gICAgICAgIGdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0KGdlbiwgZmllbGQsIC8qIG5vdCBzb3J0ZWQgKi8gaSwgcHJvcCk7XG4gICAgICAgICAgICBpZiAoIShmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSkgZ2VuXG4gICAgKFwifVwiKTtcbiAgICAgICAgfVxuICAgIH0gcmV0dXJuIGdlblxuICAgIChcInJldHVybiBtXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIHZhbHVlIHRvT2JqZWN0IGNvbnZlcnRlci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHJlZmVyZW5jZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZ2VuVmFsdWVQYXJ0aWFsX3RvT2JqZWN0KGdlbiwgZmllbGQsIGZpZWxkSW5kZXgsIHByb3ApIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG4gICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSkge1xuICAgICAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkgZ2VuXG4gICAgICAgICAgICAoXCJkJXM9by5lbnVtcz09PVN0cmluZz8odHlwZXNbJWldLnZhbHVlc1ttJXNdPT09dW5kZWZpbmVkP20lczp0eXBlc1slaV0udmFsdWVzW20lc10pOm0lc1wiLCBwcm9wLCBmaWVsZEluZGV4LCBwcm9wLCBwcm9wLCBmaWVsZEluZGV4LCBwcm9wLCBwcm9wKTtcbiAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgIChcImQlcz10eXBlc1slaV0udG9PYmplY3QobSVzLG8pXCIsIHByb3AsIGZpZWxkSW5kZXgsIHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpc1Vuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcImZsb2F0XCI6IGdlblxuICAgICAgICAgICAgKFwiZCVzPW8uanNvbiYmIWlzRmluaXRlKG0lcyk/U3RyaW5nKG0lcyk6bSVzXCIsIHByb3AsIHByb3AsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAgICAgICAgIGlzVW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6IGdlblxuICAgICAgICAgICAgKFwiaWYodHlwZW9mIG0lcz09PVxcXCJudW1iZXJcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgIChcImQlcz1vLmxvbmdzPT09U3RyaW5nP1N0cmluZyhtJXMpOm0lc1wiLCBwcm9wLCBwcm9wLCBwcm9wKVxuICAgICAgICAgICAgKFwiZWxzZVwiKSAvLyBMb25nLWxpa2VcbiAgICAgICAgICAgICAgICAoXCJkJXM9by5sb25ncz09PVN0cmluZz91dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobSVzKTpvLmxvbmdzPT09TnVtYmVyP25ldyB1dGlsLkxvbmdCaXRzKG0lcy5sb3c+Pj4wLG0lcy5oaWdoPj4+MCkudG9OdW1iZXIoJXMpOm0lc1wiLCBwcm9wLCBwcm9wLCBwcm9wLCBwcm9wLCBpc1Vuc2lnbmVkID8gXCJ0cnVlXCI6IFwiXCIsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6IGdlblxuICAgICAgICAgICAgKFwiZCVzPW8uYnl0ZXM9PT1TdHJpbmc/dXRpbC5iYXNlNjQuZW5jb2RlKG0lcywwLG0lcy5sZW5ndGgpOm8uYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtJXMpOm0lc1wiLCBwcm9wLCBwcm9wLCBwcm9wLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IGdlblxuICAgICAgICAgICAgKFwiZCVzPW0lc1wiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VuO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJ1bnRpbWUgbWVzc2FnZSB0byBwbGFpbiBvYmplY3QgY29udmVydGVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmNvbnZlcnRlci50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xuICAgIHZhciBmaWVsZHMgPSBtdHlwZS5maWVsZHNBcnJheS5zbGljZSgpLnNvcnQodXRpbC5jb21wYXJlRmllbGRzQnlJZCk7XG4gICAgaWYgKCFmaWVsZHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdXRpbC5jb2RlZ2VuKCkoXCJyZXR1cm4ge31cIik7XG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJtXCIsIFwib1wiXSwgbXR5cGUubmFtZSArIFwiJHRvT2JqZWN0XCIpXG4gICAgKFwiaWYoIW8pXCIpXG4gICAgICAgIChcIm89e31cIilcbiAgICAoXCJ2YXIgZD17fVwiKTtcblxuICAgIHZhciByZXBlYXRlZEZpZWxkcyA9IFtdLFxuICAgICAgICBtYXBGaWVsZHMgPSBbXSxcbiAgICAgICAgbm9ybWFsRmllbGRzID0gW10sXG4gICAgICAgIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgZmllbGRzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoIWZpZWxkc1tpXS5wYXJ0T2YpXG4gICAgICAgICAgICAoIGZpZWxkc1tpXS5yZXNvbHZlKCkucmVwZWF0ZWQgPyByZXBlYXRlZEZpZWxkc1xuICAgICAgICAgICAgOiBmaWVsZHNbaV0ubWFwID8gbWFwRmllbGRzXG4gICAgICAgICAgICA6IG5vcm1hbEZpZWxkcykucHVzaChmaWVsZHNbaV0pO1xuXG4gICAgaWYgKHJlcGVhdGVkRmllbGRzLmxlbmd0aCkgeyBnZW5cbiAgICAoXCJpZihvLmFycmF5c3x8by5kZWZhdWx0cyl7XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVwZWF0ZWRGaWVsZHMubGVuZ3RoOyArK2kpIGdlblxuICAgICAgICAoXCJkJXM9W11cIiwgdXRpbC5zYWZlUHJvcChyZXBlYXRlZEZpZWxkc1tpXS5uYW1lKSk7XG4gICAgICAgIGdlblxuICAgIChcIn1cIik7XG4gICAgfVxuXG4gICAgaWYgKG1hcEZpZWxkcy5sZW5ndGgpIHsgZ2VuXG4gICAgKFwiaWYoby5vYmplY3RzfHxvLmRlZmF1bHRzKXtcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXBGaWVsZHMubGVuZ3RoOyArK2kpIGdlblxuICAgICAgICAoXCJkJXM9e31cIiwgdXRpbC5zYWZlUHJvcChtYXBGaWVsZHNbaV0ubmFtZSkpO1xuICAgICAgICBnZW5cbiAgICAoXCJ9XCIpO1xuICAgIH1cblxuICAgIGlmIChub3JtYWxGaWVsZHMubGVuZ3RoKSB7IGdlblxuICAgIChcImlmKG8uZGVmYXVsdHMpe1wiKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vcm1hbEZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gbm9ybWFsRmllbGRzW2ldLFxuICAgICAgICAgICAgICAgIHByb3AgID0gdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSBnZW5cbiAgICAgICAgKFwiZCVzPW8uZW51bXM9PT1TdHJpbmc/JWo6JWpcIiwgcHJvcCwgZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlc0J5SWRbZmllbGQudHlwZURlZmF1bHRdLCBmaWVsZC50eXBlRGVmYXVsdCk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5sb25nKSBnZW5cbiAgICAgICAgKFwiaWYodXRpbC5Mb25nKXtcIilcbiAgICAgICAgICAgIChcInZhciBuPW5ldyB1dGlsLkxvbmcoJWksJWksJWopXCIsIGZpZWxkLnR5cGVEZWZhdWx0LmxvdywgZmllbGQudHlwZURlZmF1bHQuaGlnaCwgZmllbGQudHlwZURlZmF1bHQudW5zaWduZWQpXG4gICAgICAgICAgICAoXCJkJXM9by5sb25ncz09PVN0cmluZz9uLnRvU3RyaW5nKCk6by5sb25ncz09PU51bWJlcj9uLnRvTnVtYmVyKCk6blwiLCBwcm9wKVxuICAgICAgICAoXCJ9ZWxzZVwiKVxuICAgICAgICAgICAgKFwiZCVzPW8ubG9uZ3M9PT1TdHJpbmc/JWo6JWlcIiwgcHJvcCwgZmllbGQudHlwZURlZmF1bHQudG9TdHJpbmcoKSwgZmllbGQudHlwZURlZmF1bHQudG9OdW1iZXIoKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5ieXRlcykge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheURlZmF1bHQgPSBcIltcIiArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZpZWxkLnR5cGVEZWZhdWx0KS5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAoXCJpZihvLmJ5dGVzPT09U3RyaW5nKWQlcz0lalwiLCBwcm9wLCBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgZmllbGQudHlwZURlZmF1bHQpKVxuICAgICAgICAoXCJlbHNle1wiKVxuICAgICAgICAgICAgKFwiZCVzPSVzXCIsIHByb3AsIGFycmF5RGVmYXVsdClcbiAgICAgICAgICAgIChcImlmKG8uYnl0ZXMhPT1BcnJheSlkJXM9dXRpbC5uZXdCdWZmZXIoZCVzKVwiLCBwcm9wLCBwcm9wKVxuICAgICAgICAoXCJ9XCIpO1xuICAgICAgICAgICAgfSBlbHNlIGdlblxuICAgICAgICAoXCJkJXM9JWpcIiwgcHJvcCwgZmllbGQudHlwZURlZmF1bHQpOyAvLyBhbHNvIG1lc3NhZ2VzICg9bnVsbClcbiAgICAgICAgfSBnZW5cbiAgICAoXCJ9XCIpO1xuICAgIH1cbiAgICB2YXIgaGFzS3MyID0gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV0sXG4gICAgICAgICAgICBpbmRleCA9IG10eXBlLl9maWVsZHNBcnJheS5pbmRleE9mKGZpZWxkKSxcbiAgICAgICAgICAgIHByb3AgID0gdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkge1xuICAgICAgICAgICAgaWYgKCFoYXNLczIpIHsgaGFzS3MyID0gdHJ1ZTsgZ2VuXG4gICAgKFwidmFyIGtzMlwiKTtcbiAgICAgICAgICAgIH0gZ2VuXG4gICAgKFwiaWYobSVzJiYoa3MyPU9iamVjdC5rZXlzKG0lcykpLmxlbmd0aCl7XCIsIHByb3AsIHByb3ApXG4gICAgICAgIChcImQlcz17fVwiLCBwcm9wKVxuICAgICAgICAoXCJmb3IodmFyIGo9MDtqPGtzMi5sZW5ndGg7KytqKXtcIik7XG4gICAgICAgICAgICBnZW5WYWx1ZVBhcnRpYWxfdG9PYmplY3QoZ2VuLCBmaWVsZCwgLyogc29ydGVkICovIGluZGV4LCBwcm9wICsgXCJba3MyW2pdXVwiKVxuICAgICAgICAoXCJ9XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxuICAgIChcImlmKG0lcyYmbSVzLmxlbmd0aCl7XCIsIHByb3AsIHByb3ApXG4gICAgICAgIChcImQlcz1bXVwiLCBwcm9wKVxuICAgICAgICAoXCJmb3IodmFyIGo9MDtqPG0lcy5sZW5ndGg7KytqKXtcIiwgcHJvcCk7XG4gICAgICAgICAgICBnZW5WYWx1ZVBhcnRpYWxfdG9PYmplY3QoZ2VuLCBmaWVsZCwgLyogc29ydGVkICovIGluZGV4LCBwcm9wICsgXCJbal1cIilcbiAgICAgICAgKFwifVwiKTtcbiAgICAgICAgfSBlbHNlIHsgZ2VuXG4gICAgKFwiaWYobSVzIT1udWxsJiZtLmhhc093blByb3BlcnR5KCVqKSl7XCIsIHByb3AsIGZpZWxkLm5hbWUpOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG4gICAgICAgIGdlblZhbHVlUGFydGlhbF90b09iamVjdChnZW4sIGZpZWxkLCAvKiBzb3J0ZWQgKi8gaW5kZXgsIHByb3ApO1xuICAgICAgICBpZiAoZmllbGQucGFydE9mKSBnZW5cbiAgICAgICAgKFwiaWYoby5vbmVvZnMpXCIpXG4gICAgICAgICAgICAoXCJkJXM9JWpcIiwgdXRpbC5zYWZlUHJvcChmaWVsZC5wYXJ0T2YubmFtZSksIGZpZWxkLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGdlblxuICAgIChcIn1cIik7XG4gICAgfVxuICAgIHJldHVybiBnZW5cbiAgICAoXCJyZXR1cm4gZFwiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbn07XG4iXSwibmFtZXMiOlsiY29udmVydGVyIiwiZXhwb3J0cyIsIkVudW0iLCJyZXF1aXJlIiwidXRpbCIsImdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0IiwiZ2VuIiwiZmllbGQiLCJmaWVsZEluZGV4IiwicHJvcCIsImRlZmF1bHRBbHJlYWR5RW1pdHRlZCIsInJlc29sdmVkVHlwZSIsInZhbHVlcyIsImtleXMiLCJPYmplY3QiLCJpIiwibGVuZ3RoIiwidHlwZURlZmF1bHQiLCJyZXBlYXRlZCIsImZ1bGxOYW1lIiwiaXNVbnNpZ25lZCIsInR5cGUiLCJmcm9tT2JqZWN0IiwibXR5cGUiLCJmaWVsZHMiLCJmaWVsZHNBcnJheSIsImNvZGVnZW4iLCJuYW1lIiwicmVzb2x2ZSIsInNhZmVQcm9wIiwibWFwIiwiZ2VuVmFsdWVQYXJ0aWFsX3RvT2JqZWN0IiwidG9PYmplY3QiLCJzbGljZSIsInNvcnQiLCJjb21wYXJlRmllbGRzQnlJZCIsInJlcGVhdGVkRmllbGRzIiwibWFwRmllbGRzIiwibm9ybWFsRmllbGRzIiwicGFydE9mIiwicHVzaCIsInZhbHVlc0J5SWQiLCJsb25nIiwibG93IiwiaGlnaCIsInVuc2lnbmVkIiwidG9TdHJpbmciLCJ0b051bWJlciIsImJ5dGVzIiwiYXJyYXlEZWZhdWx0IiwiQXJyYXkiLCJwcm90b3R5cGUiLCJjYWxsIiwiam9pbiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwiaGFzS3MyIiwiaW5kZXgiLCJfZmllbGRzQXJyYXkiLCJpbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/converter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/decoder.js":
/*!************************************************!*\
  !*** ./node_modules/protobufjs/src/decoder.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = decoder;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/protobufjs/src/enum.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\");\nfunction missing(field) {\n    return \"missing required '\" + field.name + \"'\";\n}\n/**\n * Generates a decoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ function decoder(mtype) {\n    /* eslint-disable no-unexpected-multiline */ var gen = util.codegen([\n        \"r\",\n        \"l\"\n    ], mtype.name + \"$decode\")(\"if(!(r instanceof Reader))\")(\"r=Reader.create(r)\")(\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function(field) {\n        return field.map;\n    }).length ? \",k,value\" : \"\"))(\"while(r.pos<c){\")(\"var t=r.uint32()\");\n    if (mtype.group) gen(\"if((t&7)===4)\")(\"break\");\n    gen(\"switch(t>>>3){\");\n    var i = 0;\n    for(; i < /* initializes */ mtype.fieldsArray.length; ++i){\n        var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? \"int32\" : field.type, ref = \"m\" + util.safeProp(field.name);\n        gen(\"case %i: {\", field.id);\n        // Map fields\n        if (field.map) {\n            gen(\"if(%s===util.emptyObject)\", ref)(\"%s={}\", ref)(\"var c2 = r.uint32()+r.pos\");\n            if (types.defaults[field.keyType] !== undefined) gen(\"k=%j\", types.defaults[field.keyType]);\n            else gen(\"k=null\");\n            if (types.defaults[type] !== undefined) gen(\"value=%j\", types.defaults[type]);\n            else gen(\"value=null\");\n            gen(\"while(r.pos<c2){\")(\"var tag2=r.uint32()\")(\"switch(tag2>>>3){\")(\"case 1: k=r.%s(); break\", field.keyType)(\"case 2:\");\n            if (types.basic[type] === undefined) gen(\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\n            else gen(\"value=r.%s()\", type);\n            gen(\"break\")(\"default:\")(\"r.skipType(tag2&7)\")(\"break\")(\"}\")(\"}\");\n            if (types.long[field.keyType] !== undefined) gen('%s[typeof k===\"object\"?util.longToHash(k):k]=value', ref);\n            else gen(\"%s[k]=value\", ref);\n        // Repeated fields\n        } else if (field.repeated) {\n            gen(\"if(!(%s&&%s.length))\", ref, ref)(\"%s=[]\", ref);\n            // Packable (always check for forward and backward compatiblity)\n            if (types.packed[type] !== undefined) gen(\"if((t&7)===2){\")(\"var c2=r.uint32()+r.pos\")(\"while(r.pos<c2)\")(\"%s.push(r.%s())\", ref, type)(\"}else\");\n            // Non-packed\n            if (types.basic[type] === undefined) gen(field.resolvedType.group ? \"%s.push(types[%i].decode(r))\" : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);\n            else gen(\"%s.push(r.%s())\", ref, type);\n        // Non-repeated\n        } else if (types.basic[type] === undefined) gen(field.resolvedType.group ? \"%s=types[%i].decode(r)\" : \"%s=types[%i].decode(r,r.uint32())\", ref, i);\n        else gen(\"%s=r.%s()\", ref, type);\n        gen(\"break\")(\"}\");\n    // Unknown fields\n    }\n    gen(\"default:\")(\"r.skipType(t&7)\")(\"break\")(\"}\")(\"}\");\n    // Field presence\n    for(i = 0; i < mtype._fieldsArray.length; ++i){\n        var rfield = mtype._fieldsArray[i];\n        if (rfield.required) gen(\"if(!m.hasOwnProperty(%j))\", rfield.name)(\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n    }\n    return gen(\"return m\");\n/* eslint-enable no-unexpected-multiline */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLE9BQVVDLG1CQUFPQSxDQUFDLDJEQUFRLEdBQzFCQyxRQUFVRCxtQkFBT0EsQ0FBQyw2REFBUyxHQUMzQkUsT0FBVUYsbUJBQU9BLENBQUMsMkRBQVE7QUFFOUIsU0FBU0csUUFBUUMsS0FBSztJQUNsQixPQUFPLHVCQUF1QkEsTUFBTUMsSUFBSSxHQUFHO0FBQy9DO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNQLFFBQVFRLEtBQUs7SUFDbEIsMENBQTBDLEdBQzFDLElBQUlDLE1BQU1MLEtBQUtNLE9BQU8sQ0FBQztRQUFDO1FBQUs7S0FBSSxFQUFFRixNQUFNRCxJQUFJLEdBQUcsV0FDL0MsOEJBQ0ksc0JBQ0osc0RBQXVEQyxDQUFBQSxNQUFNRyxXQUFXLENBQUNDLE1BQU0sQ0FBQyxTQUFTTixLQUFLO1FBQUksT0FBT0EsTUFBTU8sR0FBRztJQUFFLEdBQUdDLE1BQU0sR0FBRyxhQUFhLEVBQUMsR0FDOUksbUJBQ0k7SUFDTCxJQUFJTixNQUFNTyxLQUFLLEVBQUVOLElBQ1osaUJBQ0k7SUFDVEEsSUFDSztJQUVMLElBQUlPLElBQUk7SUFDUixNQUFPQSxJQUFJLGVBQWUsR0FBR1IsTUFBTUcsV0FBVyxDQUFDRyxNQUFNLEVBQUUsRUFBRUUsRUFBRztRQUN4RCxJQUFJVixRQUFRRSxNQUFNUyxZQUFZLENBQUNELEVBQUUsQ0FBQ0UsT0FBTyxJQUNyQ0MsT0FBUWIsTUFBTWMsWUFBWSxZQUFZbkIsT0FBTyxVQUFVSyxNQUFNYSxJQUFJLEVBQ2pFRSxNQUFRLE1BQU1qQixLQUFLa0IsUUFBUSxDQUFDaEIsTUFBTUMsSUFBSTtRQUFHRSxJQUN4QyxjQUFjSCxNQUFNaUIsRUFBRTtRQUUzQixhQUFhO1FBQ2IsSUFBSWpCLE1BQU1PLEdBQUcsRUFBRTtZQUFFSixJQUNSLDZCQUE2QlksS0FDekIsU0FBU0EsS0FDYjtZQUVMLElBQUlsQixNQUFNcUIsUUFBUSxDQUFDbEIsTUFBTW1CLE9BQU8sQ0FBQyxLQUFLQyxXQUFXakIsSUFDNUMsUUFBUU4sTUFBTXFCLFFBQVEsQ0FBQ2xCLE1BQU1tQixPQUFPLENBQUM7aUJBQ3JDaEIsSUFDQTtZQUVMLElBQUlOLE1BQU1xQixRQUFRLENBQUNMLEtBQUssS0FBS08sV0FBV2pCLElBQ25DLFlBQVlOLE1BQU1xQixRQUFRLENBQUNMLEtBQUs7aUJBQ2hDVixJQUNBO1lBRUxBLElBQ0ssb0JBQ0ksdUJBQ0EscUJBQ0ksMkJBQTJCSCxNQUFNbUIsT0FBTyxFQUN4QztZQUViLElBQUl0QixNQUFNd0IsS0FBSyxDQUFDUixLQUFLLEtBQUtPLFdBQVdqQixJQUNwQix3Q0FBd0NPLElBQUksa0JBQWtCO2lCQUMxRVAsSUFDWSxnQkFBZ0JVO1lBRWpDVixJQUNpQixTQUNKLFlBQ0ksc0JBQ0EsU0FDUixLQUNKO1lBRUwsSUFBSU4sTUFBTXlCLElBQUksQ0FBQ3RCLE1BQU1tQixPQUFPLENBQUMsS0FBS0MsV0FBV2pCLElBQ3hDLHNEQUF3RFk7aUJBQ3hEWixJQUNBLGVBQWVZO1FBRXhCLGtCQUFrQjtRQUNsQixPQUFPLElBQUlmLE1BQU11QixRQUFRLEVBQUU7WUFBRXBCLElBRXBCLHdCQUF3QlksS0FBS0EsS0FDekIsU0FBU0E7WUFFbEIsZ0VBQWdFO1lBQ2hFLElBQUlsQixNQUFNMkIsTUFBTSxDQUFDWCxLQUFLLEtBQUtPLFdBQVdqQixJQUNqQyxrQkFDSSwyQkFDQSxtQkFDSSxtQkFBbUJZLEtBQUtGLE1BQ2hDO1lBRUwsYUFBYTtZQUNiLElBQUloQixNQUFNd0IsS0FBSyxDQUFDUixLQUFLLEtBQUtPLFdBQVdqQixJQUFJSCxNQUFNYyxZQUFZLENBQUNMLEtBQUssR0FDdkQsaUNBQ0EsMkNBQTJDTSxLQUFLTDtpQkFDckRQLElBQ0ksbUJBQW1CWSxLQUFLRjtRQUVyQyxlQUFlO1FBQ2YsT0FBTyxJQUFJaEIsTUFBTXdCLEtBQUssQ0FBQ1IsS0FBSyxLQUFLTyxXQUFXakIsSUFBSUgsTUFBTWMsWUFBWSxDQUFDTCxLQUFLLEdBQzlELDJCQUNBLHFDQUFxQ00sS0FBS0w7YUFDL0NQLElBQ0ksYUFBYVksS0FBS0Y7UUFDM0JWLElBQ1MsU0FDSjtJQUNMLGlCQUFpQjtJQUNyQjtJQUFFQSxJQUNPLFlBQ0ksbUJBQ0EsU0FFUixLQUNKO0lBRUQsaUJBQWlCO0lBQ2pCLElBQUtPLElBQUksR0FBR0EsSUFBSVIsTUFBTVMsWUFBWSxDQUFDSCxNQUFNLEVBQUUsRUFBRUUsRUFBRztRQUM1QyxJQUFJZSxTQUFTdkIsTUFBTVMsWUFBWSxDQUFDRCxFQUFFO1FBQ2xDLElBQUllLE9BQU9DLFFBQVEsRUFBRXZCLElBQ3hCLDZCQUE2QnNCLE9BQU94QixJQUFJLEVBQ3BDLDZDQUE2Q0YsUUFBUTBCO0lBQzFEO0lBRUEsT0FBT3RCLElBQ047QUFDRCx5Q0FBeUMsR0FDN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2RlY29kZXIuanM/ZWYwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlcjtcblxudmFyIEVudW0gICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIHR5cGVzICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcbiAgICB1dGlsICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuZnVuY3Rpb24gbWlzc2luZyhmaWVsZCkge1xuICAgIHJldHVybiBcIm1pc3NpbmcgcmVxdWlyZWQgJ1wiICsgZmllbGQubmFtZSArIFwiJ1wiO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGRlY29kZXIgc3BlY2lmaWMgdG8gdGhlIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZGVjb2RlcihtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJyXCIsIFwibFwiXSwgbXR5cGUubmFtZSArIFwiJGRlY29kZVwiKVxuICAgIChcImlmKCEociBpbnN0YW5jZW9mIFJlYWRlcikpXCIpXG4gICAgICAgIChcInI9UmVhZGVyLmNyZWF0ZShyKVwiKVxuICAgIChcInZhciBjPWw9PT11bmRlZmluZWQ/ci5sZW46ci5wb3MrbCxtPW5ldyB0aGlzLmN0b3JcIiArIChtdHlwZS5maWVsZHNBcnJheS5maWx0ZXIoZnVuY3Rpb24oZmllbGQpIHsgcmV0dXJuIGZpZWxkLm1hcDsgfSkubGVuZ3RoID8gXCIsayx2YWx1ZVwiIDogXCJcIikpXG4gICAgKFwid2hpbGUoci5wb3M8Yyl7XCIpXG4gICAgICAgIChcInZhciB0PXIudWludDMyKClcIik7XG4gICAgaWYgKG10eXBlLmdyb3VwKSBnZW5cbiAgICAgICAgKFwiaWYoKHQmNyk9PT00KVwiKVxuICAgICAgICAgICAgKFwiYnJlYWtcIik7XG4gICAgZ2VuXG4gICAgICAgIChcInN3aXRjaCh0Pj4+Myl7XCIpO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gbXR5cGUuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gbXR5cGUuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmUoKSxcbiAgICAgICAgICAgIHR5cGUgID0gZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSA/IFwiaW50MzJcIiA6IGZpZWxkLnR5cGUsXG4gICAgICAgICAgICByZWYgICA9IFwibVwiICsgdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTsgZ2VuXG4gICAgICAgICAgICAoXCJjYXNlICVpOiB7XCIsIGZpZWxkLmlkKTtcblxuICAgICAgICAvLyBNYXAgZmllbGRzXG4gICAgICAgIGlmIChmaWVsZC5tYXApIHsgZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoJXM9PT11dGlsLmVtcHR5T2JqZWN0KVwiLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcIiVzPXt9XCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJ2YXIgYzIgPSByLnVpbnQzMigpK3IucG9zXCIpO1xuXG4gICAgICAgICAgICBpZiAodHlwZXMuZGVmYXVsdHNbZmllbGQua2V5VHlwZV0gIT09IHVuZGVmaW5lZCkgZ2VuXG4gICAgICAgICAgICAgICAgKFwiaz0lalwiLCB0eXBlcy5kZWZhdWx0c1tmaWVsZC5rZXlUeXBlXSk7XG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgIChcIms9bnVsbFwiKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVzLmRlZmF1bHRzW3R5cGVdICE9PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgIChcInZhbHVlPSVqXCIsIHR5cGVzLmRlZmF1bHRzW3R5cGVdKTtcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAgICAgKFwidmFsdWU9bnVsbFwiKTtcblxuICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgKFwid2hpbGUoci5wb3M8YzIpe1wiKVxuICAgICAgICAgICAgICAgICAgICAoXCJ2YXIgdGFnMj1yLnVpbnQzMigpXCIpXG4gICAgICAgICAgICAgICAgICAgIChcInN3aXRjaCh0YWcyPj4+Myl7XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJjYXNlIDE6IGs9ci4lcygpOyBicmVha1wiLCBmaWVsZC5rZXlUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiY2FzZSAyOlwiKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVzLmJhc2ljW3R5cGVdID09PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInZhbHVlPXR5cGVzWyVpXS5kZWNvZGUocixyLnVpbnQzMigpKVwiLCBpKTsgLy8gY2FuJ3QgYmUgZ3JvdXBzXG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInZhbHVlPXIuJXMoKVwiLCB0eXBlKTtcblxuICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwici5za2lwVHlwZSh0YWcyJjcpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgKFwifVwiKVxuICAgICAgICAgICAgICAgIChcIn1cIik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlcy5sb25nW2ZpZWxkLmtleVR5cGVdICE9PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgIChcIiVzW3R5cGVvZiBrPT09XFxcIm9iamVjdFxcXCI/dXRpbC5sb25nVG9IYXNoKGspOmtdPXZhbHVlXCIsIHJlZik7XG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgIChcIiVzW2tdPXZhbHVlXCIsIHJlZik7XG5cbiAgICAgICAgLy8gUmVwZWF0ZWQgZmllbGRzXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHsgZ2VuXG5cbiAgICAgICAgICAgICAgICAoXCJpZighKCVzJiYlcy5sZW5ndGgpKVwiLCByZWYsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwiJXM9W11cIiwgcmVmKTtcblxuICAgICAgICAgICAgLy8gUGFja2FibGUgKGFsd2F5cyBjaGVjayBmb3IgZm9yd2FyZCBhbmQgYmFja3dhcmQgY29tcGF0aWJsaXR5KVxuICAgICAgICAgICAgaWYgKHR5cGVzLnBhY2tlZFt0eXBlXSAhPT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZigodCY3KT09PTIpe1wiKVxuICAgICAgICAgICAgICAgICAgICAoXCJ2YXIgYzI9ci51aW50MzIoKStyLnBvc1wiKVxuICAgICAgICAgICAgICAgICAgICAoXCJ3aGlsZShyLnBvczxjMilcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIiVzLnB1c2goci4lcygpKVwiLCByZWYsIHR5cGUpXG4gICAgICAgICAgICAgICAgKFwifWVsc2VcIik7XG5cbiAgICAgICAgICAgIC8vIE5vbi1wYWNrZWRcbiAgICAgICAgICAgIGlmICh0eXBlcy5iYXNpY1t0eXBlXSA9PT0gdW5kZWZpbmVkKSBnZW4oZmllbGQucmVzb2x2ZWRUeXBlLmdyb3VwXG4gICAgICAgICAgICAgICAgICAgID8gXCIlcy5wdXNoKHR5cGVzWyVpXS5kZWNvZGUocikpXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIiVzLnB1c2godHlwZXNbJWldLmRlY29kZShyLHIudWludDMyKCkpKVwiLCByZWYsIGkpO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAgICAgKFwiJXMucHVzaChyLiVzKCkpXCIsIHJlZiwgdHlwZSk7XG5cbiAgICAgICAgLy8gTm9uLXJlcGVhdGVkXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZXMuYmFzaWNbdHlwZV0gPT09IHVuZGVmaW5lZCkgZ2VuKGZpZWxkLnJlc29sdmVkVHlwZS5ncm91cFxuICAgICAgICAgICAgICAgID8gXCIlcz10eXBlc1slaV0uZGVjb2RlKHIpXCJcbiAgICAgICAgICAgICAgICA6IFwiJXM9dHlwZXNbJWldLmRlY29kZShyLHIudWludDMyKCkpXCIsIHJlZiwgaSk7XG4gICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAgICAgKFwiJXM9ci4lcygpXCIsIHJlZiwgdHlwZSk7XG4gICAgICAgIGdlblxuICAgICAgICAgICAgICAgIChcImJyZWFrXCIpXG4gICAgICAgICAgICAoXCJ9XCIpO1xuICAgICAgICAvLyBVbmtub3duIGZpZWxkc1xuICAgIH0gZ2VuXG4gICAgICAgICAgICAoXCJkZWZhdWx0OlwiKVxuICAgICAgICAgICAgICAgIChcInIuc2tpcFR5cGUodCY3KVwiKVxuICAgICAgICAgICAgICAgIChcImJyZWFrXCIpXG5cbiAgICAgICAgKFwifVwiKVxuICAgIChcIn1cIik7XG5cbiAgICAvLyBGaWVsZCBwcmVzZW5jZVxuICAgIGZvciAoaSA9IDA7IGkgPCBtdHlwZS5fZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJmaWVsZCA9IG10eXBlLl9maWVsZHNBcnJheVtpXTtcbiAgICAgICAgaWYgKHJmaWVsZC5yZXF1aXJlZCkgZ2VuXG4gICAgKFwiaWYoIW0uaGFzT3duUHJvcGVydHkoJWopKVwiLCByZmllbGQubmFtZSlcbiAgICAgICAgKFwidGhyb3cgdXRpbC5Qcm90b2NvbEVycm9yKCVqLHtpbnN0YW5jZTptfSlcIiwgbWlzc2luZyhyZmllbGQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2VuXG4gICAgKFwicmV0dXJuIG1cIik7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJkZWNvZGVyIiwiRW51bSIsInJlcXVpcmUiLCJ0eXBlcyIsInV0aWwiLCJtaXNzaW5nIiwiZmllbGQiLCJuYW1lIiwibXR5cGUiLCJnZW4iLCJjb2RlZ2VuIiwiZmllbGRzQXJyYXkiLCJmaWx0ZXIiLCJtYXAiLCJsZW5ndGgiLCJncm91cCIsImkiLCJfZmllbGRzQXJyYXkiLCJyZXNvbHZlIiwidHlwZSIsInJlc29sdmVkVHlwZSIsInJlZiIsInNhZmVQcm9wIiwiaWQiLCJkZWZhdWx0cyIsImtleVR5cGUiLCJ1bmRlZmluZWQiLCJiYXNpYyIsImxvbmciLCJyZXBlYXRlZCIsInBhY2tlZCIsInJmaWVsZCIsInJlcXVpcmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/decoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/encoder.js":
/*!************************************************!*\
  !*** ./node_modules/protobufjs/src/encoder.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = encoder;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/protobufjs/src/enum.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\");\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genTypePartial(gen, field, fieldIndex, ref) {\n    return field.resolvedType.group ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ function encoder(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ var gen = util.codegen([\n        \"m\",\n        \"w\"\n    ], mtype.name + \"$encode\")(\"if(!w)\")(\"w=Writer.create()\");\n    var i, ref;\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    for(var i = 0; i < fields.length; ++i){\n        var field = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? \"int32\" : field.type, wireType = types.basic[type];\n        ref = \"m\" + util.safeProp(field.name);\n        // Map fields\n        if (field.map) {\n            gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n            (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)(\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n            if (wireType === undefined) gen(\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n            else gen(\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n            gen(\"}\")(\"}\");\n        // Repeated fields\n        } else if (field.repeated) {\n            gen(\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n            // Packed repeated\n            if (field.packed && types.packed[type] !== undefined) {\n                gen(\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)(\"for(var i=0;i<%s.length;++i)\", ref)(\"w.%s(%s[i])\", type, ref)(\"w.ldelim()\");\n            // Non-packed\n            } else {\n                gen(\"for(var i=0;i<%s.length;++i)\", ref);\n                if (wireType === undefined) genTypePartial(gen, field, index, ref + \"[i]\");\n                else gen(\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n            }\n            gen(\"}\");\n        // Non-repeated\n        } else {\n            if (field.optional) gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n            if (wireType === undefined) genTypePartial(gen, field, index, ref);\n            else gen(\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n        }\n    }\n    return gen(\"return w\");\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZW5jb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLE9BQVdDLG1CQUFPQSxDQUFDLDJEQUFRLEdBQzNCQyxRQUFXRCxtQkFBT0EsQ0FBQyw2REFBUyxHQUM1QkUsT0FBV0YsbUJBQU9BLENBQUMsMkRBQVE7QUFFL0I7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTRyxlQUFlQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxHQUFHO0lBQy9DLE9BQU9GLE1BQU1HLFlBQVksQ0FBQ0MsS0FBSyxHQUN6QkwsSUFBSSxnREFBZ0RFLFlBQVlDLEtBQUssQ0FBQ0YsTUFBTUssRUFBRSxJQUFJLElBQUksT0FBTyxHQUFHLENBQUNMLE1BQU1LLEVBQUUsSUFBSSxJQUFJLE9BQU8sS0FDeEhOLElBQUkscURBQXFERSxZQUFZQyxLQUFLLENBQUNGLE1BQU1LLEVBQUUsSUFBSSxJQUFJLE9BQU87QUFDNUc7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU1osUUFBUWEsS0FBSztJQUNsQiwwRUFBMEUsR0FDMUUsSUFBSVAsTUFBTUYsS0FBS1UsT0FBTyxDQUFDO1FBQUM7UUFBSztLQUFJLEVBQUVELE1BQU1FLElBQUksR0FBRyxXQUMvQyxVQUNJO0lBRUwsSUFBSUMsR0FBR1A7SUFFUCxpR0FBaUc7SUFDakcsSUFBSVEsU0FBUyxlQUFlLEdBQUdKLE1BQU1LLFdBQVcsQ0FBQ0MsS0FBSyxHQUFHQyxJQUFJLENBQUNoQixLQUFLaUIsaUJBQWlCO0lBRXBGLElBQUssSUFBSUwsSUFBSSxHQUFHQSxJQUFJQyxPQUFPSyxNQUFNLEVBQUUsRUFBRU4sRUFBRztRQUNwQyxJQUFJVCxRQUFXVSxNQUFNLENBQUNELEVBQUUsQ0FBQ08sT0FBTyxJQUM1QkMsUUFBV1gsTUFBTVksWUFBWSxDQUFDQyxPQUFPLENBQUNuQixRQUN0Q29CLE9BQVdwQixNQUFNRyxZQUFZLFlBQVlULE9BQU8sVUFBVU0sTUFBTW9CLElBQUksRUFDcEVDLFdBQVd6QixNQUFNMEIsS0FBSyxDQUFDRixLQUFLO1FBQzVCbEIsTUFBVyxNQUFNTCxLQUFLMEIsUUFBUSxDQUFDdkIsTUFBTVEsSUFBSTtRQUU3QyxhQUFhO1FBQ2IsSUFBSVIsTUFBTXdCLEdBQUcsRUFBRTtZQUNYekIsSUFDUCxtREFBbURHLEtBQUtGLE1BQU1RLElBQUksRUFBRSw0QkFBNEI7YUFDNUYsb0RBQW9ETixLQUNoRCw0Q0FBNEMsQ0FBQ0YsTUFBTUssRUFBRSxJQUFJLElBQUksT0FBTyxHQUFHLElBQUlULE1BQU02QixNQUFNLENBQUN6QixNQUFNMEIsT0FBTyxDQUFDLEVBQUUxQixNQUFNMEIsT0FBTztZQUN0SCxJQUFJTCxhQUFhTSxXQUFXNUIsSUFDM0IscUVBQXFFa0IsT0FBT2YsTUFBTSxrQkFBa0I7aUJBQ2hHSCxJQUNKLHNDQUFzQyxLQUFLc0IsVUFBVUQsTUFBTWxCO1lBQzVESCxJQUNILEtBQ0o7UUFFTyxrQkFBa0I7UUFDdEIsT0FBTyxJQUFJQyxNQUFNNEIsUUFBUSxFQUFFO1lBQUU3QixJQUNoQyw0QkFBNEJHLEtBQUtBLE1BQU0sNEJBQTRCO1lBRTVELGtCQUFrQjtZQUNsQixJQUFJRixNQUFNNkIsTUFBTSxJQUFJakMsTUFBTWlDLE1BQU0sQ0FBQ1QsS0FBSyxLQUFLTyxXQUFXO2dCQUFFNUIsSUFFM0QsdUJBQXVCLENBQUNDLE1BQU1LLEVBQUUsSUFBSSxJQUFJLE9BQU8sR0FDL0MsZ0NBQWdDSCxLQUM1QixlQUFla0IsTUFBTWxCLEtBQ3pCO1lBRUcsYUFBYTtZQUNiLE9BQU87Z0JBQUVILElBRVosZ0NBQWdDRztnQkFDekIsSUFBSW1CLGFBQWFNLFdBQ3JCN0IsZUFBZUMsS0FBS0MsT0FBT2lCLE9BQU9mLE1BQU07cUJBQy9CSCxJQUNSLDBCQUEwQixDQUFDQyxNQUFNSyxFQUFFLElBQUksSUFBSWdCLFFBQU8sTUFBTyxHQUFHRCxNQUFNbEI7WUFFbkU7WUFBRUgsSUFDVDtRQUVHLGVBQWU7UUFDZixPQUFPO1lBQ0gsSUFBSUMsTUFBTThCLFFBQVEsRUFBRS9CLElBQzNCLGtEQUFrREcsS0FBS0YsTUFBTVEsSUFBSSxHQUFHLDRCQUE0QjtZQUV6RixJQUFJYSxhQUFhTSxXQUNyQjdCLGVBQWVDLEtBQUtDLE9BQU9pQixPQUFPZjtpQkFDekJILElBQ1IsdUJBQXVCLENBQUNDLE1BQU1LLEVBQUUsSUFBSSxJQUFJZ0IsUUFBTyxNQUFPLEdBQUdELE1BQU1sQjtRQUVoRTtJQUNKO0lBRUEsT0FBT0gsSUFDTjtBQUNELHlFQUF5RSxHQUM3RSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXByb2plY3QvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZW5jb2Rlci5qcz8yZGYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVyO1xuXG52YXIgRW51bSAgICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIHR5cGVzICAgID0gcmVxdWlyZShcIi4vdHlwZXNcIiksXG4gICAgdXRpbCAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBhcnRpYWwgbWVzc2FnZSB0eXBlIGVuY29kZXIuXG4gKiBAcGFyYW0ge0NvZGVnZW59IGdlbiBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBSZWZsZWN0ZWQgZmllbGRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZEluZGV4IEZpZWxkIGluZGV4XG4gKiBAcGFyYW0ge3N0cmluZ30gcmVmIFZhcmlhYmxlIHJlZmVyZW5jZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZ2VuVHlwZVBhcnRpYWwoZ2VuLCBmaWVsZCwgZmllbGRJbmRleCwgcmVmKSB7XG4gICAgcmV0dXJuIGZpZWxkLnJlc29sdmVkVHlwZS5ncm91cFxuICAgICAgICA/IGdlbihcInR5cGVzWyVpXS5lbmNvZGUoJXMsdy51aW50MzIoJWkpKS51aW50MzIoJWkpXCIsIGZpZWxkSW5kZXgsIHJlZiwgKGZpZWxkLmlkIDw8IDMgfCAzKSA+Pj4gMCwgKGZpZWxkLmlkIDw8IDMgfCA0KSA+Pj4gMClcbiAgICAgICAgOiBnZW4oXCJ0eXBlc1slaV0uZW5jb2RlKCVzLHcudWludDMyKCVpKS5mb3JrKCkpLmxkZWxpbSgpXCIsIGZpZWxkSW5kZXgsIHJlZiwgKGZpZWxkLmlkIDw8IDMgfCAyKSA+Pj4gMCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGVuY29kZXIgc3BlY2lmaWMgdG8gdGhlIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZW5jb2RlcihtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcIm1cIiwgXCJ3XCJdLCBtdHlwZS5uYW1lICsgXCIkZW5jb2RlXCIpXG4gICAgKFwiaWYoIXcpXCIpXG4gICAgICAgIChcInc9V3JpdGVyLmNyZWF0ZSgpXCIpO1xuXG4gICAgdmFyIGksIHJlZjtcblxuICAgIC8vIFwid2hlbiBhIG1lc3NhZ2UgaXMgc2VyaWFsaXplZCBpdHMga25vd24gZmllbGRzIHNob3VsZCBiZSB3cml0dGVuIHNlcXVlbnRpYWxseSBieSBmaWVsZCBudW1iZXJcIlxuICAgIHZhciBmaWVsZHMgPSAvKiBpbml0aWFsaXplcyAqLyBtdHlwZS5maWVsZHNBcnJheS5zbGljZSgpLnNvcnQodXRpbC5jb21wYXJlRmllbGRzQnlJZCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgICAgPSBmaWVsZHNbaV0ucmVzb2x2ZSgpLFxuICAgICAgICAgICAgaW5kZXggICAgPSBtdHlwZS5fZmllbGRzQXJyYXkuaW5kZXhPZihmaWVsZCksXG4gICAgICAgICAgICB0eXBlICAgICA9IGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0gPyBcImludDMyXCIgOiBmaWVsZC50eXBlLFxuICAgICAgICAgICAgd2lyZVR5cGUgPSB0eXBlcy5iYXNpY1t0eXBlXTtcbiAgICAgICAgICAgIHJlZiAgICAgID0gXCJtXCIgKyB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xuXG4gICAgICAgIC8vIE1hcCBmaWVsZHNcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkge1xuICAgICAgICAgICAgZ2VuXG4gICAgKFwiaWYoJXMhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sJWopKXtcIiwgcmVmLCBmaWVsZC5uYW1lKSAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG4gICAgICAgIChcImZvcih2YXIga3M9T2JqZWN0LmtleXMoJXMpLGk9MDtpPGtzLmxlbmd0aDsrK2kpe1wiLCByZWYpXG4gICAgICAgICAgICAoXCJ3LnVpbnQzMiglaSkuZm9yaygpLnVpbnQzMiglaSkuJXMoa3NbaV0pXCIsIChmaWVsZC5pZCA8PCAzIHwgMikgPj4+IDAsIDggfCB0eXBlcy5tYXBLZXlbZmllbGQua2V5VHlwZV0sIGZpZWxkLmtleVR5cGUpO1xuICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgKFwidHlwZXNbJWldLmVuY29kZSglc1trc1tpXV0sdy51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCkubGRlbGltKClcIiwgaW5kZXgsIHJlZik7IC8vIGNhbid0IGJlIGdyb3Vwc1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgIChcIi51aW50MzIoJWkpLiVzKCVzW2tzW2ldXSkubGRlbGltKClcIiwgMTYgfCB3aXJlVHlwZSwgdHlwZSwgcmVmKTtcbiAgICAgICAgICAgIGdlblxuICAgICAgICAoXCJ9XCIpXG4gICAgKFwifVwiKTtcblxuICAgICAgICAgICAgLy8gUmVwZWF0ZWQgZmllbGRzXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHsgZ2VuXG4gICAgKFwiaWYoJXMhPW51bGwmJiVzLmxlbmd0aCl7XCIsIHJlZiwgcmVmKTsgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxuXG4gICAgICAgICAgICAvLyBQYWNrZWQgcmVwZWF0ZWRcbiAgICAgICAgICAgIGlmIChmaWVsZC5wYWNrZWQgJiYgdHlwZXMucGFja2VkW3R5cGVdICE9PSB1bmRlZmluZWQpIHsgZ2VuXG5cbiAgICAgICAgKFwidy51aW50MzIoJWkpLmZvcmsoKVwiLCAoZmllbGQuaWQgPDwgMyB8IDIpID4+PiAwKVxuICAgICAgICAoXCJmb3IodmFyIGk9MDtpPCVzLmxlbmd0aDsrK2kpXCIsIHJlZilcbiAgICAgICAgICAgIChcIncuJXMoJXNbaV0pXCIsIHR5cGUsIHJlZilcbiAgICAgICAgKFwidy5sZGVsaW0oKVwiKTtcblxuICAgICAgICAgICAgLy8gTm9uLXBhY2tlZFxuICAgICAgICAgICAgfSBlbHNlIHsgZ2VuXG5cbiAgICAgICAgKFwiZm9yKHZhciBpPTA7aTwlcy5sZW5ndGg7KytpKVwiLCByZWYpO1xuICAgICAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZ2VuVHlwZVBhcnRpYWwoZ2VuLCBmaWVsZCwgaW5kZXgsIHJlZiArIFwiW2ldXCIpO1xuICAgICAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAoXCJ3LnVpbnQzMiglaSkuJXMoJXNbaV0pXCIsIChmaWVsZC5pZCA8PCAzIHwgd2lyZVR5cGUpID4+PiAwLCB0eXBlLCByZWYpO1xuXG4gICAgICAgICAgICB9IGdlblxuICAgIChcIn1cIik7XG5cbiAgICAgICAgLy8gTm9uLXJlcGVhdGVkXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZmllbGQub3B0aW9uYWwpIGdlblxuICAgIChcImlmKCVzIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCVqKSlcIiwgcmVmLCBmaWVsZC5uYW1lKTsgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxuXG4gICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgZ2VuVHlwZVBhcnRpYWwoZ2VuLCBmaWVsZCwgaW5kZXgsIHJlZik7XG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAoXCJ3LnVpbnQzMiglaSkuJXMoJXMpXCIsIChmaWVsZC5pZCA8PCAzIHwgd2lyZVR5cGUpID4+PiAwLCB0eXBlLCByZWYpO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2VuXG4gICAgKFwicmV0dXJuIHdcIik7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImVuY29kZXIiLCJFbnVtIiwicmVxdWlyZSIsInR5cGVzIiwidXRpbCIsImdlblR5cGVQYXJ0aWFsIiwiZ2VuIiwiZmllbGQiLCJmaWVsZEluZGV4IiwicmVmIiwicmVzb2x2ZWRUeXBlIiwiZ3JvdXAiLCJpZCIsIm10eXBlIiwiY29kZWdlbiIsIm5hbWUiLCJpIiwiZmllbGRzIiwiZmllbGRzQXJyYXkiLCJzbGljZSIsInNvcnQiLCJjb21wYXJlRmllbGRzQnlJZCIsImxlbmd0aCIsInJlc29sdmUiLCJpbmRleCIsIl9maWVsZHNBcnJheSIsImluZGV4T2YiLCJ0eXBlIiwid2lyZVR5cGUiLCJiYXNpYyIsInNhZmVQcm9wIiwibWFwIiwibWFwS2V5Iiwia2V5VHlwZSIsInVuZGVmaW5lZCIsInJlcGVhdGVkIiwicGFja2VkIiwib3B0aW9uYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/encoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/enum.js":
/*!*********************************************!*\
  !*** ./node_modules/protobufjs/src/enum.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Enum;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/protobufjs/src/object.js\");\n((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = \"Enum\";\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/protobufjs/src/namespace.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new enum instance.\n * @classdesc Reflected enum.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {Object.<string,number>} [values] Enum values as an object, by name\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this enum\n * @param {Object.<string,string>} [comments] The value comments for this enum\n * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum\n */ function Enum(name, values, options, comment, comments, valuesOptions) {\n    ReflectionObject.call(this, name, options);\n    if (values && typeof values !== \"object\") throw TypeError(\"values must be an object\");\n    /**\n     * Enum values by id.\n     * @type {Object.<number,string>}\n     */ this.valuesById = {};\n    /**\n     * Enum values by name.\n     * @type {Object.<string,number>}\n     */ this.values = Object.create(this.valuesById); // toJSON, marker\n    /**\n     * Enum comment text.\n     * @type {string|null}\n     */ this.comment = comment;\n    /**\n     * Value comment texts, if any.\n     * @type {Object.<string,string>}\n     */ this.comments = comments || {};\n    /**\n     * Values options, if any\n     * @type {Object<string, Object<string, *>>|undefined}\n     */ this.valuesOptions = valuesOptions;\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */ this.reserved = undefined; // toJSON\n    // Note that values inherit valuesById on their prototype which makes them a TypeScript-\n    // compatible enum. This is used by pbts to write actual enum definitions that work for\n    // static and reflection code alike instead of emitting generic object definitions.\n    if (values) {\n        for(var keys = Object.keys(values), i = 0; i < keys.length; ++i)if (typeof values[keys[i]] === \"number\") this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];\n    }\n}\n/**\n * Enum descriptor.\n * @interface IEnum\n * @property {Object.<string,number>} values Enum values\n * @property {Object.<string,*>} [options] Enum options\n */ /**\n * Constructs an enum from an enum descriptor.\n * @param {string} name Enum name\n * @param {IEnum} json Enum descriptor\n * @returns {Enum} Created enum\n * @throws {TypeError} If arguments are invalid\n */ Enum.fromJSON = function fromJSON(name, json) {\n    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);\n    enm.reserved = json.reserved;\n    return enm;\n};\n/**\n * Converts this enum to an enum descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IEnum} Enum descriptor\n */ Enum.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\",\n        this.options,\n        \"valuesOptions\",\n        this.valuesOptions,\n        \"values\",\n        this.values,\n        \"reserved\",\n        this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"comment\",\n        keepComments ? this.comment : undefined,\n        \"comments\",\n        keepComments ? this.comments : undefined\n    ]);\n};\n/**\n * Adds a value to this enum.\n * @param {string} name Value name\n * @param {number} id Value id\n * @param {string} [comment] Comment, if any\n * @param {Object.<string, *>|undefined} [options] Options, if any\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a value with this name or id\n */ Enum.prototype.add = function add(name, id, comment, options) {\n    // utilized by the parser but not by .fromJSON\n    if (!util.isString(name)) throw TypeError(\"name must be a string\");\n    if (!util.isInteger(id)) throw TypeError(\"id must be an integer\");\n    if (this.values[name] !== undefined) throw Error(\"duplicate name '\" + name + \"' in \" + this);\n    if (this.isReservedId(id)) throw Error(\"id \" + id + \" is reserved in \" + this);\n    if (this.isReservedName(name)) throw Error(\"name '\" + name + \"' is reserved in \" + this);\n    if (this.valuesById[id] !== undefined) {\n        if (!(this.options && this.options.allow_alias)) throw Error(\"duplicate id \" + id + \" in \" + this);\n        this.values[name] = id;\n    } else this.valuesById[this.values[name] = id] = name;\n    if (options) {\n        if (this.valuesOptions === undefined) this.valuesOptions = {};\n        this.valuesOptions[name] = options || null;\n    }\n    this.comments[name] = comment || null;\n    return this;\n};\n/**\n * Removes a value from this enum\n * @param {string} name Value name\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `name` is not a name of this enum\n */ Enum.prototype.remove = function remove(name) {\n    if (!util.isString(name)) throw TypeError(\"name must be a string\");\n    var val = this.values[name];\n    if (val == null) throw Error(\"name '\" + name + \"' does not exist in \" + this);\n    delete this.valuesById[val];\n    delete this.values[name];\n    delete this.comments[name];\n    if (this.valuesOptions) delete this.valuesOptions[name];\n    return this;\n};\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Enum.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Enum.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZW51bS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLDJCQUEyQjtBQUMzQixJQUFJQyxtQkFBbUJDLG1CQUFPQSxDQUFDLCtEQUFVO0FBQ3hDLEVBQUNGLEtBQUtHLFNBQVMsR0FBR0MsT0FBT0MsTUFBTSxDQUFDSixpQkFBaUJFLFNBQVMsR0FBR0csV0FBVyxHQUFHTixJQUFHLEVBQUdPLFNBQVMsR0FBRztBQUU5RixJQUFJQyxZQUFZTixtQkFBT0EsQ0FBQyxxRUFBYSxHQUNqQ08sT0FBT1AsbUJBQU9BLENBQUMsMkRBQVE7QUFFM0I7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxTQUFTRixLQUFLVSxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsYUFBYTtJQUNqRWQsaUJBQWlCZSxJQUFJLENBQUMsSUFBSSxFQUFFTixNQUFNRTtJQUVsQyxJQUFJRCxVQUFVLE9BQU9BLFdBQVcsVUFDNUIsTUFBTU0sVUFBVTtJQUVwQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLFVBQVUsR0FBRyxDQUFDO0lBRW5COzs7S0FHQyxHQUNELElBQUksQ0FBQ1AsTUFBTSxHQUFHUCxPQUFPQyxNQUFNLENBQUMsSUFBSSxDQUFDYSxVQUFVLEdBQUcsaUJBQWlCO0lBRS9EOzs7S0FHQyxHQUNELElBQUksQ0FBQ0wsT0FBTyxHQUFHQTtJQUVmOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsUUFBUSxHQUFHQSxZQUFZLENBQUM7SUFFN0I7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxhQUFhLEdBQUdBO0lBRXJCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0ksUUFBUSxHQUFHQyxXQUFXLFNBQVM7SUFFcEMsd0ZBQXdGO0lBQ3hGLHVGQUF1RjtJQUN2RixtRkFBbUY7SUFFbkYsSUFBSVQsUUFDQTtRQUFBLElBQUssSUFBSVUsT0FBT2pCLE9BQU9pQixJ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SUFDakMsT0FBTyxJQUFJO0FBQ2Y7QUFFQTs7Ozs7O0NBTUMsR0FDRGIsS0FBS0csU0FBUyxDQUFDcUMsTUFBTSxHQUFHLFNBQVNBLE9BQU85QixJQUFJO0lBRXhDLElBQUksQ0FBQ0QsS0FBS3lCLFFBQVEsQ0FBQ3hCLE9BQ2YsTUFBTU8sVUFBVTtJQUVwQixJQUFJd0IsTUFBTSxJQUFJLENBQUM5QixNQUFNLENBQUNELEtBQUs7SUFDM0IsSUFBSStCLE9BQU8sTUFDUCxNQUFNTCxNQUFNLFdBQVcxQixPQUFPLHlCQUF5QixJQUFJO0lBRS9ELE9BQU8sSUFBSSxDQUFDUSxVQUFVLENBQUN1QixJQUFJO0lBQzNCLE9BQU8sSUFBSSxDQUFDOUIsTUFBTSxDQUFDRCxLQUFLO0lBQ3hCLE9BQU8sSUFBSSxDQUFDSSxRQUFRLENBQUNKLEtBQUs7SUFDMUIsSUFBSSxJQUFJLENBQUNLLGFBQWEsRUFDbEIsT0FBTyxJQUFJLENBQUNBLGFBQWEsQ0FBQ0wsS0FBSztJQUVuQyxPQUFPLElBQUk7QUFDZjtBQUVBOzs7O0NBSUMsR0FDRFYsS0FBS0csU0FBUyxDQUFDa0MsWUFBWSxHQUFHLFNBQVNBLGFBQWFKLEVBQUU7SUFDbEQsT0FBT3pCLFVBQVU2QixZQUFZLENBQUMsSUFBSSxDQUFDbEIsUUFBUSxFQUFFYztBQUNqRDtBQUVBOzs7O0NBSUMsR0FDRGpDLEtBQUtHLFNBQVMsQ0FBQ21DLGNBQWMsR0FBRyxTQUFTQSxlQUFlNUIsSUFBSTtJQUN4RCxPQUFPRixVQUFVOEIsY0FBYyxDQUFDLElBQUksQ0FBQ25CLFFBQVEsRUFBRVQ7QUFDbkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2VudW0uanM/NDEwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gRW51bTtcblxuLy8gZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG52YXIgUmVmbGVjdGlvbk9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbigoRW51bS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBFbnVtKS5jbGFzc05hbWUgPSBcIkVudW1cIjtcblxudmFyIE5hbWVzcGFjZSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKSxcbiAgICB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGVudW0gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBlbnVtLlxuICogQGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBVbmlxdWUgbmFtZSB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fSBbdmFsdWVzXSBFbnVtIHZhbHVlcyBhcyBhbiBvYmplY3QsIGJ5IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIFRoZSBjb21tZW50IGZvciB0aGlzIGVudW1cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn0gW2NvbW1lbnRzXSBUaGUgdmFsdWUgY29tbWVudHMgZm9yIHRoaXMgZW51bVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxPYmplY3Q8c3RyaW5nLCo+Pnx1bmRlZmluZWR9IFt2YWx1ZXNPcHRpb25zXSBUaGUgdmFsdWUgb3B0aW9ucyBmb3IgdGhpcyBlbnVtXG4gKi9cbmZ1bmN0aW9uIEVudW0obmFtZSwgdmFsdWVzLCBvcHRpb25zLCBjb21tZW50LCBjb21tZW50cywgdmFsdWVzT3B0aW9ucykge1xuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIGlmICh2YWx1ZXMgJiYgdHlwZW9mIHZhbHVlcyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwidmFsdWVzIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuXG4gICAgLyoqXG4gICAgICogRW51bSB2YWx1ZXMgYnkgaWQuXG4gICAgICogQHR5cGUge09iamVjdC48bnVtYmVyLHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXNCeUlkID0ge307XG5cbiAgICAvKipcbiAgICAgKiBFbnVtIHZhbHVlcyBieSBuYW1lLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnZhbHVlc0J5SWQpOyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogRW51bSBjb21tZW50IHRleHQuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBjb21tZW50IHRleHRzLCBpZiBhbnkuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50cyA9IGNvbW1lbnRzIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVmFsdWVzIG9wdGlvbnMsIGlmIGFueVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCAqPj58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzT3B0aW9ucyA9IHZhbHVlc09wdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBSZXNlcnZlZCByYW5nZXMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcltdfHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5yZXNlcnZlZCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvLyBOb3RlIHRoYXQgdmFsdWVzIGluaGVyaXQgdmFsdWVzQnlJZCBvbiB0aGVpciBwcm90b3R5cGUgd2hpY2ggbWFrZXMgdGhlbSBhIFR5cGVTY3JpcHQtXG4gICAgLy8gY29tcGF0aWJsZSBlbnVtLiBUaGlzIGlzIHVzZWQgYnkgcGJ0cyB0byB3cml0ZSBhY3R1YWwgZW51bSBkZWZpbml0aW9ucyB0aGF0IHdvcmsgZm9yXG4gICAgLy8gc3RhdGljIGFuZCByZWZsZWN0aW9uIGNvZGUgYWxpa2UgaW5zdGVhZCBvZiBlbWl0dGluZyBnZW5lcmljIG9iamVjdCBkZWZpbml0aW9ucy5cblxuICAgIGlmICh2YWx1ZXMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlc1trZXlzW2ldXSA9PT0gXCJudW1iZXJcIikgLy8gdXNlIGZvcndhcmQgZW50cmllcyBvbmx5XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXNCeUlkWyB0aGlzLnZhbHVlc1trZXlzW2ldXSA9IHZhbHVlc1trZXlzW2ldXSBdID0ga2V5c1tpXTtcbn1cblxuLyoqXG4gKiBFbnVtIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElFbnVtXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLG51bWJlcj59IHZhbHVlcyBFbnVtIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIEVudW0gb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBlbnVtIGZyb20gYW4gZW51bSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRW51bSBuYW1lXG4gKiBAcGFyYW0ge0lFbnVtfSBqc29uIEVudW0gZGVzY3JpcHRvclxuICogQHJldHVybnMge0VudW19IENyZWF0ZWQgZW51bVxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuRW51bS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICB2YXIgZW5tID0gbmV3IEVudW0obmFtZSwganNvbi52YWx1ZXMsIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50LCBqc29uLmNvbW1lbnRzKTtcbiAgICBlbm0ucmVzZXJ2ZWQgPSBqc29uLnJlc2VydmVkO1xuICAgIHJldHVybiBlbm07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgZW51bSB0byBhbiBlbnVtIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJRW51bX0gRW51bSBkZXNjcmlwdG9yXG4gKi9cbkVudW0ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJvcHRpb25zXCIgICAgICAgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwidmFsdWVzT3B0aW9uc1wiICwgdGhpcy52YWx1ZXNPcHRpb25zLFxuICAgICAgICBcInZhbHVlc1wiICAgICAgICAsIHRoaXMudmFsdWVzLFxuICAgICAgICBcInJlc2VydmVkXCIgICAgICAsIHRoaXMucmVzZXJ2ZWQgJiYgdGhpcy5yZXNlcnZlZC5sZW5ndGggPyB0aGlzLnJlc2VydmVkIDogdW5kZWZpbmVkLFxuICAgICAgICBcImNvbW1lbnRcIiAgICAgICAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJjb21tZW50c1wiICAgICAgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnRzIDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSB2YWx1ZSB0byB0aGlzIGVudW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBWYWx1ZSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgVmFsdWUgaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gQ29tbWVudCwgaWYgYW55XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCAqPnx1bmRlZmluZWR9IFtvcHRpb25zXSBPcHRpb25zLCBpZiBhbnlcbiAqIEByZXR1cm5zIHtFbnVtfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIHZhbHVlIHdpdGggdGhpcyBuYW1lIG9yIGlkXG4gKi9cbkVudW0ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChuYW1lLCBpZCwgY29tbWVudCwgb3B0aW9ucykge1xuICAgIC8vIHV0aWxpemVkIGJ5IHRoZSBwYXJzZXIgYnV0IG5vdCBieSAuZnJvbUpTT05cblxuICAgIGlmICghdXRpbC5pc1N0cmluZyhuYW1lKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpZCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImlkIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcblxuICAgIGlmICh0aGlzLnZhbHVlc1tuYW1lXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBuYW1lICdcIiArIG5hbWUgKyBcIicgaW4gXCIgKyB0aGlzKTtcblxuICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWRJZChpZCkpXG4gICAgICAgIHRocm93IEVycm9yKFwiaWQgXCIgKyBpZCArIFwiIGlzIHJlc2VydmVkIGluIFwiICsgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5pc1Jlc2VydmVkTmFtZShuYW1lKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJuYW1lICdcIiArIG5hbWUgKyBcIicgaXMgcmVzZXJ2ZWQgaW4gXCIgKyB0aGlzKTtcblxuICAgIGlmICh0aGlzLnZhbHVlc0J5SWRbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCEodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5hbGxvd19hbGlhcykpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBpZCBcIiArIGlkICsgXCIgaW4gXCIgKyB0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXNbbmFtZV0gPSBpZDtcbiAgICB9IGVsc2VcbiAgICAgICAgdGhpcy52YWx1ZXNCeUlkW3RoaXMudmFsdWVzW25hbWVdID0gaWRdID0gbmFtZTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlc09wdGlvbnMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMudmFsdWVzT3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLnZhbHVlc09wdGlvbnNbbmFtZV0gPSBvcHRpb25zIHx8IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5jb21tZW50c1tuYW1lXSA9IGNvbW1lbnQgfHwgbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhpcyBlbnVtXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBWYWx1ZSBuYW1lXG4gKiBAcmV0dXJucyB7RW51bX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIGBuYW1lYCBpcyBub3QgYSBuYW1lIG9mIHRoaXMgZW51bVxuICovXG5FbnVtLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKG5hbWUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICB2YXIgdmFsID0gdGhpcy52YWx1ZXNbbmFtZV07XG4gICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5hbWUgJ1wiICsgbmFtZSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiBcIiArIHRoaXMpO1xuXG4gICAgZGVsZXRlIHRoaXMudmFsdWVzQnlJZFt2YWxdO1xuICAgIGRlbGV0ZSB0aGlzLnZhbHVlc1tuYW1lXTtcbiAgICBkZWxldGUgdGhpcy5jb21tZW50c1tuYW1lXTtcbiAgICBpZiAodGhpcy52YWx1ZXNPcHRpb25zKVxuICAgICAgICBkZWxldGUgdGhpcy52YWx1ZXNPcHRpb25zW25hbWVdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgaWQgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgSWQgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuRW51bS5wcm90b3R5cGUuaXNSZXNlcnZlZElkID0gZnVuY3Rpb24gaXNSZXNlcnZlZElkKGlkKSB7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5pc1Jlc2VydmVkSWQodGhpcy5yZXNlcnZlZCwgaWQpO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbkVudW0ucHJvdG90eXBlLmlzUmVzZXJ2ZWROYW1lID0gZnVuY3Rpb24gaXNSZXNlcnZlZE5hbWUobmFtZSkge1xuICAgIHJldHVybiBOYW1lc3BhY2UuaXNSZXNlcnZlZE5hbWUodGhpcy5yZXNlcnZlZCwgbmFtZSk7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJFbnVtIiwiUmVmbGVjdGlvbk9iamVjdCIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImNsYXNzTmFtZSIsIk5hbWVzcGFjZSIsInV0aWwiLCJuYW1lIiwidmFsdWVzIiwib3B0aW9ucyIsImNvbW1lbnQiLCJjb21tZW50cyIsInZhbHVlc09wdGlvbnMiLCJjYWxsIiwiVHlwZUVycm9yIiwidmFsdWVzQnlJZCIsInJlc2VydmVkIiwidW5kZWZpbmVkIiwia2V5cyIsImkiLCJsZW5ndGgiLCJmcm9tSlNPTiIsImpzb24iLCJlbm0iLCJ0b0pTT04iLCJ0b0pTT05PcHRpb25zIiwia2VlcENvbW1lbnRzIiwiQm9vbGVhbiIsInRvT2JqZWN0IiwiYWRkIiwiaWQiLCJpc1N0cmluZyIsImlzSW50ZWdlciIsIkVycm9yIiwiaXNSZXNlcnZlZElkIiwiaXNSZXNlcnZlZE5hbWUiLCJhbGxvd19hbGlhcyIsInJlbW92ZSIsInZhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/enum.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/field.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/field.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Field;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/protobufjs/src/object.js\");\n((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = \"Field\";\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/protobufjs/src/enum.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\");\nvar Type; // cyclic\nvar ruleRe = /^required|optional|repeated$/;\n/**\n * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.\n * @name Field\n * @classdesc Reflected message field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n */ /**\n * Constructs a field from a field descriptor.\n * @param {string} name Field name\n * @param {IField} json Field descriptor\n * @returns {Field} Created field\n * @throws {TypeError} If arguments are invalid\n */ Field.fromJSON = function fromJSON(name, json) {\n    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);\n};\n/**\n * Not an actual constructor. Use {@link Field} instead.\n * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports FieldBase\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */ function Field(name, id, type, rule, extend, options, comment) {\n    if (util.isObject(rule)) {\n        comment = extend;\n        options = rule;\n        rule = extend = undefined;\n    } else if (util.isObject(extend)) {\n        comment = options;\n        options = extend;\n        extend = undefined;\n    }\n    ReflectionObject.call(this, name, options);\n    if (!util.isInteger(id) || id < 0) throw TypeError(\"id must be a non-negative integer\");\n    if (!util.isString(type)) throw TypeError(\"type must be a string\");\n    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase())) throw TypeError(\"rule must be a string rule\");\n    if (extend !== undefined && !util.isString(extend)) throw TypeError(\"extend must be a string\");\n    /**\n     * Field rule, if any.\n     * @type {string|undefined}\n     */ if (rule === \"proto3_optional\") {\n        rule = \"optional\";\n    }\n    this.rule = rule && rule !== \"optional\" ? rule : undefined; // toJSON\n    /**\n     * Field type.\n     * @type {string}\n     */ this.type = type; // toJSON\n    /**\n     * Unique field id.\n     * @type {number}\n     */ this.id = id; // toJSON, marker\n    /**\n     * Extended type if different from parent.\n     * @type {string|undefined}\n     */ this.extend = extend || undefined; // toJSON\n    /**\n     * Whether this field is required.\n     * @type {boolean}\n     */ this.required = rule === \"required\";\n    /**\n     * Whether this field is optional.\n     * @type {boolean}\n     */ this.optional = !this.required;\n    /**\n     * Whether this field is repeated.\n     * @type {boolean}\n     */ this.repeated = rule === \"repeated\";\n    /**\n     * Whether this field is a map or not.\n     * @type {boolean}\n     */ this.map = false;\n    /**\n     * Message this field belongs to.\n     * @type {Type|null}\n     */ this.message = null;\n    /**\n     * OneOf this field belongs to, if any,\n     * @type {OneOf|null}\n     */ this.partOf = null;\n    /**\n     * The field type's default value.\n     * @type {*}\n     */ this.typeDefault = null;\n    /**\n     * The field's default value on prototypes.\n     * @type {*}\n     */ this.defaultValue = null;\n    /**\n     * Whether this field's value should be treated as a long.\n     * @type {boolean}\n     */ this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;\n    /**\n     * Whether this field's value is a buffer.\n     * @type {boolean}\n     */ this.bytes = type === \"bytes\";\n    /**\n     * Resolved type if not a basic type.\n     * @type {Type|Enum|null}\n     */ this.resolvedType = null;\n    /**\n     * Sister-field within the extended type if a declaring extension field.\n     * @type {Field|null}\n     */ this.extensionField = null;\n    /**\n     * Sister-field within the declaring namespace if an extended field.\n     * @type {Field|null}\n     */ this.declaringField = null;\n    /**\n     * Internally remembers whether this field is packed.\n     * @type {boolean|null}\n     * @private\n     */ this._packed = null;\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */ this.comment = comment;\n}\n/**\n * Determines whether this field is packed. Only relevant when repeated and working with proto2.\n * @name Field#packed\n * @type {boolean}\n * @readonly\n */ Object.defineProperty(Field.prototype, \"packed\", {\n    get: function() {\n        // defaults to packed=true if not explicity set to false\n        if (this._packed === null) this._packed = this.getOption(\"packed\") !== false;\n        return this._packed;\n    }\n});\n/**\n * @override\n */ Field.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (name === \"packed\") this._packed = null;\n    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);\n};\n/**\n * Field descriptor.\n * @interface IField\n * @property {string} [rule=\"optional\"] Field rule\n * @property {string} type Field type\n * @property {number} id Field id\n * @property {Object.<string,*>} [options] Field options\n */ /**\n * Extension field descriptor.\n * @interface IExtensionField\n * @extends IField\n * @property {string} extend Extended type\n */ /**\n * Converts this field to a field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IField} Field descriptor\n */ Field.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"rule\",\n        this.rule !== \"optional\" && this.rule || undefined,\n        \"type\",\n        this.type,\n        \"id\",\n        this.id,\n        \"extend\",\n        this.extend,\n        \"options\",\n        this.options,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * Resolves this field's type references.\n * @returns {Field} `this`\n * @throws {Error} If any reference cannot be resolved\n */ Field.prototype.resolve = function resolve() {\n    if (this.resolved) return this;\n    if ((this.typeDefault = types.defaults[this.type]) === undefined) {\n        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);\n        if (this.resolvedType instanceof Type) this.typeDefault = null;\n        else this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined\n    } else if (this.options && this.options.proto3_optional) {\n        // proto3 scalar value marked optional; should default to null\n        this.typeDefault = null;\n    }\n    // use explicitly set default value if present\n    if (this.options && this.options[\"default\"] != null) {\n        this.typeDefault = this.options[\"default\"];\n        if (this.resolvedType instanceof Enum && typeof this.typeDefault === \"string\") this.typeDefault = this.resolvedType.values[this.typeDefault];\n    }\n    // remove unnecessary options\n    if (this.options) {\n        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum)) delete this.options.packed;\n        if (!Object.keys(this.options).length) this.options = undefined;\n    }\n    // convert to internal data type if necesssary\n    if (this.long) {\n        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === \"u\");\n        /* istanbul ignore else */ if (Object.freeze) Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)\n    } else if (this.bytes && typeof this.typeDefault === \"string\") {\n        var buf;\n        if (util.base64.test(this.typeDefault)) util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);\n        else util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);\n        this.typeDefault = buf;\n    }\n    // take special care of maps and repeated fields\n    if (this.map) this.defaultValue = util.emptyObject;\n    else if (this.repeated) this.defaultValue = util.emptyArray;\n    else this.defaultValue = this.typeDefault;\n    // ensure proper value on prototype\n    if (this.parent instanceof Type) this.parent.ctor.prototype[this.name] = this.defaultValue;\n    return ReflectionObject.prototype.resolve.call(this);\n};\n/**\n * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).\n * @typedef FieldDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} fieldName Field name\n * @returns {undefined}\n */ /**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"string\"|\"bool\"|\"bytes\"|Object} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @param {T} [defaultValue] Default value\n * @returns {FieldDecorator} Decorator function\n * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]\n */ Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {\n    // submessage: decorate the submessage and use its name as the type\n    if (typeof fieldType === \"function\") fieldType = util.decorateType(fieldType).name;\n    else if (fieldType && typeof fieldType === \"object\") fieldType = util.decorateEnum(fieldType).name;\n    return function fieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, {\n            \"default\": defaultValue\n        }));\n    };\n};\n/**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {Constructor<T>|string} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @returns {FieldDecorator} Decorator function\n * @template T extends Message<T>\n * @variation 2\n */ // like Field.d but without a default value\n// Sets up cyclic dependencies (called in index-light)\nField._configure = function configure(Type_) {\n    Type = Type_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZmllbGQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQiwyQkFBMkI7QUFDM0IsSUFBSUMsbUJBQW1CQyxtQkFBT0EsQ0FBQywrREFBVTtBQUN4QyxFQUFDRixNQUFNRyxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0osaUJBQWlCRSxTQUFTLEdBQUdHLFdBQVcsR0FBR04sS0FBSSxFQUFHTyxTQUFTLEdBQUc7QUFFaEcsSUFBSUMsT0FBUU4sbUJBQU9BLENBQUMsMkRBQVEsR0FDeEJPLFFBQVFQLG1CQUFPQSxDQUFDLDZEQUFTLEdBQ3pCUSxPQUFRUixtQkFBT0EsQ0FBQywyREFBUTtBQUU1QixJQUFJUyxNQUFNLFNBQVM7QUFFbkIsSUFBSUMsU0FBUztBQUViOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUVEOzs7Ozs7Q0FNQyxHQUNEWixNQUFNYSxRQUFRLEdBQUcsU0FBU0EsU0FBU0MsSUFBSSxFQUFFQyxJQUFJO0lBQ3pDLE9BQU8sSUFBSWYsTUFBTWMsTUFBTUMsS0FBS0MsRUFBRSxFQUFFRCxLQUFLRSxJQUFJLEVBQUVGLEtBQUtHLElBQUksRUFBRUgsS0FBS0ksTUFBTSxFQUFFSixLQUFLSyxPQUFPLEVBQUVMLEtBQUtNLE9BQU87QUFDakc7QUFFQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0QsU0FBU3JCLE1BQU1jLElBQUksRUFBRUUsRUFBRSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFFekQsSUFBSVgsS0FBS1ksUUFBUSxDQUFDSixPQUFPO1FBQ3JCRyxVQUFVRjtRQUNWQyxVQUFVRjtRQUNWQSxPQUFPQyxTQUFTSTtJQUNwQixPQUFPLElBQUliLEtBQUtZLFFBQVEsQ0FBQ0gsU0FBUztRQUM5QkUsVUFBVUQ7UUFDVkEsVUFBVUQ7UUFDVkEsU0FBU0k7SUFDYjtJQUVBdEIsaUJBQWlCdUIsSUFBSSxD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QUFHLFNBQVNDLGNBQWNDLE9BQU8sRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUU3QyxZQUFZO0lBRXhFLG1FQUFtRTtJQUNuRSxJQUFJLE9BQU80QyxjQUFjLFlBQ3JCQSxZQUFZeEUsS0FBSzBFLFlBQVksQ0FBQ0YsV0FBV3BFLElBQUk7U0FHNUMsSUFBSW9FLGFBQWEsT0FBT0EsY0FBYyxVQUN2Q0EsWUFBWXhFLEtBQUsyRSxZQUFZLENBQUNILFdBQVdwRSxJQUFJO0lBRWpELE9BQU8sU0FBU3dFLGVBQWVuRixTQUFTLEVBQUVvRixTQUFTO1FBQy9DN0UsS0FBSzBFLFlBQVksQ0FBQ2pGLFVBQVVHLFdBQVcsRUFDbENrRixHQUFHLENBQUMsSUFBSXhGLE1BQU11RixXQUFXTixTQUFTQyxXQUFXQyxXQUFXO1lBQUUsV0FBVzdDO1FBQWE7SUFDM0Y7QUFDSjtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRCwyQ0FBMkM7QUFFM0Msc0RBQXNEO0FBQ3REdEMsTUFBTXlGLFVBQVUsR0FBRyxTQUFTQyxVQUFVQyxLQUFLO0lBQ3ZDaEYsT0FBT2dGO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2ZpZWxkLmpzP2U4YjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEZpZWxkO1xuXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuKChGaWVsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBGaWVsZCkuY2xhc3NOYW1lID0gXCJGaWVsZFwiO1xuXG52YXIgRW51bSAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIHR5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIiksXG4gICAgdXRpbCAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgVHlwZTsgLy8gY3ljbGljXG5cbnZhciBydWxlUmUgPSAvXnJlcXVpcmVkfG9wdGlvbmFsfHJlcGVhdGVkJC87XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBtZXNzYWdlIGZpZWxkIGluc3RhbmNlLiBOb3RlIHRoYXQge0BsaW5rIE1hcEZpZWxkfG1hcCBmaWVsZHN9IGhhdmUgdGhlaXIgb3duIGNsYXNzLlxuICogQG5hbWUgRmllbGRcbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIG1lc3NhZ2UgZmllbGQuXG4gKiBAZXh0ZW5kcyBGaWVsZEJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVW5pcXVlIG5hbWUgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgaWQgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFZhbHVlIHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdC48c3RyaW5nLCo+fSBbcnVsZT1cIm9wdGlvbmFsXCJdIEZpZWxkIHJ1bGVcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdC48c3RyaW5nLCo+fSBbZXh0ZW5kXSBFeHRlbmRlZCB0eXBlIGlmIGRpZmZlcmVudCBmcm9tIHBhcmVudFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBmaWVsZCBmcm9tIGEgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcbiAqIEBwYXJhbSB7SUZpZWxkfSBqc29uIEZpZWxkIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtGaWVsZH0gQ3JlYXRlZCBmaWVsZFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuRmllbGQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBGaWVsZChuYW1lLCBqc29uLmlkLCBqc29uLnR5cGUsIGpzb24ucnVsZSwganNvbi5leHRlbmQsIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50KTtcbn07XG5cbi8qKlxuICogTm90IGFuIGFjdHVhbCBjb25zdHJ1Y3Rvci4gVXNlIHtAbGluayBGaWVsZH0gaW5zdGVhZC5cbiAqIEBjbGFzc2Rlc2MgQmFzZSBjbGFzcyBvZiBhbGwgcmVmbGVjdGVkIG1lc3NhZ2UgZmllbGRzLiBUaGlzIGlzIG5vdCBhbiBhY3R1YWwgY2xhc3MgYnV0IGhlcmUgZm9yIHRoZSBzYWtlIG9mIGhhdmluZyBjb25zaXN0ZW50IHR5cGUgZGVmaW5pdGlvbnMuXG4gKiBAZXhwb3J0cyBGaWVsZEJhc2VcbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVW5pcXVlIG5hbWUgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgaWQgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFZhbHVlIHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdC48c3RyaW5nLCo+fSBbcnVsZT1cIm9wdGlvbmFsXCJdIEZpZWxkIHJ1bGVcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdC48c3RyaW5nLCo+fSBbZXh0ZW5kXSBFeHRlbmRlZCB0eXBlIGlmIGRpZmZlcmVudCBmcm9tIHBhcmVudFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gQ29tbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWVsZFxuICovXG5mdW5jdGlvbiBGaWVsZChuYW1lLCBpZCwgdHlwZSwgcnVsZSwgZXh0ZW5kLCBvcHRpb25zLCBjb21tZW50KSB7XG5cbiAgICBpZiAodXRpbC5pc09iamVjdChydWxlKSkge1xuICAgICAgICBjb21tZW50ID0gZXh0ZW5kO1xuICAgICAgICBvcHRpb25zID0gcnVsZTtcbiAgICAgICAgcnVsZSA9IGV4dGVuZCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNPYmplY3QoZXh0ZW5kKSkge1xuICAgICAgICBjb21tZW50ID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZDtcbiAgICAgICAgZXh0ZW5kID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIGlmICghdXRpbC5pc0ludGVnZXIoaWQpIHx8IGlkIDwgMClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiaWQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyXCIpO1xuXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKHR5cGUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJ0eXBlIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICBpZiAocnVsZSAhPT0gdW5kZWZpbmVkICYmICFydWxlUmUudGVzdChydWxlID0gcnVsZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJydWxlIG11c3QgYmUgYSBzdHJpbmcgcnVsZVwiKTtcblxuICAgIGlmIChleHRlbmQgIT09IHVuZGVmaW5lZCAmJiAhdXRpbC5pc1N0cmluZyhleHRlbmQpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJleHRlbmQgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIC8qKlxuICAgICAqIEZpZWxkIHJ1bGUsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBpZiAocnVsZSA9PT0gXCJwcm90bzNfb3B0aW9uYWxcIikge1xuICAgICAgICBydWxlID0gXCJvcHRpb25hbFwiO1xuICAgIH1cbiAgICB0aGlzLnJ1bGUgPSBydWxlICYmIHJ1bGUgIT09IFwib3B0aW9uYWxcIiA/IHJ1bGUgOiB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogRmllbGQgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogVW5pcXVlIGZpZWxkIGlkLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGlkOyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kZWQgdHlwZSBpZiBkaWZmZXJlbnQgZnJvbSBwYXJlbnQuXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5leHRlbmQgPSBleHRlbmQgfHwgdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCBpcyByZXF1aXJlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVpcmVkID0gcnVsZSA9PT0gXCJyZXF1aXJlZFwiO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGZpZWxkIGlzIG9wdGlvbmFsLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9uYWwgPSAhdGhpcy5yZXF1aXJlZDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCBpcyByZXBlYXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcGVhdGVkID0gcnVsZSA9PT0gXCJyZXBlYXRlZFwiO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGZpZWxkIGlzIGEgbWFwIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm1hcCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTWVzc2FnZSB0aGlzIGZpZWxkIGJlbG9uZ3MgdG8uXG4gICAgICogQHR5cGUge1R5cGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm1lc3NhZ2UgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogT25lT2YgdGhpcyBmaWVsZCBiZWxvbmdzIHRvLCBpZiBhbnksXG4gICAgICogQHR5cGUge09uZU9mfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYXJ0T2YgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpZWxkIHR5cGUncyBkZWZhdWx0IHZhbHVlLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHRoaXMudHlwZURlZmF1bHQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpZWxkJ3MgZGVmYXVsdCB2YWx1ZSBvbiBwcm90b3R5cGVzLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCdzIHZhbHVlIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgbG9uZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvbmcgPSB1dGlsLkxvbmcgPyB0eXBlcy5sb25nW3R5cGVdICE9PSB1bmRlZmluZWQgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCdzIHZhbHVlIGlzIGEgYnVmZmVyLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYnl0ZXMgPSB0eXBlID09PSBcImJ5dGVzXCI7XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCB0eXBlIGlmIG5vdCBhIGJhc2ljIHR5cGUuXG4gICAgICogQHR5cGUge1R5cGV8RW51bXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x2ZWRUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNpc3Rlci1maWVsZCB3aXRoaW4gdGhlIGV4dGVuZGVkIHR5cGUgaWYgYSBkZWNsYXJpbmcgZXh0ZW5zaW9uIGZpZWxkLlxuICAgICAqIEB0eXBlIHtGaWVsZHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW5zaW9uRmllbGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2lzdGVyLWZpZWxkIHdpdGhpbiB0aGUgZGVjbGFyaW5nIG5hbWVzcGFjZSBpZiBhbiBleHRlbmRlZCBmaWVsZC5cbiAgICAgKiBAdHlwZSB7RmllbGR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmRlY2xhcmluZ0ZpZWxkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgcmVtZW1iZXJzIHdoZXRoZXIgdGhpcyBmaWVsZCBpcyBwYWNrZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW58bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3BhY2tlZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDb21tZW50IGZvciB0aGlzIGZpZWxkLlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbW1lbnQgPSBjb21tZW50O1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGlzIGZpZWxkIGlzIHBhY2tlZC4gT25seSByZWxldmFudCB3aGVuIHJlcGVhdGVkIGFuZCB3b3JraW5nIHdpdGggcHJvdG8yLlxuICogQG5hbWUgRmllbGQjcGFja2VkXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEByZWFkb25seVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRmllbGQucHJvdG90eXBlLCBcInBhY2tlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gZGVmYXVsdHMgdG8gcGFja2VkPXRydWUgaWYgbm90IGV4cGxpY2l0eSBzZXQgdG8gZmFsc2VcbiAgICAgICAgaWYgKHRoaXMuX3BhY2tlZCA9PT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3BhY2tlZCA9IHRoaXMuZ2V0T3B0aW9uKFwicGFja2VkXCIpICE9PSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhY2tlZDtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuRmllbGQucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIHNldE9wdGlvbihuYW1lLCB2YWx1ZSwgaWZOb3RTZXQpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJwYWNrZWRcIikgLy8gY2xlYXIgY2FjaGVkIGJlZm9yZSBzZXR0aW5nXG4gICAgICAgIHRoaXMuX3BhY2tlZCA9IG51bGw7XG4gICAgcmV0dXJuIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldE9wdGlvbi5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlLCBpZk5vdFNldCk7XG59O1xuXG4vKipcbiAqIEZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElGaWVsZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtydWxlPVwib3B0aW9uYWxcIl0gRmllbGQgcnVsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgRmllbGQgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlkIEZpZWxkIGlkXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRmllbGQgb3B0aW9uc1xuICovXG5cbi8qKlxuICogRXh0ZW5zaW9uIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElFeHRlbnNpb25GaWVsZFxuICogQGV4dGVuZHMgSUZpZWxkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXh0ZW5kIEV4dGVuZGVkIHR5cGVcbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgZmllbGQgdG8gYSBmaWVsZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SUZpZWxkfSBGaWVsZCBkZXNjcmlwdG9yXG4gKi9cbkZpZWxkLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwicnVsZVwiICAgICwgdGhpcy5ydWxlICE9PSBcIm9wdGlvbmFsXCIgJiYgdGhpcy5ydWxlIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJ0eXBlXCIgICAgLCB0aGlzLnR5cGUsXG4gICAgICAgIFwiaWRcIiAgICAgICwgdGhpcy5pZCxcbiAgICAgICAgXCJleHRlbmRcIiAgLCB0aGlzLmV4dGVuZCxcbiAgICAgICAgXCJvcHRpb25zXCIgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwiY29tbWVudFwiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHRoaXMgZmllbGQncyB0eXBlIHJlZmVyZW5jZXMuXG4gKiBAcmV0dXJucyB7RmllbGR9IGB0aGlzYFxuICogQHRocm93cyB7RXJyb3J9IElmIGFueSByZWZlcmVuY2UgY2Fubm90IGJlIHJlc29sdmVkXG4gKi9cbkZpZWxkLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcblxuICAgIGlmICh0aGlzLnJlc29sdmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICgodGhpcy50eXBlRGVmYXVsdCA9IHR5cGVzLmRlZmF1bHRzW3RoaXMudHlwZV0pID09PSB1bmRlZmluZWQpIHsgLy8gaWYgbm90IGEgYmFzaWMgdHlwZSwgcmVzb2x2ZSBpdFxuICAgICAgICB0aGlzLnJlc29sdmVkVHlwZSA9ICh0aGlzLmRlY2xhcmluZ0ZpZWxkID8gdGhpcy5kZWNsYXJpbmdGaWVsZC5wYXJlbnQgOiB0aGlzLnBhcmVudCkubG9va3VwVHlwZU9yRW51bSh0aGlzLnR5cGUpO1xuICAgICAgICBpZiAodGhpcy5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBUeXBlKVxuICAgICAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IG51bGw7XG4gICAgICAgIGVsc2UgLy8gaW5zdGFuY2VvZiBFbnVtXG4gICAgICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gdGhpcy5yZXNvbHZlZFR5cGUudmFsdWVzW09iamVjdC5rZXlzKHRoaXMucmVzb2x2ZWRUeXBlLnZhbHVlcylbMF1dOyAvLyBmaXJzdCBkZWZpbmVkXG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnByb3RvM19vcHRpb25hbCkge1xuICAgICAgICAvLyBwcm90bzMgc2NhbGFyIHZhbHVlIG1hcmtlZCBvcHRpb25hbDsgc2hvdWxkIGRlZmF1bHQgdG8gbnVsbFxuICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyB1c2UgZXhwbGljaXRseSBzZXQgZGVmYXVsdCB2YWx1ZSBpZiBwcmVzZW50XG4gICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbXCJkZWZhdWx0XCJdICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IHRoaXMub3B0aW9uc1tcImRlZmF1bHRcIl07XG4gICAgICAgIGlmICh0aGlzLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0gJiYgdHlwZW9mIHRoaXMudHlwZURlZmF1bHQgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gdGhpcy5yZXNvbHZlZFR5cGUudmFsdWVzW3RoaXMudHlwZURlZmF1bHRdO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB1bm5lY2Vzc2FyeSBvcHRpb25zXG4gICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhY2tlZCA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMucGFja2VkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yZXNvbHZlZFR5cGUgJiYgISh0aGlzLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9ucy5wYWNrZWQ7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5vcHRpb25zKS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCB0byBpbnRlcm5hbCBkYXRhIHR5cGUgaWYgbmVjZXNzc2FyeVxuICAgIGlmICh0aGlzLmxvbmcpIHtcbiAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IHV0aWwuTG9uZy5mcm9tTnVtYmVyKHRoaXMudHlwZURlZmF1bHQsIHRoaXMudHlwZS5jaGFyQXQoMCkgPT09IFwidVwiKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSlcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGhpcy50eXBlRGVmYXVsdCk7IC8vIGxvbmcgaW5zdGFuY2VzIGFyZSBtZWFudCB0byBiZSBpbW11dGFibGUgYW55d2F5IChpLmUuIHVzZSBzbWFsbCBpbnQgY2FjaGUgdGhhdCBldmVuIHJlcXVpcmVzIGl0KVxuXG4gICAgfSBlbHNlIGlmICh0aGlzLmJ5dGVzICYmIHR5cGVvZiB0aGlzLnR5cGVEZWZhdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBidWY7XG4gICAgICAgIGlmICh1dGlsLmJhc2U2NC50ZXN0KHRoaXMudHlwZURlZmF1bHQpKVxuICAgICAgICAgICAgdXRpbC5iYXNlNjQuZGVjb2RlKHRoaXMudHlwZURlZmF1bHQsIGJ1ZiA9IHV0aWwubmV3QnVmZmVyKHV0aWwuYmFzZTY0Lmxlbmd0aCh0aGlzLnR5cGVEZWZhdWx0KSksIDApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB1dGlsLnV0Zjgud3JpdGUodGhpcy50eXBlRGVmYXVsdCwgYnVmID0gdXRpbC5uZXdCdWZmZXIodXRpbC51dGY4Lmxlbmd0aCh0aGlzLnR5cGVEZWZhdWx0KSksIDApO1xuICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gYnVmO1xuICAgIH1cblxuICAgIC8vIHRha2Ugc3BlY2lhbCBjYXJlIG9mIG1hcHMgYW5kIHJlcGVhdGVkIGZpZWxkc1xuICAgIGlmICh0aGlzLm1hcClcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB1dGlsLmVtcHR5T2JqZWN0O1xuICAgIGVsc2UgaWYgKHRoaXMucmVwZWF0ZWQpXG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdXRpbC5lbXB0eUFycmF5O1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB0aGlzLnR5cGVEZWZhdWx0O1xuXG4gICAgLy8gZW5zdXJlIHByb3BlciB2YWx1ZSBvbiBwcm90b3R5cGVcbiAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBUeXBlKVxuICAgICAgICB0aGlzLnBhcmVudC5jdG9yLnByb3RvdHlwZVt0aGlzLm5hbWVdID0gdGhpcy5kZWZhdWx0VmFsdWU7XG5cbiAgICByZXR1cm4gUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUucmVzb2x2ZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gYXMgcmV0dXJuZWQgYnkge0BsaW5rIEZpZWxkLmR9IGFuZCB7QGxpbmsgTWFwRmllbGQuZH0gKFR5cGVTY3JpcHQpLlxuICogQHR5cGVkZWYgRmllbGREZWNvcmF0b3JcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGFyZ2V0IHByb3RvdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZSBGaWVsZCBuYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogRmllbGQgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cbiAqIEBuYW1lIEZpZWxkLmRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSWQgRmllbGQgaWRcbiAqIEBwYXJhbSB7XCJkb3VibGVcInxcImZsb2F0XCJ8XCJpbnQzMlwifFwidWludDMyXCJ8XCJzaW50MzJcInxcImZpeGVkMzJcInxcInNmaXhlZDMyXCJ8XCJpbnQ2NFwifFwidWludDY0XCJ8XCJzaW50NjRcInxcImZpeGVkNjRcInxcInNmaXhlZDY0XCJ8XCJzdHJpbmdcInxcImJvb2xcInxcImJ5dGVzXCJ8T2JqZWN0fSBmaWVsZFR5cGUgRmllbGQgdHlwZVxuICogQHBhcmFtIHtcIm9wdGlvbmFsXCJ8XCJyZXF1aXJlZFwifFwicmVwZWF0ZWRcIn0gW2ZpZWxkUnVsZT1cIm9wdGlvbmFsXCJdIEZpZWxkIHJ1bGVcbiAqIEBwYXJhbSB7VH0gW2RlZmF1bHRWYWx1ZV0gRGVmYXVsdCB2YWx1ZVxuICogQHJldHVybnMge0ZpZWxkRGVjb3JhdG9yfSBEZWNvcmF0b3IgZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgbnVtYmVyIHwgbnVtYmVyW10gfCBMb25nIHwgTG9uZ1tdIHwgc3RyaW5nIHwgc3RyaW5nW10gfCBib29sZWFuIHwgYm9vbGVhbltdIHwgVWludDhBcnJheSB8IFVpbnQ4QXJyYXlbXSB8IEJ1ZmZlciB8IEJ1ZmZlcltdXG4gKi9cbkZpZWxkLmQgPSBmdW5jdGlvbiBkZWNvcmF0ZUZpZWxkKGZpZWxkSWQsIGZpZWxkVHlwZSwgZmllbGRSdWxlLCBkZWZhdWx0VmFsdWUpIHtcblxuICAgIC8vIHN1Ym1lc3NhZ2U6IGRlY29yYXRlIHRoZSBzdWJtZXNzYWdlIGFuZCB1c2UgaXRzIG5hbWUgYXMgdGhlIHR5cGVcbiAgICBpZiAodHlwZW9mIGZpZWxkVHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmaWVsZFR5cGUgPSB1dGlsLmRlY29yYXRlVHlwZShmaWVsZFR5cGUpLm5hbWU7XG5cbiAgICAvLyBlbnVtIHJlZmVyZW5jZTogY3JlYXRlIGEgcmVmbGVjdGVkIGNvcHkgb2YgdGhlIGVudW0gYW5kIGtlZXAgcmV1c2VpbmcgaXRcbiAgICBlbHNlIGlmIChmaWVsZFR5cGUgJiYgdHlwZW9mIGZpZWxkVHlwZSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgZmllbGRUeXBlID0gdXRpbC5kZWNvcmF0ZUVudW0oZmllbGRUeXBlKS5uYW1lO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZpZWxkRGVjb3JhdG9yKHByb3RvdHlwZSwgZmllbGROYW1lKSB7XG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHByb3RvdHlwZS5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgIC5hZGQobmV3IEZpZWxkKGZpZWxkTmFtZSwgZmllbGRJZCwgZmllbGRUeXBlLCBmaWVsZFJ1bGUsIHsgXCJkZWZhdWx0XCI6IGRlZmF1bHRWYWx1ZSB9KSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogRmllbGQgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cbiAqIEBuYW1lIEZpZWxkLmRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSWQgRmllbGQgaWRcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VD58c3RyaW5nfSBmaWVsZFR5cGUgRmllbGQgdHlwZVxuICogQHBhcmFtIHtcIm9wdGlvbmFsXCJ8XCJyZXF1aXJlZFwifFwicmVwZWF0ZWRcIn0gW2ZpZWxkUnVsZT1cIm9wdGlvbmFsXCJdIEZpZWxkIHJ1bGVcbiAqIEByZXR1cm5zIHtGaWVsZERlY29yYXRvcn0gRGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB2YXJpYXRpb24gMlxuICovXG4vLyBsaWtlIEZpZWxkLmQgYnV0IHdpdGhvdXQgYSBkZWZhdWx0IHZhbHVlXG5cbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxuRmllbGQuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uIGNvbmZpZ3VyZShUeXBlXykge1xuICAgIFR5cGUgPSBUeXBlXztcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkZpZWxkIiwiUmVmbGVjdGlvbk9iamVjdCIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImNsYXNzTmFtZSIsIkVudW0iLCJ0eXBlcyIsInV0aWwiLCJUeXBlIiwicnVsZVJlIiwiZnJvbUpTT04iLCJuYW1lIiwianNvbiIsImlkIiwidHlwZSIsInJ1bGUiLCJleHRlbmQiLCJvcHRpb25zIiwiY29tbWVudCIsImlzT2JqZWN0IiwidW5kZWZpbmVkIiwiY2FsbCIsImlzSW50ZWdlciIsIlR5cGVFcnJvciIsImlzU3RyaW5nIiwidGVzdCIsInRvU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJyZXF1aXJlZCIsIm9wdGlvbmFsIiwicmVwZWF0ZWQiLCJtYXAiLCJtZXNzYWdlIiwicGFydE9mIiwidHlwZURlZmF1bHQiLCJkZWZhdWx0VmFsdWUiLCJsb25nIiwiTG9uZyIsImJ5dGVzIiwicmVzb2x2ZWRUeXBlIiwiZXh0ZW5zaW9uRmllbGQiLCJkZWNsYXJpbmdGaWVsZCIsIl9wYWNrZWQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImdldE9wdGlvbiIsInNldE9wdGlvbiIsInZhbHVlIiwiaWZOb3RTZXQiLCJ0b0pTT04iLCJ0b0pTT05PcHRpb25zIiwia2VlcENvbW1lbnRzIiwiQm9vbGVhbiIsInRvT2JqZWN0IiwicmVzb2x2ZSIsInJlc29sdmVkIiwiZGVmYXVsdHMiLCJwYXJlbnQiLCJsb29rdXBUeXBlT3JFbnVtIiwidmFsdWVzIiwia2V5cyIsInByb3RvM19vcHRpb25hbCIsInBhY2tlZCIsImxlbmd0aCIsImZyb21OdW1iZXIiLCJjaGFyQXQiLCJmcmVlemUiLCJidWYiLCJiYXNlNjQiLCJkZWNvZGUiLCJuZXdCdWZmZXIiLCJ1dGY4Iiwid3JpdGUiLCJlbXB0eU9iamVjdCIsImVtcHR5QXJyYXkiLCJjdG9yIiwiZCIsImRlY29yYXRlRmllbGQiLCJmaWVsZElkIiwiZmllbGRUeXBlIiwiZmllbGRSdWxlIiwiZGVjb3JhdGVUeXBlIiwiZGVjb3JhdGVFbnVtIiwiZmllbGREZWNvcmF0b3IiLCJmaWVsZE5hbWUiLCJhZGQiLCJfY29uZmlndXJlIiwiY29uZmlndXJlIiwiVHlwZV8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/field.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/index-light.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/index-light.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar protobuf = module.exports = __webpack_require__(/*! ./index-minimal */ \"(ssr)/./node_modules/protobufjs/src/index-minimal.js\");\nprotobuf.build = \"light\";\n/**\n * A node-style callback as used by {@link load} and {@link Root#load}.\n * @typedef LoadCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Root} [root] Root, if there hasn't been an error\n * @returns {undefined}\n */ /**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} root Root namespace, defaults to create a new one if omitted.\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n */ function load(filename, root, callback) {\n    if (typeof root === \"function\") {\n        callback = root;\n        root = new protobuf.Root();\n    } else if (!root) root = new protobuf.Root();\n    return root.load(filename, callback);\n}\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n * @variation 2\n */ // function load(filename:string, callback:LoadCallback):undefined\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Promise<Root>} Promise\n * @see {@link Root#load}\n * @variation 3\n */ // function load(filename:string, [root:Root]):Promise<Root>\nprotobuf.load = load;\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n * @see {@link Root#loadSync}\n */ function loadSync(filename, root) {\n    if (!root) root = new protobuf.Root();\n    return root.loadSync(filename);\n}\nprotobuf.loadSync = loadSync;\n// Serialization\nprotobuf.encoder = __webpack_require__(/*! ./encoder */ \"(ssr)/./node_modules/protobufjs/src/encoder.js\");\nprotobuf.decoder = __webpack_require__(/*! ./decoder */ \"(ssr)/./node_modules/protobufjs/src/decoder.js\");\nprotobuf.verifier = __webpack_require__(/*! ./verifier */ \"(ssr)/./node_modules/protobufjs/src/verifier.js\");\nprotobuf.converter = __webpack_require__(/*! ./converter */ \"(ssr)/./node_modules/protobufjs/src/converter.js\");\n// Reflection\nprotobuf.ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/protobufjs/src/object.js\");\nprotobuf.Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/protobufjs/src/namespace.js\");\nprotobuf.Root = __webpack_require__(/*! ./root */ \"(ssr)/./node_modules/protobufjs/src/root.js\");\nprotobuf.Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/protobufjs/src/enum.js\");\nprotobuf.Type = __webpack_require__(/*! ./type */ \"(ssr)/./node_modules/protobufjs/src/type.js\");\nprotobuf.Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/protobufjs/src/field.js\");\nprotobuf.OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/protobufjs/src/oneof.js\");\nprotobuf.MapField = __webpack_require__(/*! ./mapfield */ \"(ssr)/./node_modules/protobufjs/src/mapfield.js\");\nprotobuf.Service = __webpack_require__(/*! ./service */ \"(ssr)/./node_modules/protobufjs/src/service.js\");\nprotobuf.Method = __webpack_require__(/*! ./method */ \"(ssr)/./node_modules/protobufjs/src/method.js\");\n// Runtime\nprotobuf.Message = __webpack_require__(/*! ./message */ \"(ssr)/./node_modules/protobufjs/src/message.js\");\nprotobuf.wrappers = __webpack_require__(/*! ./wrappers */ \"(ssr)/./node_modules/protobufjs/src/wrappers.js\");\n// Utility\nprotobuf.types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/protobufjs/src/types.js\");\nprotobuf.util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\");\n// Set up possibly cyclic reflection dependencies\nprotobuf.ReflectionObject._configure(protobuf.Root);\nprotobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);\nprotobuf.Root._configure(protobuf.Type);\nprotobuf.Field._configure(protobuf.Type);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbGlnaHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxXQUFXQyxtSEFBMkM7QUFFMURELFNBQVNJLEtBQUssR0FBRztBQUVqQjs7Ozs7OztDQU9DLEdBRUQ7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNDLEtBQUtDLFFBQVEsRUFBRUMsSUFBSSxFQUFFQyxRQUFRO0lBQ2xDLElBQUksT0FBT0QsU0FBUyxZQUFZO1FBQzVCQyxXQUFXRDtRQUNYQSxPQUFPLElBQUlQLFNBQVNTLElBQUk7SUFDNUIsT0FBTyxJQUFJLENBQUNGLE1BQ1JBLE9BQU8sSUFBSVAsU0FBU1MsSUFBSTtJQUM1QixPQUFPRixLQUFLRixJQUFJLENBQUNDLFVBQVVFO0FBQy9CO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0Qsa0VBQWtFO0FBRWxFOzs7Ozs7Ozs7Q0FTQyxHQUNELDREQUE0RDtBQUU1RFIsU0FBU0ssSUFBSSxHQUFHQTtBQUVoQjs7Ozs7OztDQU9DLEdBQ0QsU0FBU0ssU0FBU0osUUFBUSxFQUFFQyxJQUFJO0lBQzVCLElBQUksQ0FBQ0EsTUFDREEsT0FBTyxJQUFJUCxTQUFTUyxJQUFJO0lBQzVCLE9BQU9GLEtBQUtHLFFBQVEsQ0FBQ0o7QUFDekI7QUFFQU4sU0FBU1UsUUFBUSxHQUFHQTtBQUVwQixnQkFBZ0I7QUFDaEJWLFNBQVNXLE9BQU8sR0FBWVIsbUJBQU9BLENBQUMsaUVBQVc7QUFDL0NILFNBQVNZLE9BQU8sR0FBWVQsbUJBQU9BLENBQUMsaUVBQVc7QUFDL0NILFNBQVNhLFFBQVEsR0FBV1YsbUJBQU9BLENBQUMsbUVBQVk7QUFDaERILFNBQVNjLFNBQVMsR0FBVVgsbUJBQU9BLENBQUMscUVBQWE7QUFFakQsYUFBYTtBQUNiSCxTQUFTZSxnQkFBZ0IsR0FBR1osbUJBQU9BLENBQUMsK0RBQVU7QUFDOUNILFNBQVNnQixTQUFTLEdBQVViLG1CQUFPQSxDQUFDLHFFQUFhO0FBQ2pESCxTQUFTUyxJQUFJLEdBQWVOLG1CQUFPQSxDQUFDLDJEQUFRO0FBQzVDSCxTQUFTaUIsSUFBSSxHQUFlZCxtQkFBT0EsQ0FBQywyREFBUTtBQUM1Q0gsU0FBU2tCLElBQUksR0FBZWYsbUJBQU9BLENBQUMsMkRBQVE7QUFDNUNILFNBQVNtQixLQUFLLEdBQWNoQixtQkFBT0EsQ0FBQyw2REFBUztBQUM3Q0gsU0FBU29CLEtBQUssR0FBY2pCLG1CQUFPQSxDQUFDLDZEQUFTO0FBQzdDSCxTQUFTcUIsUUFBUSxHQUFXbEIsbUJBQU9BLENBQUMsbUVBQVk7QUFDaERILFNBQVNzQixPQUFPLEdBQVluQixtQkFBT0EsQ0FBQyxpRUFBVztBQUMvQ0gsU0FBU3VCLE1BQU0sR0FBYXBCLG1CQUFPQSxDQUFDLCtEQUFVO0FBRTlDLFVBQVU7QUFDVkgsU0FBU3dCLE9BQU8sR0FBWXJCLG1CQUFPQSxDQUFDLGlFQUFXO0FBQy9DSCxTQUFTeUIsUUFBUSxHQUFXdEIsbUJBQU9BLENBQUMsbUVBQVk7QUFFaEQsVUFBVTtBQUNWSCxTQUFTMEIsS0FBSyxHQUFjdkIsbUJBQU9BLENBQUMsNkRBQVM7QUFDN0NILFNBQVMyQixJQUFJLEdBQWV4QixtQkFBT0EsQ0FBQywyREFBUTtBQUU1QyxpREFBaUQ7QUFDakRILFNBQVNlLGdCQUFnQixDQUFDYSxVQUFVLENBQUM1QixTQUFTUyxJQUFJO0FBQ2xEVCxTQUFTZ0IsU0FBUyxDQUFDWSxVQUFVLENBQUM1QixTQUFTa0IsSUFBSSxFQUFFbEIsU0FBU3NCLE9BQU8sRUFBRXRCLFNBQVNpQixJQUFJO0FBQzVFakIsU0FBU1MsSUFBSSxDQUFDbUIsVUFBVSxDQUFDNUIsU0FBU2tCLElBQUk7QUFDdENsQixTQUFTbUIsS0FBSyxDQUFDUyxVQUFVLENBQUM1QixTQUFTa0IsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXByb2plY3QvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbGlnaHQuanM/NWRhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm90b2J1ZiA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaW5kZXgtbWluaW1hbFwiKTtcblxucHJvdG9idWYuYnVpbGQgPSBcImxpZ2h0XCI7XG5cbi8qKlxuICogQSBub2RlLXN0eWxlIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIGxvYWR9IGFuZCB7QGxpbmsgUm9vdCNsb2FkfS5cbiAqIEB0eXBlZGVmIExvYWRDYWxsYmFja1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290LCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gYSBjb21tb24gcm9vdCBuYW1lc3BhY2UgYW5kIGNhbGxzIHRoZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtSb290fSByb290IFJvb3QgbmFtZXNwYWNlLCBkZWZhdWx0cyB0byBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXG4gKiBAcGFyYW0ge0xvYWRDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAc2VlIHtAbGluayBSb290I2xvYWR9XG4gKi9cbmZ1bmN0aW9uIGxvYWQoZmlsZW5hbWUsIHJvb3QsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiByb290ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSByb290O1xuICAgICAgICByb290ID0gbmV3IHByb3RvYnVmLlJvb3QoKTtcbiAgICB9IGVsc2UgaWYgKCFyb290KVxuICAgICAgICByb290ID0gbmV3IHByb3RvYnVmLlJvb3QoKTtcbiAgICByZXR1cm4gcm9vdC5sb2FkKGZpbGVuYW1lLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byBhIGNvbW1vbiByb290IG5hbWVzcGFjZSBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrLlxuICogQG5hbWUgbG9hZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7TG9hZENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZH1cbiAqIEB2YXJpYXRpb24gMlxuICovXG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgY2FsbGJhY2s6TG9hZENhbGxiYWNrKTp1bmRlZmluZWRcblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBuYW1lIGxvYWRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290IG5hbWVzcGFjZSwgZGVmYXVsdHMgdG8gY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxuICogQHJldHVybnMge1Byb21pc2U8Um9vdD59IFByb21pc2VcbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZH1cbiAqIEB2YXJpYXRpb24gM1xuICovXG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgW3Jvb3Q6Um9vdF0pOlByb21pc2U8Um9vdD5cblxucHJvdG9idWYubG9hZCA9IGxvYWQ7XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBsb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIChub2RlIG9ubHkpLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290IG5hbWVzcGFjZSwgZGVmYXVsdHMgdG8gY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxuICogQHJldHVybnMge1Jvb3R9IFJvb3QgbmFtZXNwYWNlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgc3luY2hyb25vdXMgZmV0Y2hpbmcgaXMgbm90IHN1cHBvcnRlZCAoaS5lLiBpbiBicm93c2Vycykgb3IgaWYgYSBmaWxlJ3Mgc3ludGF4IGlzIGludmFsaWRcbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZFN5bmN9XG4gKi9cbmZ1bmN0aW9uIGxvYWRTeW5jKGZpbGVuYW1lLCByb290KSB7XG4gICAgaWYgKCFyb290KVxuICAgICAgICByb290ID0gbmV3IHByb3RvYnVmLlJvb3QoKTtcbiAgICByZXR1cm4gcm9vdC5sb2FkU3luYyhmaWxlbmFtZSk7XG59XG5cbnByb3RvYnVmLmxvYWRTeW5jID0gbG9hZFN5bmM7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLmVuY29kZXIgICAgICAgICAgPSByZXF1aXJlKFwiLi9lbmNvZGVyXCIpO1xucHJvdG9idWYuZGVjb2RlciAgICAgICAgICA9IHJlcXVpcmUoXCIuL2RlY29kZXJcIik7XG5wcm90b2J1Zi52ZXJpZmllciAgICAgICAgID0gcmVxdWlyZShcIi4vdmVyaWZpZXJcIik7XG5wcm90b2J1Zi5jb252ZXJ0ZXIgICAgICAgID0gcmVxdWlyZShcIi4vY29udmVydGVyXCIpO1xuXG4vLyBSZWZsZWN0aW9uXG5wcm90b2J1Zi5SZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xucHJvdG9idWYuTmFtZXNwYWNlICAgICAgICA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbnByb3RvYnVmLlJvb3QgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9yb290XCIpO1xucHJvdG9idWYuRW51bSAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL2VudW1cIik7XG5wcm90b2J1Zi5UeXBlICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbnByb3RvYnVmLkZpZWxkICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKTtcbnByb3RvYnVmLk9uZU9mICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKTtcbnByb3RvYnVmLk1hcEZpZWxkICAgICAgICAgPSByZXF1aXJlKFwiLi9tYXBmaWVsZFwiKTtcbnByb3RvYnVmLlNlcnZpY2UgICAgICAgICAgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xucHJvdG9idWYuTWV0aG9kICAgICAgICAgICA9IHJlcXVpcmUoXCIuL21ldGhvZFwiKTtcblxuLy8gUnVudGltZVxucHJvdG9idWYuTWVzc2FnZSAgICAgICAgICA9IHJlcXVpcmUoXCIuL21lc3NhZ2VcIik7XG5wcm90b2J1Zi53cmFwcGVycyAgICAgICAgID0gcmVxdWlyZShcIi4vd3JhcHBlcnNcIik7XG5cbi8vIFV0aWxpdHlcbnByb3RvYnVmLnR5cGVzICAgICAgICAgICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnByb3RvYnVmLnV0aWwgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vLyBTZXQgdXAgcG9zc2libHkgY3ljbGljIHJlZmxlY3Rpb24gZGVwZW5kZW5jaWVzXG5wcm90b2J1Zi5SZWZsZWN0aW9uT2JqZWN0Ll9jb25maWd1cmUocHJvdG9idWYuUm9vdCk7XG5wcm90b2J1Zi5OYW1lc3BhY2UuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlLCBwcm90b2J1Zi5TZXJ2aWNlLCBwcm90b2J1Zi5FbnVtKTtcbnByb3RvYnVmLlJvb3QuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlKTtcbnByb3RvYnVmLkZpZWxkLl9jb25maWd1cmUocHJvdG9idWYuVHlwZSk7XG4iXSwibmFtZXMiOlsicHJvdG9idWYiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsImJ1aWxkIiwibG9hZCIsImZpbGVuYW1lIiwicm9vdCIsImNhbGxiYWNrIiwiUm9vdCIsImxvYWRTeW5jIiwiZW5jb2RlciIsImRlY29kZXIiLCJ2ZXJpZmllciIsImNvbnZlcnRlciIsIlJlZmxlY3Rpb25PYmplY3QiLCJOYW1lc3BhY2UiLCJFbnVtIiwiVHlwZSIsIkZpZWxkIiwiT25lT2YiLCJNYXBGaWVsZCIsIlNlcnZpY2UiLCJNZXRob2QiLCJNZXNzYWdlIiwid3JhcHBlcnMiLCJ0eXBlcyIsInV0aWwiLCJfY29uZmlndXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/index-light.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar protobuf = exports;\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */ protobuf.build = \"minimal\";\n// Serialization\nprotobuf.Writer = __webpack_require__(/*! ./writer */ \"(ssr)/./node_modules/protobufjs/src/writer.js\");\nprotobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ \"(ssr)/./node_modules/protobufjs/src/writer_buffer.js\");\nprotobuf.Reader = __webpack_require__(/*! ./reader */ \"(ssr)/./node_modules/protobufjs/src/reader.js\");\nprotobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ \"(ssr)/./node_modules/protobufjs/src/reader_buffer.js\");\n// Utility\nprotobuf.util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/protobufjs/src/util/minimal.js\");\nprotobuf.rpc = __webpack_require__(/*! ./rpc */ \"(ssr)/./node_modules/protobufjs/src/rpc.js\");\nprotobuf.roots = __webpack_require__(/*! ./roots */ \"(ssr)/./node_modules/protobufjs/src/roots.js\");\nprotobuf.configure = configure;\n/* istanbul ignore next */ /**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */ function configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n// Set up buffer utility according to the environment\nconfigure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFdBQVdDO0FBRWY7Ozs7O0NBS0MsR0FDREQsU0FBU0UsS0FBSyxHQUFHO0FBRWpCLGdCQUFnQjtBQUNoQkYsU0FBU0csTUFBTSxHQUFTQyxtQkFBT0EsQ0FBQywrREFBVTtBQUMxQ0osU0FBU0ssWUFBWSxHQUFHRCxtQkFBT0EsQ0FBQyw2RUFBaUI7QUFDakRKLFNBQVNNLE1BQU0sR0FBU0YsbUJBQU9BLENBQUMsK0RBQVU7QUFDMUNKLFNBQVNPLFlBQVksR0FBR0gsbUJBQU9BLENBQUMsNkVBQWlCO0FBRWpELFVBQVU7QUFDVkosU0FBU1EsSUFBSSxHQUFXSixtQkFBT0EsQ0FBQywyRUFBZ0I7QUFDaERKLFNBQVNTLEdBQUcsR0FBWUwsbUJBQU9BLENBQUMseURBQU87QUFDdkNKLFNBQVNVLEtBQUssR0FBVU4sbUJBQU9BLENBQUMsNkRBQVM7QUFDekNKLFNBQVNXLFNBQVMsR0FBTUE7QUFFeEIsd0JBQXdCLEdBQ3hCOzs7Q0FHQyxHQUNELFNBQVNBO0lBQ0xYLFNBQVNRLElBQUksQ0FBQ0ksVUFBVTtJQUN4QlosU0FBU0csTUFBTSxDQUFDUyxVQUFVLENBQUNaLFNBQVNLLFlBQVk7SUFDaERMLFNBQVNNLE1BQU0sQ0FBQ00sVUFBVSxDQUFDWixTQUFTTyxZQUFZO0FBQ3BEO0FBRUEscURBQXFEO0FBQ3JESSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXByb2plY3QvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcz85NDNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gZXhwb3J0cztcblxuLyoqXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cbiAqIEBuYW1lIGJ1aWxkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xufVxuXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxuY29uZmlndXJlKCk7XG4iXSwibmFtZXMiOlsicHJvdG9idWYiLCJleHBvcnRzIiwiYnVpbGQiLCJXcml0ZXIiLCJyZXF1aXJlIiwiQnVmZmVyV3JpdGVyIiwiUmVhZGVyIiwiQnVmZmVyUmVhZGVyIiwidXRpbCIsInJwYyIsInJvb3RzIiwiY29uZmlndXJlIiwiX2NvbmZpZ3VyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/index-minimal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/index.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar protobuf = module.exports = __webpack_require__(/*! ./index-light */ \"(ssr)/./node_modules/protobufjs/src/index-light.js\");\nprotobuf.build = \"full\";\n// Parser\nprotobuf.tokenize = __webpack_require__(/*! ./tokenize */ \"(ssr)/./node_modules/protobufjs/src/tokenize.js\");\nprotobuf.parse = __webpack_require__(/*! ./parse */ \"(ssr)/./node_modules/protobufjs/src/parse.js\");\nprotobuf.common = __webpack_require__(/*! ./common */ \"(ssr)/./node_modules/protobufjs/src/common.js\");\n// Configure parser\nprotobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxXQUFXQywrR0FBeUM7QUFFeERELFNBQVNJLEtBQUssR0FBRztBQUVqQixTQUFTO0FBQ1RKLFNBQVNLLFFBQVEsR0FBV0YsbUJBQU9BLENBQUMsbUVBQVk7QUFDaERILFNBQVNNLEtBQUssR0FBY0gsbUJBQU9BLENBQUMsNkRBQVM7QUFDN0NILFNBQVNPLE1BQU0sR0FBYUosbUJBQU9BLENBQUMsK0RBQVU7QUFFOUMsbUJBQW1CO0FBQ25CSCxTQUFTUSxJQUFJLENBQUNDLFVBQVUsQ0FBQ1QsU0FBU1UsSUFBSSxFQUFFVixTQUFTTSxLQUFLLEVBQUVOLFNBQVNPLE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LmpzPzVhNGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcHJvdG9idWYgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2luZGV4LWxpZ2h0XCIpO1xuXG5wcm90b2J1Zi5idWlsZCA9IFwiZnVsbFwiO1xuXG4vLyBQYXJzZXJcbnByb3RvYnVmLnRva2VuaXplICAgICAgICAgPSByZXF1aXJlKFwiLi90b2tlbml6ZVwiKTtcbnByb3RvYnVmLnBhcnNlICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9wYXJzZVwiKTtcbnByb3RvYnVmLmNvbW1vbiAgICAgICAgICAgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG5cbi8vIENvbmZpZ3VyZSBwYXJzZXJcbnByb3RvYnVmLlJvb3QuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlLCBwcm90b2J1Zi5wYXJzZSwgcHJvdG9idWYuY29tbW9uKTtcbiJdLCJuYW1lcyI6WyJwcm90b2J1ZiIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiYnVpbGQiLCJ0b2tlbml6ZSIsInBhcnNlIiwiY29tbW9uIiwiUm9vdCIsIl9jb25maWd1cmUiLCJUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/mapfield.js":
/*!*************************************************!*\
  !*** ./node_modules/protobufjs/src/mapfield.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = MapField;\n// extends Field\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/protobufjs/src/field.js\");\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\nvar types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new map field instance.\n * @classdesc Reflected map field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} keyType Key type\n * @param {string} type Value type\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */ function MapField(name, id, keyType, type, options, comment) {\n    Field.call(this, name, id, type, undefined, undefined, options, comment);\n    /* istanbul ignore if */ if (!util.isString(keyType)) throw TypeError(\"keyType must be a string\");\n    /**\n     * Key type.\n     * @type {string}\n     */ this.keyType = keyType; // toJSON, marker\n    /**\n     * Resolved key type if not a basic type.\n     * @type {ReflectionObject|null}\n     */ this.resolvedKeyType = null;\n    // Overrides Field#map\n    this.map = true;\n}\n/**\n * Map field descriptor.\n * @interface IMapField\n * @extends {IField}\n * @property {string} keyType Key type\n */ /**\n * Extension map field descriptor.\n * @interface IExtensionMapField\n * @extends IMapField\n * @property {string} extend Extended type\n */ /**\n * Constructs a map field from a map field descriptor.\n * @param {string} name Field name\n * @param {IMapField} json Map field descriptor\n * @returns {MapField} Created map field\n * @throws {TypeError} If arguments are invalid\n */ MapField.fromJSON = function fromJSON(name, json) {\n    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\n};\n/**\n * Converts this map field to a map field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMapField} Map field descriptor\n */ MapField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"keyType\",\n        this.keyType,\n        \"type\",\n        this.type,\n        \"id\",\n        this.id,\n        \"extend\",\n        this.extend,\n        \"options\",\n        this.options,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * @override\n */ MapField.prototype.resolve = function resolve() {\n    if (this.resolved) return this;\n    // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\n    if (types.mapKey[this.keyType] === undefined) throw Error(\"invalid key type: \" + this.keyType);\n    return Field.prototype.resolve.call(this);\n};\n/**\n * Map field decorator (TypeScript).\n * @name MapField.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\n * @returns {FieldDecorator} Decorator function\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\n */ MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\n    // submessage value: decorate the submessage and use its name as the type\n    if (typeof fieldValueType === \"function\") fieldValueType = util.decorateType(fieldValueType).name;\n    else if (fieldValueType && typeof fieldValueType === \"object\") fieldValueType = util.decorateEnum(fieldValueType).name;\n    return function mapFieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbWFwZmllbGQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixnQkFBZ0I7QUFDaEIsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsNkRBQVM7QUFDNUIsRUFBQ0YsU0FBU0csU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLE1BQU1FLFNBQVMsR0FBR0csV0FBVyxHQUFHTixRQUFPLEVBQUdPLFNBQVMsR0FBRztBQUUzRixJQUFJQyxRQUFVTixtQkFBT0EsQ0FBQyw2REFBUyxHQUMzQk8sT0FBVVAsbUJBQU9BLENBQUMsMkRBQVE7QUFFOUI7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxTQUFTRixTQUFTVSxJQUFJLEVBQUVDLEVBQUUsRUFBRUMsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsT0FBTztJQUN2RGQsTUFBTWUsSUFBSSxDQUFDLElBQUksRUFBRU4sTUFBTUMsSUFBSUUsTUFBTUksV0FBV0EsV0FBV0gsU0FBU0M7SUFFaEUsc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ04sS0FBS1MsUUFBUSxDQUFDTixVQUNmLE1BQU1PLFVBQVU7SUFFcEI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDUCxPQUFPLEdBQUdBLFNBQVMsaUJBQWlCO0lBRXpDOzs7S0FHQyxHQUNELElBQUksQ0FBQ1EsZUFBZSxHQUFHO0lBRXZCLHNCQUFzQjtJQUN0QixJQUFJLENBQUNDLEdBQUcsR0FBRztBQUNmO0FBRUE7Ozs7O0NBS0MsR0FFRDs7Ozs7Q0FLQyxHQUVEOzs7Ozs7Q0FNQyxHQUNEckIsU0FBU3NCLFFBQVEsR0FBRyxTQUFTQSxTQUFTWixJQUFJLEVBQUVhLElBQUk7SUFDNUMsT0FBTyxJQUFJdkIsU0FBU1UsTUFBTWEsS0FBS1osRUFBRSxFQUFFWSxLQUFLWCxPQUFPLEVBQUVXLEtBQUtWLElBQUksRUFBRVUsS0FBS1QsT0FBTyxFQUFFUyxLQUFLUixPQUFPO0FBQzFGO0FBRUE7Ozs7Q0FJQyxHQUNEZixTQUFTRyxTQUFTLENBQUNxQixNQUFNLEdBQUcsU0FBU0EsT0FBT0MsYUFBYTtJQUNyRCxJQUFJQyxlQUFlRCxnQkFBZ0JFLFFBQVFGLGNBQWNDLFlBQVksSUFBSTtJQUN6RSxPQUFPakIsS0FBS21CLFFBQVEsQ0FBQztRQUNqQjtRQUFZLElBQUksQ0FBQ2hCLE9BQU87UUFDeEI7UUFBWSxJQUFJLENBQUNDLElBQUk7UUFDckI7UUFBWSxJQUFJLENBQUNGLEVBQUU7UUFDbkI7UUFBWSxJQUFJLENBQUNrQixNQUFNO1FBQ3ZCO1FBQVksSUFBSSxDQUFDZixPQUFPO1FBQ3hCO1FBQVlZLGVBQWUsSUFBSSxDQUFDWCxPQUFPLEdBQUdFO0tBQzdDO0FBQ0w7QUFFQTs7Q0FFQyxHQUNEakIsU0FBU0csU0FBUyxDQUFDMkIsT0FBTyxHQUFHLFNBQVNBO0lBQ2xDLElBQUksSUFBSSxDQUFDQyxRQUFRLEVBQ2IsT0FBTyxJQUFJO0lBRWYsMkhBQTJIO0lBQzNILElBQUl2QixNQUFNd0IsTUFBTSxDQUFDLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQyxLQUFLSyxXQUMvQixNQUFNZ0IsTUFBTSx1QkFBdUIsSUFBSSxDQUFDckIsT0FBTztJQUVuRCxPQUFPWCxNQUFNRSxTQUFTLENBQUMyQixPQUFPLENBQUNkLElBQUksQ0FBQyxJQUFJO0FBQzVDO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0RoQixTQUFTa0MsQ0FBQyxHQUFHLFNBQVNDLGlCQUFpQkMsT0FBTyxFQUFFQyxZQUFZLEVBQUVDLGNBQWM7SUFFeEUseUVBQXlFO0lBQ3pFLElBQUksT0FBT0EsbUJBQW1CLFlBQzFCQSxpQkFBaUI3QixLQUFLOEIsWUFBWSxDQUFDRCxnQkFBZ0I1QixJQUFJO1NBR3RELElBQUk0QixrQkFBa0IsT0FBT0EsbUJBQW1CLFVBQ2pEQSxpQkFBaUI3QixLQUFLK0IsWUFBWSxDQUFDRixnQkFBZ0I1QixJQUFJO0lBRTNELE9BQU8sU0FBUytCLGtCQUFrQnRDLFNBQVMsRUFBRXVDLFNBQVM7UUFDbERqQyxLQUFLOEIsWUFBWSxDQUFDcEMsVUFBVUcsV0FBVyxFQUNsQ3FDLEdBQUcsQ0FBQyxJQUFJM0MsU0FBUzBDLFdBQVdOLFNBQVNDLGNBQWNDO0lBQzVEO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21hcGZpZWxkLmpzPzJiOTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE1hcEZpZWxkO1xuXG4vLyBleHRlbmRzIEZpZWxkXG52YXIgRmllbGQgPSByZXF1aXJlKFwiLi9maWVsZFwiKTtcbigoTWFwRmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWVsZC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IE1hcEZpZWxkKS5jbGFzc05hbWUgPSBcIk1hcEZpZWxkXCI7XG5cbnZhciB0eXBlcyAgID0gcmVxdWlyZShcIi4vdHlwZXNcIiksXG4gICAgdXRpbCAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBtYXAgZmllbGQgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBtYXAgZmllbGQuXG4gKiBAZXh0ZW5kcyBGaWVsZEJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVW5pcXVlIG5hbWUgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgaWQgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlUeXBlIEtleSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBWYWx1ZSB0eXBlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBDb21tZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIE1hcEZpZWxkKG5hbWUsIGlkLCBrZXlUeXBlLCB0eXBlLCBvcHRpb25zLCBjb21tZW50KSB7XG4gICAgRmllbGQuY2FsbCh0aGlzLCBuYW1lLCBpZCwgdHlwZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnMsIGNvbW1lbnQpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKGtleVR5cGUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJrZXlUeXBlIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICAvKipcbiAgICAgKiBLZXkgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMua2V5VHlwZSA9IGtleVR5cGU7IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCBrZXkgdHlwZSBpZiBub3QgYSBiYXNpYyB0eXBlLlxuICAgICAqIEB0eXBlIHtSZWZsZWN0aW9uT2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlZEtleVR5cGUgPSBudWxsO1xuXG4gICAgLy8gT3ZlcnJpZGVzIEZpZWxkI21hcFxuICAgIHRoaXMubWFwID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBNYXAgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSU1hcEZpZWxkXG4gKiBAZXh0ZW5kcyB7SUZpZWxkfVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleVR5cGUgS2V5IHR5cGVcbiAqL1xuXG4vKipcbiAqIEV4dGVuc2lvbiBtYXAgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSUV4dGVuc2lvbk1hcEZpZWxkXG4gKiBAZXh0ZW5kcyBJTWFwRmllbGRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBleHRlbmQgRXh0ZW5kZWQgdHlwZVxuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG1hcCBmaWVsZCBmcm9tIGEgbWFwIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gKiBAcGFyYW0ge0lNYXBGaWVsZH0ganNvbiBNYXAgZmllbGQgZGVzY3JpcHRvclxuICogQHJldHVybnMge01hcEZpZWxkfSBDcmVhdGVkIG1hcCBmaWVsZFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuTWFwRmllbGQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBNYXBGaWVsZChuYW1lLCBqc29uLmlkLCBqc29uLmtleVR5cGUsIGpzb24udHlwZSwganNvbi5vcHRpb25zLCBqc29uLmNvbW1lbnQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG1hcCBmaWVsZCB0byBhIG1hcCBmaWVsZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU1hcEZpZWxkfSBNYXAgZmllbGQgZGVzY3JpcHRvclxuICovXG5NYXBGaWVsZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcImtleVR5cGVcIiAsIHRoaXMua2V5VHlwZSxcbiAgICAgICAgXCJ0eXBlXCIgICAgLCB0aGlzLnR5cGUsXG4gICAgICAgIFwiaWRcIiAgICAgICwgdGhpcy5pZCxcbiAgICAgICAgXCJleHRlbmRcIiAgLCB0aGlzLmV4dGVuZCxcbiAgICAgICAgXCJvcHRpb25zXCIgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwiY29tbWVudFwiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5NYXBGaWVsZC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgaWYgKHRoaXMucmVzb2x2ZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgLy8gQmVzaWRlcyBhIHZhbHVlIHR5cGUsIG1hcCBmaWVsZHMgaGF2ZSBhIGtleSB0eXBlIHRoYXQgbWF5IGJlIFwiYW55IHNjYWxhciB0eXBlIGV4Y2VwdCBmb3IgZmxvYXRpbmcgcG9pbnQgdHlwZXMgYW5kIGJ5dGVzXCJcbiAgICBpZiAodHlwZXMubWFwS2V5W3RoaXMua2V5VHlwZV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGtleSB0eXBlOiBcIiArIHRoaXMua2V5VHlwZSk7XG5cbiAgICByZXR1cm4gRmllbGQucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogTWFwIGZpZWxkIGRlY29yYXRvciAoVHlwZVNjcmlwdCkuXG4gKiBAbmFtZSBNYXBGaWVsZC5kXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZElkIEZpZWxkIGlkXG4gKiBAcGFyYW0ge1wiaW50MzJcInxcInVpbnQzMlwifFwic2ludDMyXCJ8XCJmaXhlZDMyXCJ8XCJzZml4ZWQzMlwifFwiaW50NjRcInxcInVpbnQ2NFwifFwic2ludDY0XCJ8XCJmaXhlZDY0XCJ8XCJzZml4ZWQ2NFwifFwiYm9vbFwifFwic3RyaW5nXCJ9IGZpZWxkS2V5VHlwZSBGaWVsZCBrZXkgdHlwZVxuICogQHBhcmFtIHtcImRvdWJsZVwifFwiZmxvYXRcInxcImludDMyXCJ8XCJ1aW50MzJcInxcInNpbnQzMlwifFwiZml4ZWQzMlwifFwic2ZpeGVkMzJcInxcImludDY0XCJ8XCJ1aW50NjRcInxcInNpbnQ2NFwifFwiZml4ZWQ2NFwifFwic2ZpeGVkNjRcInxcImJvb2xcInxcInN0cmluZ1wifFwiYnl0ZXNcInxPYmplY3R8Q29uc3RydWN0b3I8e30+fSBmaWVsZFZhbHVlVHlwZSBGaWVsZCB2YWx1ZSB0eXBlXG4gKiBAcmV0dXJucyB7RmllbGREZWNvcmF0b3J9IERlY29yYXRvciBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IG51bWJlciB8IExvbmcgfCBzdHJpbmcgfCBib29sZWFuIHwgVWludDhBcnJheSB8IEJ1ZmZlciB8IG51bWJlcltdIHwgTWVzc2FnZTx7fT4gfVxuICovXG5NYXBGaWVsZC5kID0gZnVuY3Rpb24gZGVjb3JhdGVNYXBGaWVsZChmaWVsZElkLCBmaWVsZEtleVR5cGUsIGZpZWxkVmFsdWVUeXBlKSB7XG5cbiAgICAvLyBzdWJtZXNzYWdlIHZhbHVlOiBkZWNvcmF0ZSB0aGUgc3VibWVzc2FnZSBhbmQgdXNlIGl0cyBuYW1lIGFzIHRoZSB0eXBlXG4gICAgaWYgKHR5cGVvZiBmaWVsZFZhbHVlVHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmaWVsZFZhbHVlVHlwZSA9IHV0aWwuZGVjb3JhdGVUeXBlKGZpZWxkVmFsdWVUeXBlKS5uYW1lO1xuXG4gICAgLy8gZW51bSByZWZlcmVuY2UgdmFsdWU6IGNyZWF0ZSBhIHJlZmxlY3RlZCBjb3B5IG9mIHRoZSBlbnVtIGFuZCBrZWVwIHJldXNlaW5nIGl0XG4gICAgZWxzZSBpZiAoZmllbGRWYWx1ZVR5cGUgJiYgdHlwZW9mIGZpZWxkVmFsdWVUeXBlID09PSBcIm9iamVjdFwiKVxuICAgICAgICBmaWVsZFZhbHVlVHlwZSA9IHV0aWwuZGVjb3JhdGVFbnVtKGZpZWxkVmFsdWVUeXBlKS5uYW1lO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hcEZpZWxkRGVjb3JhdG9yKHByb3RvdHlwZSwgZmllbGROYW1lKSB7XG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHByb3RvdHlwZS5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgIC5hZGQobmV3IE1hcEZpZWxkKGZpZWxkTmFtZSwgZmllbGRJZCwgZmllbGRLZXlUeXBlLCBmaWVsZFZhbHVlVHlwZSkpO1xuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJNYXBGaWVsZCIsIkZpZWxkIiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiY2xhc3NOYW1lIiwidHlwZXMiLCJ1dGlsIiwibmFtZSIsImlkIiwia2V5VHlwZSIsInR5cGUiLCJvcHRpb25zIiwiY29tbWVudCIsImNhbGwiLCJ1bmRlZmluZWQiLCJpc1N0cmluZyIsIlR5cGVFcnJvciIsInJlc29sdmVkS2V5VHlwZSIsIm1hcCIsImZyb21KU09OIiwianNvbiIsInRvSlNPTiIsInRvSlNPTk9wdGlvbnMiLCJrZWVwQ29tbWVudHMiLCJCb29sZWFuIiwidG9PYmplY3QiLCJleHRlbmQiLCJyZXNvbHZlIiwicmVzb2x2ZWQiLCJtYXBLZXkiLCJFcnJvciIsImQiLCJkZWNvcmF0ZU1hcEZpZWxkIiwiZmllbGRJZCIsImZpZWxkS2V5VHlwZSIsImZpZWxkVmFsdWVUeXBlIiwiZGVjb3JhdGVUeXBlIiwiZGVjb3JhdGVFbnVtIiwibWFwRmllbGREZWNvcmF0b3IiLCJmaWVsZE5hbWUiLCJhZGQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/mapfield.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/message.js":
/*!************************************************!*\
  !*** ./node_modules/protobufjs/src/message.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Message;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs a new message instance.\n * @classdesc Abstract runtime message.\n * @constructor\n * @param {Properties<T>} [properties] Properties to set\n * @template T extends object = object\n */ function Message(properties) {\n    // not used internally\n    if (properties) for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)this[keys[i]] = properties[keys[i]];\n}\n/**\n * Reference to the reflected type.\n * @name Message.$type\n * @type {Type}\n * @readonly\n */ /**\n * Reference to the reflected type.\n * @name Message#$type\n * @type {Type}\n * @readonly\n */ /*eslint-disable valid-jsdoc*/ /**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<T>} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.create = function create(properties) {\n    return this.$type.create(properties);\n};\n/**\n * Encodes a message of this type.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.encode = function encode(message, writer) {\n    return this.$type.encode(message, writer);\n};\n/**\n * Encodes a message of this type preceeded by its length as a varint.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.$type.encodeDelimited(message, writer);\n};\n/**\n * Decodes a message of this type.\n * @name Message.decode\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.decode = function decode(reader) {\n    return this.$type.decode(reader);\n};\n/**\n * Decodes a message of this type preceeded by its length as a varint.\n * @name Message.decodeDelimited\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.decodeDelimited = function decodeDelimited(reader) {\n    return this.$type.decodeDelimited(reader);\n};\n/**\n * Verifies a message of this type.\n * @name Message.verify\n * @function\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {string|null} `null` if valid, otherwise the reason why it is not\n */ Message.verify = function verify(message) {\n    return this.$type.verify(message);\n};\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object\n * @returns {T} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.fromObject = function fromObject(object) {\n    return this.$type.fromObject(object);\n};\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {T} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.toObject = function toObject(message, options) {\n    return this.$type.toObject(message, options);\n};\n/**\n * Converts this message to JSON.\n * @returns {Object.<string,*>} JSON object\n */ Message.prototype.toJSON = function toJSON() {\n    return this.$type.toObject(this, util.toJSONOptions);\n}; /*eslint-enable valid-jsdoc*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLE9BQU9DLG1CQUFPQSxDQUFDLDJFQUFnQjtBQUVuQzs7Ozs7O0NBTUMsR0FDRCxTQUFTRixRQUFRRyxVQUFVO0lBQ3ZCLHNCQUFzQjtJQUN0QixJQUFJQSxZQUNBLElBQUssSUFBSUMsT0FBT0MsT0FBT0QsSUFBSSxDQUFDRCxhQUFhRyxJQUFJLEdBQUdBLElBQUlGLEtBQUtHLE1BQU0sRUFBRSxFQUFFRCxFQUMvRCxJQUFJLENBQUNGLElBQUksQ0FBQ0UsRUFBRSxDQUFDLEdBQUdILFVBQVUsQ0FBQ0MsSUFBSSxDQUFDRSxFQUFFLENBQUM7QUFDL0M7QUFFQTs7Ozs7Q0FLQyxHQUVEOzs7OztDQUtDLEdBRUQsNEJBQTRCLEdBRTVCOzs7Ozs7Q0FNQyxHQUNETixRQUFRUSxNQUFNLEdBQUcsU0FBU0EsT0FBT0wsVUFBVTtJQUN2QyxPQUFPLElBQUksQ0FBQ00sS0FBSyxDQUFDRCxNQUFNLENBQUNMO0FBQzdCO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNESCxRQUFRVSxNQUFNLEdBQUcsU0FBU0EsT0FBT0MsT0FBTyxFQUFFQyxNQUFNO0lBQzVDLE9BQU8sSUFBSSxDQUFDSCxLQUFLLENBQUNDLE1BQU0sQ0FBQ0MsU0FBU0M7QUFDdEM7QUFFQTs7Ozs7OztDQU9DLEdBQ0RaLFFBQVFhLGVBQWUsR0FBRyxTQUFTQSxnQkFBZ0JGLE9BQU8sRUFBRUMsTUFBTTtJQUM5RCxPQUFPLElBQUksQ0FBQ0gsS0FBSyxDQUFDSSxlQUFlLENBQUNGLFNBQVNDO0FBQy9DO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDRFosUUFBUWMsTUFBTSxHQUFHLFNBQVNBLE9BQU9DLE1BQU07SUFDbkMsT0FBTyxJQUFJLENBQUNOLEtBQUssQ0FBQ0ssTUFBTSxDQUFDQztBQUM3QjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0RmLFFBQVFnQixlQUFlLEdBQUcsU0FBU0EsZ0JBQWdCRCxNQUFNO0lBQ3JELE9BQU8sSUFBSSxDQUFDTixLQUFLLENBQUNPLGVBQWUsQ0FBQ0Q7QUFDdEM7QUFFQTs7Ozs7O0NBTUMsR0FDRGYsUUFBUWlCLE1BQU0sR0FBRyxTQUFTQSxPQUFPTixPQUFPO0lBQ3BDLE9BQU8sSUFBSSxDQUFDRixLQUFLLENBQUNRLE1BQU0sQ0FBQ047QUFDN0I7QUFFQTs7Ozs7O0NBTUMsR0FDRFgsUUFBUWtCLFVBQVUsR0FBRyxTQUFTQSxXQUFXQyxNQUFNO0lBQzNDLE9BQU8sSUFBSSxDQUFDVixLQUFLLENBQUNTLFVBQVUsQ0FBQ0M7QUFDakM7QUFFQTs7Ozs7OztDQU9DLEdBQ0RuQixRQUFRb0IsUUFBUSxHQUFHLFNBQVNBLFNBQVNULE9BQU8sRUFBRVUsT0FBTztJQUNqRCxPQUFPLElBQUksQ0FBQ1osS0FBSyxDQUFDVyxRQUFRLENBQUNULFNBQVNVO0FBQ3hDO0FBRUE7OztDQUdDLEdBQ0RyQixRQUFRc0IsU0FBUyxDQUFDQyxNQUFNLEdBQUcsU0FBU0E7SUFDaEMsT0FBTyxJQUFJLENBQUNkLEtBQUssQ0FBQ1csUUFBUSxDQUFDLElBQUksRUFBRW5CLEtBQUt1QixhQUFhO0FBQ3ZELEdBRUEsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9tZXNzYWdlLmpzPzhmOGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2U7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgbWVzc2FnZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQWJzdHJhY3QgcnVudGltZSBtZXNzYWdlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1Byb3BlcnRpZXM8VD59IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBvYmplY3QgPSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gTWVzc2FnZShwcm9wZXJ0aWVzKSB7XG4gICAgLy8gbm90IHVzZWQgaW50ZXJuYWxseVxuICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xufVxuXG4vKipcbiAqIFJlZmVyZW5jZSB0byB0aGUgcmVmbGVjdGVkIHR5cGUuXG4gKiBAbmFtZSBNZXNzYWdlLiR0eXBlXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEByZWFkb25seVxuICovXG5cbi8qKlxuICogUmVmZXJlbmNlIHRvIHRoZSByZWZsZWN0ZWQgdHlwZS5cbiAqIEBuYW1lIE1lc3NhZ2UjJHR5cGVcbiAqIEB0eXBlIHtUeXBlfVxuICogQHJlYWRvbmx5XG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtZXNzYWdlIG9mIHRoaXMgdHlwZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAqIEByZXR1cm5zIHtNZXNzYWdlPFQ+fSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5jcmVhdGUocHJvcGVydGllcyk7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7VHxPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBNZXNzYWdlIHRvIGVuY29kZVxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byB1c2VcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IFdyaXRlclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtUfE9iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIE1lc3NhZ2UgdG8gZW5jb2RlXG4gKiBAcGFyYW0ge1dyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIHVzZVxuICogQHJldHVybnMge1dyaXRlcn0gV3JpdGVyXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLmVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuXG4gKiBAbmFtZSBNZXNzYWdlLmRlY29kZVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1JlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGVcbiAqIEByZXR1cm5zIHtUfSBEZWNvZGVkIG1lc3NhZ2VcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZGVjb2RlKHJlYWRlcik7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZSBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBuYW1lIE1lc3NhZ2UuZGVjb2RlRGVsaW1pdGVkXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZVxuICogQHJldHVybnMge1R9IERlY29kZWQgbWVzc2FnZVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5kZWNvZGVEZWxpbWl0ZWQocmVhZGVyKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS5cbiAqIEBuYW1lIE1lc3NhZ2UudmVyaWZ5XG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAqL1xuTWVzc2FnZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLnZlcmlmeShtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtZXNzYWdlIG9mIHRoaXMgdHlwZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICogQHJldHVybnMge1R9IE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5mcm9tT2JqZWN0KG9iamVjdCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge1R9IG1lc3NhZ2UgTWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtJQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUudG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbWVzc2FnZSB0byBKU09OLlxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICovXG5NZXNzYWdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUudG9PYmplY3QodGhpcywgdXRpbC50b0pTT05PcHRpb25zKTtcbn07XG5cbi8qZXNsaW50LWVuYWJsZSB2YWxpZC1qc2RvYyovIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJNZXNzYWdlIiwidXRpbCIsInJlcXVpcmUiLCJwcm9wZXJ0aWVzIiwia2V5cyIsIk9iamVjdCIsImkiLCJsZW5ndGgiLCJjcmVhdGUiLCIkdHlwZSIsImVuY29kZSIsIm1lc3NhZ2UiLCJ3cml0ZXIiLCJlbmNvZGVEZWxpbWl0ZWQiLCJkZWNvZGUiLCJyZWFkZXIiLCJkZWNvZGVEZWxpbWl0ZWQiLCJ2ZXJpZnkiLCJmcm9tT2JqZWN0Iiwib2JqZWN0IiwidG9PYmplY3QiLCJvcHRpb25zIiwicHJvdG90eXBlIiwidG9KU09OIiwidG9KU09OT3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/message.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/method.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/method.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Method;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/protobufjs/src/object.js\");\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new service method instance.\n * @classdesc Reflected service method.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Method name\n * @param {string|undefined} type Method type, usually `\"rpc\"`\n * @param {string} requestType Request message type\n * @param {string} responseType Response message type\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this method\n * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object\n */ function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {\n    /* istanbul ignore next */ if (util.isObject(requestStream)) {\n        options = requestStream;\n        requestStream = responseStream = undefined;\n    } else if (util.isObject(responseStream)) {\n        options = responseStream;\n        responseStream = undefined;\n    }\n    /* istanbul ignore if */ if (!(type === undefined || util.isString(type))) throw TypeError(\"type must be a string\");\n    /* istanbul ignore if */ if (!util.isString(requestType)) throw TypeError(\"requestType must be a string\");\n    /* istanbul ignore if */ if (!util.isString(responseType)) throw TypeError(\"responseType must be a string\");\n    ReflectionObject.call(this, name, options);\n    /**\n     * Method type.\n     * @type {string}\n     */ this.type = type || \"rpc\"; // toJSON\n    /**\n     * Request type.\n     * @type {string}\n     */ this.requestType = requestType; // toJSON, marker\n    /**\n     * Whether requests are streamed or not.\n     * @type {boolean|undefined}\n     */ this.requestStream = requestStream ? true : undefined; // toJSON\n    /**\n     * Response type.\n     * @type {string}\n     */ this.responseType = responseType; // toJSON\n    /**\n     * Whether responses are streamed or not.\n     * @type {boolean|undefined}\n     */ this.responseStream = responseStream ? true : undefined; // toJSON\n    /**\n     * Resolved request type.\n     * @type {Type|null}\n     */ this.resolvedRequestType = null;\n    /**\n     * Resolved response type.\n     * @type {Type|null}\n     */ this.resolvedResponseType = null;\n    /**\n     * Comment for this method\n     * @type {string|null}\n     */ this.comment = comment;\n    /**\n     * Options properly parsed into an object\n     */ this.parsedOptions = parsedOptions;\n}\n/**\n * Method descriptor.\n * @interface IMethod\n * @property {string} [type=\"rpc\"] Method type\n * @property {string} requestType Request type\n * @property {string} responseType Response type\n * @property {boolean} [requestStream=false] Whether requests are streamed\n * @property {boolean} [responseStream=false] Whether responses are streamed\n * @property {Object.<string,*>} [options] Method options\n * @property {string} comment Method comments\n * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object\n */ /**\n * Constructs a method from a method descriptor.\n * @param {string} name Method name\n * @param {IMethod} json Method descriptor\n * @returns {Method} Created method\n * @throws {TypeError} If arguments are invalid\n */ Method.fromJSON = function fromJSON(name, json) {\n    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);\n};\n/**\n * Converts this method to a method descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMethod} Method descriptor\n */ Method.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"type\",\n        this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\n        \"requestType\",\n        this.requestType,\n        \"requestStream\",\n        this.requestStream,\n        \"responseType\",\n        this.responseType,\n        \"responseStream\",\n        this.responseStream,\n        \"options\",\n        this.options,\n        \"comment\",\n        keepComments ? this.comment : undefined,\n        \"parsedOptions\",\n        this.parsedOptions\n    ]);\n};\n/**\n * @override\n */ Method.prototype.resolve = function resolve() {\n    /* istanbul ignore if */ if (this.resolved) return this;\n    this.resolvedRequestType = this.parent.lookupType(this.requestType);\n    this.resolvedResponseType = this.parent.lookupType(this.responseType);\n    return ReflectionObject.prototype.resolve.call(this);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbWV0aG9kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsMkJBQTJCO0FBQzNCLElBQUlDLG1CQUFtQkMsbUJBQU9BLENBQUMsK0RBQVU7QUFDeEMsRUFBQ0YsT0FBT0csU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLGlCQUFpQkUsU0FBUyxHQUFHRyxXQUFXLEdBQUdOLE1BQUssRUFBR08sU0FBUyxHQUFHO0FBRWxHLElBQUlDLE9BQU9OLG1CQUFPQSxDQUFDLDJEQUFRO0FBRTNCOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0QsU0FBU0YsT0FBT1MsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFdBQVcsRUFBRUMsWUFBWSxFQUFFQyxhQUFhLEVBQUVDLGNBQWMsRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLGFBQWE7SUFFakgsd0JBQXdCLEdBQ3hCLElBQUlULEtBQUtVLFFBQVEsQ0FBQ0wsZ0JBQWdCO1FBQzlCRSxVQUFVRjtRQUNWQSxnQkFBZ0JDLGlCQUFpQks7SUFDckMsT0FBTyxJQUFJWCxLQUFLVSxRQUFRLENBQUNKLGlCQUFpQjtRQUN0Q0MsVUFBVUQ7UUFDVkEsaUJBQWlCSztJQUNyQjtJQUVBLHNCQUFzQixHQUN0QixJQUFJLENBQUVULENBQUFBLFNBQVNTLGFBQWFYLEtBQUtZLFFBQVEsQ0FBQ1YsS0FBSSxHQUMxQyxNQUFNVyxVQUFVO0lBRXBCLHNCQUFzQixHQUN0QixJQUFJLENBQUNiLEtBQUtZLFFBQVEsQ0FBQ1QsY0FDZixNQUFNVSxVQUFVO0lBRXBCLHNCQUFzQixHQUN0QixJQUFJLENBQUNiLEtBQUtZLFFBQVEsQ0FBQ1IsZUFDZixNQUFNUyxVQUFVO0lBRXBCcEIsaUJBQWlCcUIsSUFBSSxDQUFDLElBQUksRUFBRWIsTUFBTU07SUFFbEM7OztLQUdDLEdBQ0QsSUFBSSxDQUFDTCxJQUFJLEdBQUdBLFFBQVEsT0FBTyxTQUFTO0lBRXBDOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsV0FBVyxHQUFHQSxhQUFhLGlCQUFpQjtJQUVqRDs7O0tBR0MsR0FDRCxJQUFJLENBQUNFLGFBQWEsR0FBR0EsZ0JBQWdCLE9BQU9NLFdBQVcsU0FBUztJQUVoRTs7O0tBR0MsR0FDRCxJQUFJLENBQUNQLFlBQVksR0FBR0EsY0FBYyxTQUFTO0lBRTNDOzs7S0FHQyxHQUNELElBQUksQ0FBQ0UsY0FBYyxHQUFHQSxpQkFBaUIsT0FBT0ssV0FBVyxTQUFTO0lBRWxFOzs7S0FHQyxHQUNELElBQUksQ0FBQ0ksbUJBQW1CLEdBQUc7SUFFM0I7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRztJQUU1Qjs7O0tBR0MsR0FDRCxJQUFJLENBQUNSLE9BQU8sR0FBR0E7SUFFZjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsYUFBYSxHQUFHQTtBQUN6QjtBQUVBOzs7Ozs7Ozs7OztDQVdDLEdBRUQ7Ozs7OztDQU1DLEdBQ0RqQixPQUFPeUIsUUFBUSxHQUFHLFNBQVNBLFNBQVNoQixJQUFJLEVBQUVpQixJQUFJO0lBQzFDLE9BQU8sSUFBSTFCLE9BQU9TLE1BQU1pQixLQUFLaEIsSUFBSSxFQUFFZ0IsS0FBS2YsV0FBVyxFQUFFZSxLQUFLZCxZQUFZLEVBQUVjLEtBQUtiLGFBQWEsRUFBRWEsS0FBS1osY0FBYyxFQUFFWSxLQUFLWCxPQUFPLEVBQUVXLEtBQUtWLE9BQU8sRUFBRVUsS0FBS1QsYUFBYTtBQUNuSztBQUVBOzs7O0NBSUMsR0FDRGpCLE9BQU9HLFNBQVMsQ0FBQ3dCLE1BQU0sR0FBRyxTQUFTQSxPQUFPQyxhQUFhO0lBQ25ELElBQUlDLGVBQWVELGdCQUFnQkUsUUFBUUYsY0FBY0MsWUFBWSxJQUFJO0lBQ3pFLE9BQU9yQixLQUFLdUIsUUFBUSxDQUFDO1FBQ2pCO1FBQW1CLElBQUksQ0FBQ3JCLElBQUksS0FBSyxTQUFTLHdCQUF3QixHQUFHLElBQUksQ0FBQ0EsSUFBSSxJQUFJUztRQUNsRjtRQUFtQixJQUFJLENBQUNSLFdBQVc7UUFDbkM7UUFBbUIsSUFBSSxDQUFDRSxhQUFhO1FBQ3JDO1FBQW1CLElBQUksQ0FBQ0QsWUFBWTtRQUNwQztRQUFtQixJQUFJLENBQUNFLGNBQWM7UUFDdEM7UUFBbUIsSUFBSSxDQUFDQyxPQUFPO1FBQy9CO1FBQW1CYyxlQUFlLElBQUksQ0FBQ2IsT0FBTyxHQUFHRztRQUNqRDtRQUFtQixJQUFJLENBQUNGLGFBQWE7S0FDeEM7QUFDTDtBQUVBOztDQUVDLEdBQ0RqQixPQUFPRyxTQUFTLENBQUM2QixPQUFPLEdBQUcsU0FBU0E7SUFFaEMsc0JBQXNCLEdBQ3RCLElBQUksSUFBSSxDQUFDQyxRQUFRLEVBQ2IsT0FBTyxJQUFJO0lBRWYsSUFBSSxDQUFDVixtQkFBbUIsR0FBRyxJQUFJLENBQUNXLE1BQU0sQ0FBQ0MsVUFBVSxDQUFDLElBQUksQ0FBQ3hCLFdBQVc7SUFDbEUsSUFBSSxDQUFDYSxvQkFBb0IsR0FBRyxJQUFJLENBQUNVLE1BQU0sQ0FBQ0MsVUFBVSxDQUFDLElBQUksQ0FBQ3ZCLFlBQVk7SUFFcEUsT0FBT1gsaUJBQWlCRSxTQUFTLENBQUM2QixPQUFPLENBQUNWLElBQUksQ0FBQyxJQUFJO0FBQ3ZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9tZXRob2QuanM/YmUwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTWV0aG9kO1xuXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuKChNZXRob2QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gTWV0aG9kKS5jbGFzc05hbWUgPSBcIk1ldGhvZFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBzZXJ2aWNlIG1ldGhvZCBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIHNlcnZpY2UgbWV0aG9kLlxuICogQGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXRob2QgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB0eXBlIE1ldGhvZCB0eXBlLCB1c3VhbGx5IGBcInJwY1wiYFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RUeXBlIFJlcXVlc3QgbWVzc2FnZSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2VUeXBlIFJlc3BvbnNlIG1lc3NhZ2UgdHlwZVxuICogQHBhcmFtIHtib29sZWFufE9iamVjdC48c3RyaW5nLCo+fSBbcmVxdWVzdFN0cmVhbV0gV2hldGhlciB0aGUgcmVxdWVzdCBpcyBzdHJlYW1lZFxuICogQHBhcmFtIHtib29sZWFufE9iamVjdC48c3RyaW5nLCo+fSBbcmVzcG9uc2VTdHJlYW1dIFdoZXRoZXIgdGhlIHJlc3BvbnNlIGlzIHN0cmVhbWVkXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBUaGUgY29tbWVudCBmb3IgdGhpcyBtZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwYXJzZWRPcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zLCBwcm9wZXJseSBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gTWV0aG9kKG5hbWUsIHR5cGUsIHJlcXVlc3RUeXBlLCByZXNwb25zZVR5cGUsIHJlcXVlc3RTdHJlYW0sIHJlc3BvbnNlU3RyZWFtLCBvcHRpb25zLCBjb21tZW50LCBwYXJzZWRPcHRpb25zKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh1dGlsLmlzT2JqZWN0KHJlcXVlc3RTdHJlYW0pKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZXF1ZXN0U3RyZWFtO1xuICAgICAgICByZXF1ZXN0U3RyZWFtID0gcmVzcG9uc2VTdHJlYW0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KHJlc3BvbnNlU3RyZWFtKSkge1xuICAgICAgICBvcHRpb25zID0gcmVzcG9uc2VTdHJlYW07XG4gICAgICAgIHJlc3BvbnNlU3RyZWFtID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB1dGlsLmlzU3RyaW5nKHR5cGUpKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwidHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKHJlcXVlc3RUeXBlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdFR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdXRpbC5pc1N0cmluZyhyZXNwb25zZVR5cGUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXNwb25zZVR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0eXBlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZSB8fCBcInJwY1wiOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdFR5cGUgPSByZXF1ZXN0VHlwZTsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIHN0cmVhbWVkIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0U3RyZWFtID0gcmVxdWVzdFN0cmVhbSA/IHRydWUgOiB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUmVzcG9uc2UgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBzdHJlYW1lZCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VTdHJlYW0gPSByZXNwb25zZVN0cmVhbSA/IHRydWUgOiB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgcmVxdWVzdCB0eXBlLlxuICAgICAqIEB0eXBlIHtUeXBlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlZFJlcXVlc3RUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIHJlc3BvbnNlIHR5cGUuXG4gICAgICogQHR5cGUge1R5cGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkUmVzcG9uc2VUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENvbW1lbnQgZm9yIHRoaXMgbWV0aG9kXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIHByb3Blcmx5IHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICAgICAqL1xuICAgIHRoaXMucGFyc2VkT3B0aW9ucyA9IHBhcnNlZE9wdGlvbnM7XG59XG5cbi8qKlxuICogTWV0aG9kIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElNZXRob2RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZT1cInJwY1wiXSBNZXRob2QgdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlcXVlc3RUeXBlIFJlcXVlc3QgdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlc3BvbnNlVHlwZSBSZXNwb25zZSB0eXBlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1ZXN0U3RyZWFtPWZhbHNlXSBXaGV0aGVyIHJlcXVlc3RzIGFyZSBzdHJlYW1lZFxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVzcG9uc2VTdHJlYW09ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBzdHJlYW1lZFxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIE1ldGhvZCBvcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29tbWVudCBNZXRob2QgY29tbWVudHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwYXJzZWRPcHRpb25zXSBNZXRob2Qgb3B0aW9ucyBwcm9wZXJseSBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBtZXRob2QgZnJvbSBhIG1ldGhvZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcbiAqIEBwYXJhbSB7SU1ldGhvZH0ganNvbiBNZXRob2QgZGVzY3JpcHRvclxuICogQHJldHVybnMge01ldGhvZH0gQ3JlYXRlZCBtZXRob2RcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbk1ldGhvZC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IE1ldGhvZChuYW1lLCBqc29uLnR5cGUsIGpzb24ucmVxdWVzdFR5cGUsIGpzb24ucmVzcG9uc2VUeXBlLCBqc29uLnJlcXVlc3RTdHJlYW0sIGpzb24ucmVzcG9uc2VTdHJlYW0sIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50LCBqc29uLnBhcnNlZE9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG1ldGhvZCB0byBhIG1ldGhvZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU1ldGhvZH0gTWV0aG9kIGRlc2NyaXB0b3JcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgICAsIHRoaXMudHlwZSAhPT0gXCJycGNcIiAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB0aGlzLnR5cGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcInJlcXVlc3RUeXBlXCIgICAgLCB0aGlzLnJlcXVlc3RUeXBlLFxuICAgICAgICBcInJlcXVlc3RTdHJlYW1cIiAgLCB0aGlzLnJlcXVlc3RTdHJlYW0sXG4gICAgICAgIFwicmVzcG9uc2VUeXBlXCIgICAsIHRoaXMucmVzcG9uc2VUeXBlLFxuICAgICAgICBcInJlc3BvbnNlU3RyZWFtXCIgLCB0aGlzLnJlc3BvbnNlU3RyZWFtLFxuICAgICAgICBcIm9wdGlvbnNcIiAgICAgICAgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwiY29tbWVudFwiICAgICAgICAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJwYXJzZWRPcHRpb25zXCIgICwgdGhpcy5wYXJzZWRPcHRpb25zLFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnJlc29sdmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZSA9IHRoaXMucGFyZW50Lmxvb2t1cFR5cGUodGhpcy5yZXF1ZXN0VHlwZSk7XG4gICAgdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZSA9IHRoaXMucGFyZW50Lmxvb2t1cFR5cGUodGhpcy5yZXNwb25zZVR5cGUpO1xuXG4gICAgcmV0dXJuIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIk1ldGhvZCIsIlJlZmxlY3Rpb25PYmplY3QiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJjbGFzc05hbWUiLCJ1dGlsIiwibmFtZSIsInR5cGUiLCJyZXF1ZXN0VHlwZSIsInJlc3BvbnNlVHlwZSIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsIm9wdGlvbnMiLCJjb21tZW50IiwicGFyc2VkT3B0aW9ucyIsImlzT2JqZWN0IiwidW5kZWZpbmVkIiwiaXNTdHJpbmciLCJUeXBlRXJyb3IiLCJjYWxsIiwicmVzb2x2ZWRSZXF1ZXN0VHlwZSIsInJlc29sdmVkUmVzcG9uc2VUeXBlIiwiZnJvbUpTT04iLCJqc29uIiwidG9KU09OIiwidG9KU09OT3B0aW9ucyIsImtlZXBDb21tZW50cyIsIkJvb2xlYW4iLCJ0b09iamVjdCIsInJlc29sdmUiLCJyZXNvbHZlZCIsInBhcmVudCIsImxvb2t1cFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/method.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/namespace.js":
/*!**************************************************!*\
  !*** ./node_modules/protobufjs/src/namespace.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Namespace;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/protobufjs/src/object.js\");\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/protobufjs/src/field.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/protobufjs/src/oneof.js\");\nvar Type, Service, Enum;\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */ /**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */ Namespace.fromJSON = function fromJSON(name, json) {\n    return new Namespace(name, json.options).addJSON(json.nested);\n};\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */ function arrayToJSON(array, toJSONOptions) {\n    if (!(array && array.length)) return undefined;\n    var obj = {};\n    for(var i = 0; i < array.length; ++i)obj[array[i].name] = array[i].toJSON(toJSONOptions);\n    return obj;\n}\nNamespace.arrayToJSON = arrayToJSON;\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Namespace.isReservedId = function isReservedId(reserved, id) {\n    if (reserved) {\n        for(var i = 0; i < reserved.length; ++i)if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id) return true;\n    }\n    return false;\n};\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Namespace.isReservedName = function isReservedName(reserved, name) {\n    if (reserved) {\n        for(var i = 0; i < reserved.length; ++i)if (reserved[i] === name) return true;\n    }\n    return false;\n};\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */ function Namespace(name, options) {\n    ReflectionObject.call(this, name, options);\n    /**\n     * Nested objects by name.\n     * @type {Object.<string,ReflectionObject>|undefined}\n     */ this.nested = undefined; // toJSON\n    /**\n     * Cached nested objects as an array.\n     * @type {ReflectionObject[]|null}\n     * @private\n     */ this._nestedArray = null;\n}\nfunction clearCache(namespace) {\n    namespace._nestedArray = null;\n    return namespace;\n}\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */ Object.defineProperty(Namespace.prototype, \"nestedArray\", {\n    get: function() {\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n    }\n});\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */ /**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */ /**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}\n */ /**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */ Namespace.prototype.toJSON = function toJSON(toJSONOptions) {\n    return util.toObject([\n        \"options\",\n        this.options,\n        \"nested\",\n        arrayToJSON(this.nestedArray, toJSONOptions)\n    ]);\n};\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */ Namespace.prototype.addJSON = function addJSON(nestedJson) {\n    var ns = this;\n    /* istanbul ignore else */ if (nestedJson) {\n        for(var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i){\n            nested = nestedJson[names[i]];\n            ns.add((nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : nested.id !== undefined ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));\n        }\n    }\n    return this;\n};\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */ Namespace.prototype.get = function get(name) {\n    return this.nested && this.nested[name] || null;\n};\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */ Namespace.prototype.getEnum = function getEnum(name) {\n    if (this.nested && this.nested[name] instanceof Enum) return this.nested[name].values;\n    throw Error(\"no such enum: \" + name);\n};\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */ Namespace.prototype.add = function add(object) {\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace)) throw TypeError(\"object must be a valid nested object\");\n    if (!this.nested) this.nested = {};\n    else {\n        var prev = this.get(object.name);\n        if (prev) {\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n                // replace plain namespace but keep existing nested elements and options\n                var nested = prev.nestedArray;\n                for(var i = 0; i < nested.length; ++i)object.add(nested[i]);\n                this.remove(prev);\n                if (!this.nested) this.nested = {};\n                object.setOptions(prev.options, true);\n            } else throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n        }\n    }\n    this.nested[object.name] = object;\n    object.onAdd(this);\n    return clearCache(this);\n};\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */ Namespace.prototype.remove = function remove(object) {\n    if (!(object instanceof ReflectionObject)) throw TypeError(\"object must be a ReflectionObject\");\n    if (object.parent !== this) throw Error(object + \" is not a member of \" + this);\n    delete this.nested[object.name];\n    if (!Object.keys(this.nested).length) this.nested = undefined;\n    object.onRemove(this);\n    return clearCache(this);\n};\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */ Namespace.prototype.define = function define(path, json) {\n    if (util.isString(path)) path = path.split(\".\");\n    else if (!Array.isArray(path)) throw TypeError(\"illegal path\");\n    if (path && path.length && path[0] === \"\") throw Error(\"path must be relative\");\n    var ptr = this;\n    while(path.length > 0){\n        var part = path.shift();\n        if (ptr.nested && ptr.nested[part]) {\n            ptr = ptr.nested[part];\n            if (!(ptr instanceof Namespace)) throw Error(\"path conflicts with non-namespace objects\");\n        } else ptr.add(ptr = new Namespace(part));\n    }\n    if (json) ptr.addJSON(json);\n    return ptr;\n};\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */ Namespace.prototype.resolveAll = function resolveAll() {\n    var nested = this.nestedArray, i = 0;\n    while(i < nested.length)if (nested[i] instanceof Namespace) nested[i++].resolveAll();\n    else nested[i++].resolve();\n    return this.resolve();\n};\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */ Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n    /* istanbul ignore next */ if (typeof filterTypes === \"boolean\") {\n        parentAlreadyChecked = filterTypes;\n        filterTypes = undefined;\n    } else if (filterTypes && !Array.isArray(filterTypes)) filterTypes = [\n        filterTypes\n    ];\n    if (util.isString(path) && path.length) {\n        if (path === \".\") return this.root;\n        path = path.split(\".\");\n    } else if (!path.length) return this;\n    // Start at root if path is absolute\n    if (path[0] === \"\") return this.root.lookup(path.slice(1), filterTypes);\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\n    var found = this.get(path[0]);\n    if (found) {\n        if (path.length === 1) {\n            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1) return found;\n        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true))) return found;\n    // Otherwise try each nested namespace\n    } else for(var i = 0; i < this.nestedArray.length; ++i)if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true))) return found;\n    // If there hasn't been a match, try again at the parent\n    if (this.parent === null || parentAlreadyChecked) return null;\n    return this.parent.lookup(path, filterTypes);\n};\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */ // lookup(path: string, [parentAlreadyChecked: boolean])\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */ Namespace.prototype.lookupType = function lookupType(path) {\n    var found = this.lookup(path, [\n        Type\n    ]);\n    if (!found) throw Error(\"no such type: \" + path);\n    return found;\n};\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */ Namespace.prototype.lookupEnum = function lookupEnum(path) {\n    var found = this.lookup(path, [\n        Enum\n    ]);\n    if (!found) throw Error(\"no such Enum '\" + path + \"' in \" + this);\n    return found;\n};\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */ Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n    var found = this.lookup(path, [\n        Type,\n        Enum\n    ]);\n    if (!found) throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n    return found;\n};\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */ Namespace.prototype.lookupService = function lookupService(path) {\n    var found = this.lookup(path, [\n        Service\n    ]);\n    if (!found) throw Error(\"no such Service '\" + path + \"' in \" + this);\n    return found;\n};\n// Sets up cyclic dependencies (called in index-light)\nNamespace._configure = function(Type_, Service_, Enum_) {\n    Type = Type_;\n    Service = Service_;\n    Enum = Enum_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbmFtZXNwYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsMkJBQTJCO0FBQzNCLElBQUlDLG1CQUFtQkMsbUJBQU9BLENBQUMsK0RBQVU7QUFDeEMsRUFBQ0YsVUFBVUcsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLGlCQUFpQkUsU0FBUyxHQUFHRyxXQUFXLEdBQUdOLFNBQVEsRUFBR08sU0FBUyxHQUFHO0FBRXhHLElBQUlDLFFBQVdOLG1CQUFPQSxDQUFDLDZEQUFTLEdBQzVCTyxPQUFXUCxtQkFBT0EsQ0FBQywyREFBUSxHQUMzQlEsUUFBV1IsbUJBQU9BLENBQUMsNkRBQVM7QUFFaEMsSUFBSVMsTUFDQUMsU0FDQUM7QUFFSjs7Ozs7Ozs7Q0FRQyxHQUVEOzs7Ozs7OztDQVFDLEdBQ0RiLFVBQVVjLFFBQVEsR0FBRyxTQUFTQSxTQUFTQyxJQUFJLEVBQUVDLElBQUk7SUFDN0MsT0FBTyxJQUFJaEIsVUFBVWUsTUFBTUMsS0FBS0MsT0FBTyxFQUFFQyxPQUFPLENBQUNGLEtBQUtHLE1BQU07QUFDaEU7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxZQUFZQyxLQUFLLEVBQUVDLGFBQWE7SUFDckMsSUFBSSxDQUFFRCxDQUFBQSxTQUFTQSxNQUFNRSxNQUFNLEdBQ3ZCLE9BQU9DO0lBQ1gsSUFBSUMsTUFBTSxDQUFDO0lBQ1gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlMLE1BQU1FLE1BQU0sRUFBRSxFQUFFRyxFQUNoQ0QsR0FBRyxDQUFDSixLQUFLLENBQUNLLEVBQUUsQ0FBQ1gsSUFBSSxDQUFDLEdBQUdNLEtBQUssQ0FBQ0ssRUFBRSxDQUFDQyxNQUFNLENBQUNMO0lBQ3pDLE9BQU9HO0FBQ1g7QUFFQXpCLFVBQVVvQixXQUFXLEdBQUdBO0FBRXhCOzs7OztDQUtDLEdBQ0RwQixVQUFVNEIsWUFBWSxHQUFHLFNBQVNBLGFBQWFDLFFB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dG9idWZqcy9zcmMvbmFtZXNwYWNlLmpzP2JjY2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE5hbWVzcGFjZTtcblxuLy8gZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG52YXIgUmVmbGVjdGlvbk9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbigoTmFtZXNwYWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IE5hbWVzcGFjZSkuY2xhc3NOYW1lID0gXCJOYW1lc3BhY2VcIjtcblxudmFyIEZpZWxkICAgID0gcmVxdWlyZShcIi4vZmllbGRcIiksXG4gICAgdXRpbCAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpLFxuICAgIE9uZU9mICAgID0gcmVxdWlyZShcIi4vb25lb2ZcIik7XG5cbnZhciBUeXBlLCAgICAvLyBjeWNsaWNcbiAgICBTZXJ2aWNlLFxuICAgIEVudW07XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBuYW1lc3BhY2UgaW5zdGFuY2UuXG4gKiBAbmFtZSBOYW1lc3BhY2VcbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIG5hbWVzcGFjZS5cbiAqIEBleHRlbmRzIE5hbWVzcGFjZUJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZXNwYWNlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmFtZXNwYWNlIGZyb20gSlNPTi5cbiAqIEBtZW1iZXJvZiBOYW1lc3BhY2VcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZXNwYWNlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGpzb24gSlNPTiBvYmplY3RcbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IENyZWF0ZWQgbmFtZXNwYWNlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5OYW1lc3BhY2UuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBOYW1lc3BhY2UobmFtZSwganNvbi5vcHRpb25zKS5hZGRKU09OKGpzb24ubmVzdGVkKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb2YgcmVmbGVjdGlvbiBvYmplY3RzIHRvIEpTT04uXG4gKiBAbWVtYmVyb2YgTmFtZXNwYWNlXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3RbXX0gYXJyYXkgT2JqZWN0IGFycmF5XG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPnx1bmRlZmluZWR9IEpTT04gb2JqZWN0IG9yIGB1bmRlZmluZWRgIHdoZW4gYXJyYXkgaXMgZW1wdHlcbiAqL1xuZnVuY3Rpb24gYXJyYXlUb0pTT04oYXJyYXksIHRvSlNPTk9wdGlvbnMpIHtcbiAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHZhciBvYmogPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICBvYmpbYXJyYXlbaV0ubmFtZV0gPSBhcnJheVtpXS50b0pTT04odG9KU09OT3B0aW9ucyk7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuTmFtZXNwYWNlLmFycmF5VG9KU09OID0gYXJyYXlUb0pTT047XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBpZCBpcyByZXNlcnZlZC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcltdfHN0cmluZz58dW5kZWZpbmVkfSByZXNlcnZlZCBBcnJheSBvZiByZXNlcnZlZCByYW5nZXMgYW5kIG5hbWVzXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgSWQgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuTmFtZXNwYWNlLmlzUmVzZXJ2ZWRJZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRJZChyZXNlcnZlZCwgaWQpIHtcbiAgICBpZiAocmVzZXJ2ZWQpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzZXJ2ZWQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc2VydmVkW2ldICE9PSBcInN0cmluZ1wiICYmIHJlc2VydmVkW2ldWzBdIDw9IGlkICYmIHJlc2VydmVkW2ldWzFdID4gaWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fHVuZGVmaW5lZH0gcmVzZXJ2ZWQgQXJyYXkgb2YgcmVzZXJ2ZWQgcmFuZ2VzIGFuZCBuYW1lc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG5OYW1lc3BhY2UuaXNSZXNlcnZlZE5hbWUgPSBmdW5jdGlvbiBpc1Jlc2VydmVkTmFtZShyZXNlcnZlZCwgbmFtZSkge1xuICAgIGlmIChyZXNlcnZlZClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNlcnZlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmIChyZXNlcnZlZFtpXSA9PT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIE5vdCBhbiBhY3R1YWwgY29uc3RydWN0b3IuIFVzZSB7QGxpbmsgTmFtZXNwYWNlfSBpbnN0ZWFkLlxuICogQGNsYXNzZGVzYyBCYXNlIGNsYXNzIG9mIGFsbCByZWZsZWN0aW9uIG9iamVjdHMgY29udGFpbmluZyBuZXN0ZWQgb2JqZWN0cy4gVGhpcyBpcyBub3QgYW4gYWN0dWFsIGNsYXNzIGJ1dCBoZXJlIGZvciB0aGUgc2FrZSBvZiBoYXZpbmcgY29uc2lzdGVudCB0eXBlIGRlZmluaXRpb25zLlxuICogQGV4cG9ydHMgTmFtZXNwYWNlQmFzZVxuICogQGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxuICogQGFic3RyYWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHNlZSB7QGxpbmsgTmFtZXNwYWNlfVxuICovXG5mdW5jdGlvbiBOYW1lc3BhY2UobmFtZSwgb3B0aW9ucykge1xuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIE5lc3RlZCBvYmplY3RzIGJ5IG5hbWUuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLFJlZmxlY3Rpb25PYmplY3Q+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm5lc3RlZCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgbmVzdGVkIG9iamVjdHMgYXMgYW4gYXJyYXkuXG4gICAgICogQHR5cGUge1JlZmxlY3Rpb25PYmplY3RbXXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbmVzdGVkQXJyYXkgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjbGVhckNhY2hlKG5hbWVzcGFjZSkge1xuICAgIG5hbWVzcGFjZS5fbmVzdGVkQXJyYXkgPSBudWxsO1xuICAgIHJldHVybiBuYW1lc3BhY2U7XG59XG5cbi8qKlxuICogTmVzdGVkIG9iamVjdHMgb2YgdGhpcyBuYW1lc3BhY2UgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAqIEBuYW1lIE5hbWVzcGFjZUJhc2UjbmVzdGVkQXJyYXlcbiAqIEB0eXBlIHtSZWZsZWN0aW9uT2JqZWN0W119XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE5hbWVzcGFjZS5wcm90b3R5cGUsIFwibmVzdGVkQXJyYXlcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXN0ZWRBcnJheSB8fCAodGhpcy5fbmVzdGVkQXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5uZXN0ZWQpKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBOYW1lc3BhY2UgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSU5hbWVzcGFjZVxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIE5hbWVzcGFjZSBvcHRpb25zXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLEFueU5lc3RlZE9iamVjdD59IFtuZXN0ZWRdIE5lc3RlZCBvYmplY3QgZGVzY3JpcHRvcnNcbiAqL1xuXG4vKipcbiAqIEFueSBleHRlbnNpb24gZmllbGQgZGVzY3JpcHRvci5cbiAqIEB0eXBlZGVmIEFueUV4dGVuc2lvbkZpZWxkXG4gKiBAdHlwZSB7SUV4dGVuc2lvbkZpZWxkfElFeHRlbnNpb25NYXBGaWVsZH1cbiAqL1xuXG4vKipcbiAqIEFueSBuZXN0ZWQgb2JqZWN0IGRlc2NyaXB0b3IuXG4gKiBAdHlwZWRlZiBBbnlOZXN0ZWRPYmplY3RcbiAqIEB0eXBlIHtJRW51bXxJVHlwZXxJU2VydmljZXxBbnlFeHRlbnNpb25GaWVsZHxJTmFtZXNwYWNlfElPbmVPZn1cbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbmFtZXNwYWNlIHRvIGEgbmFtZXNwYWNlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJTmFtZXNwYWNlfSBOYW1lc3BhY2UgZGVzY3JpcHRvclxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcIm9wdGlvbnNcIiAsIHRoaXMub3B0aW9ucyxcbiAgICAgICAgXCJuZXN0ZWRcIiAgLCBhcnJheVRvSlNPTih0aGlzLm5lc3RlZEFycmF5LCB0b0pTT05PcHRpb25zKVxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBBZGRzIG5lc3RlZCBvYmplY3RzIHRvIHRoaXMgbmFtZXNwYWNlIGZyb20gbmVzdGVkIG9iamVjdCBkZXNjcmlwdG9ycy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsQW55TmVzdGVkT2JqZWN0Pn0gbmVzdGVkSnNvbiBBbnkgbmVzdGVkIG9iamVjdCBkZXNjcmlwdG9yc1xuICogQHJldHVybnMge05hbWVzcGFjZX0gYHRoaXNgXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuYWRkSlNPTiA9IGZ1bmN0aW9uIGFkZEpTT04obmVzdGVkSnNvbikge1xuICAgIHZhciBucyA9IHRoaXM7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAobmVzdGVkSnNvbikge1xuICAgICAgICBmb3IgKHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKG5lc3RlZEpzb24pLCBpID0gMCwgbmVzdGVkOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5lc3RlZCA9IG5lc3RlZEpzb25bbmFtZXNbaV1dO1xuICAgICAgICAgICAgbnMuYWRkKCAvLyBtb3N0IHRvIGxlYXN0IGxpa2VseVxuICAgICAgICAgICAgICAgICggbmVzdGVkLmZpZWxkcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBUeXBlLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQudmFsdWVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IEVudW0uZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IG5lc3RlZC5tZXRob2RzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFNlcnZpY2UuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IG5lc3RlZC5pZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBGaWVsZC5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogTmFtZXNwYWNlLmZyb21KU09OICkobmFtZXNbaV0sIG5lc3RlZClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIG5lc3RlZCBvYmplY3Qgb2YgdGhlIHNwZWNpZmllZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmVzdGVkIG9iamVjdCBuYW1lXG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdHxudWxsfSBUaGUgcmVmbGVjdGlvbiBvYmplY3Qgb3IgYG51bGxgIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLm5lc3RlZCAmJiB0aGlzLm5lc3RlZFtuYW1lXVxuICAgICAgICB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZXMgb2YgdGhlIG5lc3RlZCB7QGxpbmsgRW51bXxlbnVtfSBvZiB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gKiBUaGlzIG1ldGhvZHMgZGlmZmVycyBmcm9tIHtAbGluayBOYW1lc3BhY2UjZ2V0fGdldH0gaW4gdGhhdCBpdCByZXR1cm5zIGFuIGVudW0ncyB2YWx1ZXMgZGlyZWN0bHkgYW5kIHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOZXN0ZWQgZW51bSBuYW1lXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn0gRW51bSB2YWx1ZXNcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBubyBzdWNoIGVudW1cbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5nZXRFbnVtID0gZnVuY3Rpb24gZ2V0RW51bShuYW1lKSB7XG4gICAgaWYgKHRoaXMubmVzdGVkICYmIHRoaXMubmVzdGVkW25hbWVdIGluc3RhbmNlb2YgRW51bSlcbiAgICAgICAgcmV0dXJuIHRoaXMubmVzdGVkW25hbWVdLnZhbHVlcztcbiAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggZW51bTogXCIgKyBuYW1lKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIG5lc3RlZCBvYmplY3QgdG8gdGhpcyBuYW1lc3BhY2UuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBOZXN0ZWQgb2JqZWN0IHRvIGFkZFxuICogQHJldHVybnMge05hbWVzcGFjZX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGFscmVhZHkgYSBuZXN0ZWQgb2JqZWN0IHdpdGggdGhpcyBuYW1lXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG9iamVjdCkge1xuXG4gICAgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgRmllbGQgJiYgb2JqZWN0LmV4dGVuZCAhPT0gdW5kZWZpbmVkIHx8IG9iamVjdCBpbnN0YW5jZW9mIFR5cGUgIHx8IG9iamVjdCBpbnN0YW5jZW9mIE9uZU9mIHx8IG9iamVjdCBpbnN0YW5jZW9mIEVudW0gfHwgb2JqZWN0IGluc3RhbmNlb2YgU2VydmljZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBOYW1lc3BhY2UpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJvYmplY3QgbXVzdCBiZSBhIHZhbGlkIG5lc3RlZCBvYmplY3RcIik7XG5cbiAgICBpZiAoIXRoaXMubmVzdGVkKVxuICAgICAgICB0aGlzLm5lc3RlZCA9IHt9O1xuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcHJldiA9IHRoaXMuZ2V0KG9iamVjdC5uYW1lKTtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIGlmIChwcmV2IGluc3RhbmNlb2YgTmFtZXNwYWNlICYmIG9iamVjdCBpbnN0YW5jZW9mIE5hbWVzcGFjZSAmJiAhKHByZXYgaW5zdGFuY2VvZiBUeXBlIHx8IHByZXYgaW5zdGFuY2VvZiBTZXJ2aWNlKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgcGxhaW4gbmFtZXNwYWNlIGJ1dCBrZWVwIGV4aXN0aW5nIG5lc3RlZCBlbGVtZW50cyBhbmQgb3B0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBuZXN0ZWQgPSBwcmV2Lm5lc3RlZEFycmF5O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVzdGVkLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuYWRkKG5lc3RlZFtpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUocHJldik7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm5lc3RlZClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWQgPSB7fTtcbiAgICAgICAgICAgICAgICBvYmplY3Quc2V0T3B0aW9ucyhwcmV2Lm9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBuYW1lICdcIiArIG9iamVjdC5uYW1lICsgXCInIGluIFwiICsgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5uZXN0ZWRbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xuICAgIG9iamVjdC5vbkFkZCh0aGlzKTtcbiAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIG5lc3RlZCBvYmplY3QgZnJvbSB0aGlzIG5hbWVzcGFjZS5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYG9iamVjdGAgaXMgbm90IGEgbWVtYmVyIG9mIHRoaXMgbmFtZXNwYWNlXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKG9iamVjdCkge1xuXG4gICAgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgUmVmbGVjdGlvbk9iamVjdCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIm9iamVjdCBtdXN0IGJlIGEgUmVmbGVjdGlvbk9iamVjdFwiKTtcbiAgICBpZiAob2JqZWN0LnBhcmVudCAhPT0gdGhpcylcbiAgICAgICAgdGhyb3cgRXJyb3Iob2JqZWN0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICBkZWxldGUgdGhpcy5uZXN0ZWRbb2JqZWN0Lm5hbWVdO1xuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5uZXN0ZWQpLmxlbmd0aClcbiAgICAgICAgdGhpcy5uZXN0ZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBvYmplY3Qub25SZW1vdmUodGhpcyk7XG4gICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG59O1xuXG4vKipcbiAqIERlZmluZXMgYWRkaXRpYWwgbmFtZXNwYWNlcyB3aXRoaW4gdGhpcyBvbmUgaWYgbm90IHlldCBleGlzdGluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gY3JlYXRlXG4gKiBAcGFyYW0geyp9IFtqc29uXSBOZXN0ZWQgdHlwZXMgdG8gY3JlYXRlIGZyb20gSlNPTlxuICogQHJldHVybnMge05hbWVzcGFjZX0gUG9pbnRlciB0byB0aGUgbGFzdCBuYW1lc3BhY2UgY3JlYXRlZCBvciBgdGhpc2AgaWYgcGF0aCBpcyBlbXB0eVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShwYXRoLCBqc29uKSB7XG5cbiAgICBpZiAodXRpbC5pc1N0cmluZyhwYXRoKSlcbiAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJpbGxlZ2FsIHBhdGhcIik7XG4gICAgaWYgKHBhdGggJiYgcGF0aC5sZW5ndGggJiYgcGF0aFswXSA9PT0gXCJcIilcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJwYXRoIG11c3QgYmUgcmVsYXRpdmVcIik7XG5cbiAgICB2YXIgcHRyID0gdGhpcztcbiAgICB3aGlsZSAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGF0aC5zaGlmdCgpO1xuICAgICAgICBpZiAocHRyLm5lc3RlZCAmJiBwdHIubmVzdGVkW3BhcnRdKSB7XG4gICAgICAgICAgICBwdHIgPSBwdHIubmVzdGVkW3BhcnRdO1xuICAgICAgICAgICAgaWYgKCEocHRyIGluc3RhbmNlb2YgTmFtZXNwYWNlKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInBhdGggY29uZmxpY3RzIHdpdGggbm9uLW5hbWVzcGFjZSBvYmplY3RzXCIpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHB0ci5hZGQocHRyID0gbmV3IE5hbWVzcGFjZShwYXJ0KSk7XG4gICAgfVxuICAgIGlmIChqc29uKVxuICAgICAgICBwdHIuYWRkSlNPTihqc29uKTtcbiAgICByZXR1cm4gcHRyO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGlzIG5hbWVzcGFjZSdzIGFuZCBhbGwgaXRzIG5lc3RlZCBvYmplY3RzJyB0eXBlIHJlZmVyZW5jZXMuIFVzZWZ1bCB0byB2YWxpZGF0ZSBhIHJlZmxlY3Rpb24gdHJlZSwgYnV0IGNvbWVzIGF0IGEgY29zdC5cbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IGB0aGlzYFxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbiByZXNvbHZlQWxsKCkge1xuICAgIHZhciBuZXN0ZWQgPSB0aGlzLm5lc3RlZEFycmF5LCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IG5lc3RlZC5sZW5ndGgpXG4gICAgICAgIGlmIChuZXN0ZWRbaV0gaW5zdGFuY2VvZiBOYW1lc3BhY2UpXG4gICAgICAgICAgICBuZXN0ZWRbaSsrXS5yZXNvbHZlQWxsKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5lc3RlZFtpKytdLnJlc29sdmUoKTtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKCk7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGxvb2tzIHVwIHRoZSByZWZsZWN0aW9uIG9iamVjdCBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHBhdGggaW4gdGhlIHNjb3BlIG9mIHRoaXMgbmFtZXNwYWNlLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcGFyYW0geyp8QXJyYXkuPCo+fSBmaWx0ZXJUeXBlcyBGaWx0ZXIgdHlwZXMsIGFueSBjb21iaW5hdGlvbiBvZiB0aGUgY29uc3RydWN0b3JzIG9mIGBwcm90b2J1Zi5UeXBlYCwgYHByb3RvYnVmLkVudW1gLCBgcHJvdG9idWYuU2VydmljZWAgZXRjLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyZW50QWxyZWFkeUNoZWNrZWQ9ZmFsc2VdIElmIGtub3duLCB3aGV0aGVyIHRoZSBwYXJlbnQgaGFzIGFscmVhZHkgYmVlbiBjaGVja2VkXG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdHxudWxsfSBMb29rZWQgdXAgb2JqZWN0IG9yIGBudWxsYCBpZiBub25lIGNvdWxkIGJlIGZvdW5kXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gbG9va3VwKHBhdGgsIGZpbHRlclR5cGVzLCBwYXJlbnRBbHJlYWR5Q2hlY2tlZCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGZpbHRlclR5cGVzID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBwYXJlbnRBbHJlYWR5Q2hlY2tlZCA9IGZpbHRlclR5cGVzO1xuICAgICAgICBmaWx0ZXJUeXBlcyA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKGZpbHRlclR5cGVzICYmICFBcnJheS5pc0FycmF5KGZpbHRlclR5cGVzKSlcbiAgICAgICAgZmlsdGVyVHlwZXMgPSBbIGZpbHRlclR5cGVzIF07XG5cbiAgICBpZiAodXRpbC5pc1N0cmluZyhwYXRoKSAmJiBwYXRoLmxlbmd0aCkge1xuICAgICAgICBpZiAocGF0aCA9PT0gXCIuXCIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290O1xuICAgICAgICBwYXRoID0gcGF0aC5zcGxpdChcIi5cIik7XG4gICAgfSBlbHNlIGlmICghcGF0aC5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgLy8gU3RhcnQgYXQgcm9vdCBpZiBwYXRoIGlzIGFic29sdXRlXG4gICAgaWYgKHBhdGhbMF0gPT09IFwiXCIpXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QubG9va3VwKHBhdGguc2xpY2UoMSksIGZpbHRlclR5cGVzKTtcblxuICAgIC8vIFRlc3QgaWYgdGhlIGZpcnN0IHBhcnQgbWF0Y2hlcyBhbnkgbmVzdGVkIG9iamVjdCwgYW5kIGlmIHNvLCB0cmF2ZXJzZSBpZiBwYXRoIGNvbnRhaW5zIG1vcmVcbiAgICB2YXIgZm91bmQgPSB0aGlzLmdldChwYXRoWzBdKTtcbiAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlclR5cGVzIHx8IGZpbHRlclR5cGVzLmluZGV4T2YoZm91bmQuY29uc3RydWN0b3IpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9IGVsc2UgaWYgKGZvdW5kIGluc3RhbmNlb2YgTmFtZXNwYWNlICYmIChmb3VuZCA9IGZvdW5kLmxvb2t1cChwYXRoLnNsaWNlKDEpLCBmaWx0ZXJUeXBlcywgdHJ1ZSkpKVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuXG4gICAgLy8gT3RoZXJ3aXNlIHRyeSBlYWNoIG5lc3RlZCBuYW1lc3BhY2VcbiAgICB9IGVsc2VcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5lc3RlZEFycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHRoaXMuX25lc3RlZEFycmF5W2ldIGluc3RhbmNlb2YgTmFtZXNwYWNlICYmIChmb3VuZCA9IHRoaXMuX25lc3RlZEFycmF5W2ldLmxvb2t1cChwYXRoLCBmaWx0ZXJUeXBlcywgdHJ1ZSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcblxuICAgIC8vIElmIHRoZXJlIGhhc24ndCBiZWVuIGEgbWF0Y2gsIHRyeSBhZ2FpbiBhdCB0aGUgcGFyZW50XG4gICAgaWYgKHRoaXMucGFyZW50ID09PSBudWxsIHx8IHBhcmVudEFscmVhZHlDaGVja2VkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQubG9va3VwKHBhdGgsIGZpbHRlclR5cGVzKTtcbn07XG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHJlZmxlY3Rpb24gb2JqZWN0IGF0IHRoZSBzcGVjaWZpZWQgcGF0aCwgcmVsYXRpdmUgdG8gdGhpcyBuYW1lc3BhY2UuXG4gKiBAbmFtZSBOYW1lc3BhY2VCYXNlI2xvb2t1cFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmVudEFscmVhZHlDaGVja2VkPWZhbHNlXSBXaGV0aGVyIHRoZSBwYXJlbnQgaGFzIGFscmVhZHkgYmVlbiBjaGVja2VkXG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdHxudWxsfSBMb29rZWQgdXAgb2JqZWN0IG9yIGBudWxsYCBpZiBub25lIGNvdWxkIGJlIGZvdW5kXG4gKiBAdmFyaWF0aW9uIDJcbiAqL1xuLy8gbG9va3VwKHBhdGg6IHN0cmluZywgW3BhcmVudEFscmVhZHlDaGVja2VkOiBib29sZWFuXSlcblxuLyoqXG4gKiBMb29rcyB1cCB0aGUge0BsaW5rIFR5cGV8dHlwZX0gYXQgdGhlIHNwZWNpZmllZCBwYXRoLCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEJlc2lkZXMgaXRzIHNpZ25hdHVyZSwgdGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2xvb2t1cHxsb29rdXB9IGluIHRoYXQgaXQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHJldHVybnMge1R5cGV9IExvb2tlZCB1cCB0eXBlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBhdGhgIGRvZXMgbm90IHBvaW50IHRvIGEgdHlwZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cFR5cGUgPSBmdW5jdGlvbiBsb29rdXBUeXBlKHBhdGgpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmxvb2t1cChwYXRoLCBbIFR5cGUgXSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIHR5cGU6IFwiICsgcGF0aCk7XG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuLyoqXG4gKiBMb29rcyB1cCB0aGUgdmFsdWVzIG9mIHRoZSB7QGxpbmsgRW51bXxlbnVtfSBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQmVzaWRlcyBpdHMgc2lnbmF0dXJlLCB0aGlzIG1ldGhvZHMgZGlmZmVycyBmcm9tIHtAbGluayBOYW1lc3BhY2UjbG9va3VwfGxvb2t1cH0gaW4gdGhhdCBpdCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7RW51bX0gTG9va2VkIHVwIGVudW1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgcGF0aGAgZG9lcyBub3QgcG9pbnQgdG8gYW4gZW51bVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cEVudW0gPSBmdW5jdGlvbiBsb29rdXBFbnVtKHBhdGgpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmxvb2t1cChwYXRoLCBbIEVudW0gXSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIEVudW0gJ1wiICsgcGF0aCArIFwiJyBpbiBcIiArIHRoaXMpO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHtAbGluayBUeXBlfHR5cGV9IG9yIHtAbGluayBFbnVtfGVudW19IGF0IHRoZSBzcGVjaWZpZWQgcGF0aCwgcmVsYXRpdmUgdG8gdGhpcyBuYW1lc3BhY2UuXG4gKiBCZXNpZGVzIGl0cyBzaWduYXR1cmUsIHRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNsb29rdXB8bG9va3VwfSBpbiB0aGF0IGl0IHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEByZXR1cm5zIHtUeXBlfSBMb29rZWQgdXAgdHlwZSBvciBlbnVtXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBhdGhgIGRvZXMgbm90IHBvaW50IHRvIGEgdHlwZSBvciBlbnVtXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUubG9va3VwVHlwZU9yRW51bSA9IGZ1bmN0aW9uIGxvb2t1cFR5cGVPckVudW0ocGF0aCkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMubG9va3VwKHBhdGgsIFsgVHlwZSwgRW51bSBdKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggVHlwZSBvciBFbnVtICdcIiArIHBhdGggKyBcIicgaW4gXCIgKyB0aGlzKTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG4vKipcbiAqIExvb2tzIHVwIHRoZSB7QGxpbmsgU2VydmljZXxzZXJ2aWNlfSBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQmVzaWRlcyBpdHMgc2lnbmF0dXJlLCB0aGlzIG1ldGhvZHMgZGlmZmVycyBmcm9tIHtAbGluayBOYW1lc3BhY2UjbG9va3VwfGxvb2t1cH0gaW4gdGhhdCBpdCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7U2VydmljZX0gTG9va2VkIHVwIHNlcnZpY2VcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgcGF0aGAgZG9lcyBub3QgcG9pbnQgdG8gYSBzZXJ2aWNlXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUubG9va3VwU2VydmljZSA9IGZ1bmN0aW9uIGxvb2t1cFNlcnZpY2UocGF0aCkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMubG9va3VwKHBhdGgsIFsgU2VydmljZSBdKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggU2VydmljZSAnXCIgKyBwYXRoICsgXCInIGluIFwiICsgdGhpcyk7XG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuLy8gU2V0cyB1cCBjeWNsaWMgZGVwZW5kZW5jaWVzIChjYWxsZWQgaW4gaW5kZXgtbGlnaHQpXG5OYW1lc3BhY2UuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKFR5cGVfLCBTZXJ2aWNlXywgRW51bV8pIHtcbiAgICBUeXBlICAgID0gVHlwZV87XG4gICAgU2VydmljZSA9IFNlcnZpY2VfO1xuICAgIEVudW0gICAgPSBFbnVtXztcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIk5hbWVzcGFjZSIsIlJlZmxlY3Rpb25PYmplY3QiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJjbGFzc05hbWUiLCJGaWVsZCIsInV0aWwiLCJPbmVPZiIsIlR5cGUiLCJTZXJ2aWNlIiwiRW51bSIsImZyb21KU09OIiwibmFtZSIsImpzb24iLCJvcHRpb25zIiwiYWRkSlNPTiIsIm5lc3RlZCIsImFycmF5VG9KU09OIiwiYXJyYXkiLCJ0b0pTT05PcHRpb25zIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwib2JqIiwiaSIsInRvSlNPTiIsImlzUmVzZXJ2ZWRJZCIsInJlc2VydmVkIiwiaWQiLCJpc1Jlc2VydmVkTmFtZSIsImNhbGwiLCJfbmVzdGVkQXJyYXkiLCJjbGVhckNhY2hlIiwibmFtZXNwYWNlIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJ0b0FycmF5IiwidG9PYmplY3QiLCJuZXN0ZWRBcnJheSIsIm5lc3RlZEpzb24iLCJucyIsIm5hbWVzIiwia2V5cyIsImFkZCIsImZpZWxkcyIsInZhbHVlcyIsIm1ldGhvZHMiLCJnZXRFbnVtIiwiRXJyb3IiLCJvYmplY3QiLCJleHRlbmQiLCJUeXBlRXJyb3IiLCJwcmV2IiwicmVtb3ZlIiwic2V0T3B0aW9ucyIsIm9uQWRkIiwicGFyZW50Iiwib25SZW1vdmUiLCJkZWZpbmUiLCJwYXRoIiwiaXNTdHJpbmciLCJzcGxpdCIsIkFycmF5IiwiaXNBcnJheSIsInB0ciIsInBhcnQiLCJzaGlmdCIsInJlc29sdmVBbGwiLCJyZXNvbHZlIiwibG9va3VwIiwiZmlsdGVyVHlwZXMiLCJwYXJlbnRBbHJlYWR5Q2hlY2tlZCIsInJvb3QiLCJzbGljZSIsImZvdW5kIiwiaW5kZXhPZiIsImxvb2t1cFR5cGUiLCJsb29rdXBFbnVtIiwibG9va3VwVHlwZU9yRW51bSIsImxvb2t1cFNlcnZpY2UiLCJfY29uZmlndXJlIiwiVHlwZV8iLCJTZXJ2aWNlXyIsIkVudW1fIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/namespace.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/object.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/object.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = ReflectionObject;\nReflectionObject.className = \"ReflectionObject\";\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\");\nvar Root; // cyclic\n/**\n * Constructs a new reflection object instance.\n * @classdesc Base class of all reflection objects.\n * @constructor\n * @param {string} name Object name\n * @param {Object.<string,*>} [options] Declared options\n * @abstract\n */ function ReflectionObject(name, options) {\n    if (!util.isString(name)) throw TypeError(\"name must be a string\");\n    if (options && !util.isObject(options)) throw TypeError(\"options must be an object\");\n    /**\n     * Options.\n     * @type {Object.<string,*>|undefined}\n     */ this.options = options; // toJSON\n    /**\n     * Parsed Options.\n     * @type {Array.<Object.<string,*>>|undefined}\n     */ this.parsedOptions = null;\n    /**\n     * Unique name within its namespace.\n     * @type {string}\n     */ this.name = name;\n    /**\n     * Parent namespace.\n     * @type {Namespace|null}\n     */ this.parent = null;\n    /**\n     * Whether already resolved or not.\n     * @type {boolean}\n     */ this.resolved = false;\n    /**\n     * Comment text, if any.\n     * @type {string|null}\n     */ this.comment = null;\n    /**\n     * Defining file name.\n     * @type {string|null}\n     */ this.filename = null;\n}\nObject.defineProperties(ReflectionObject.prototype, {\n    /**\n     * Reference to the root namespace.\n     * @name ReflectionObject#root\n     * @type {Root}\n     * @readonly\n     */ root: {\n        get: function() {\n            var ptr = this;\n            while(ptr.parent !== null)ptr = ptr.parent;\n            return ptr;\n        }\n    },\n    /**\n     * Full name including leading dot.\n     * @name ReflectionObject#fullName\n     * @type {string}\n     * @readonly\n     */ fullName: {\n        get: function() {\n            var path = [\n                this.name\n            ], ptr = this.parent;\n            while(ptr){\n                path.unshift(ptr.name);\n                ptr = ptr.parent;\n            }\n            return path.join(\".\");\n        }\n    }\n});\n/**\n * Converts this reflection object to its descriptor representation.\n * @returns {Object.<string,*>} Descriptor\n * @abstract\n */ ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {\n    throw Error(); // not implemented, shouldn't happen\n};\n/**\n * Called when this object is added to a parent.\n * @param {ReflectionObject} parent Parent added to\n * @returns {undefined}\n */ ReflectionObject.prototype.onAdd = function onAdd(parent) {\n    if (this.parent && this.parent !== parent) this.parent.remove(this);\n    this.parent = parent;\n    this.resolved = false;\n    var root = parent.root;\n    if (root instanceof Root) root._handleAdd(this);\n};\n/**\n * Called when this object is removed from a parent.\n * @param {ReflectionObject} parent Parent removed from\n * @returns {undefined}\n */ ReflectionObject.prototype.onRemove = function onRemove(parent) {\n    var root = parent.root;\n    if (root instanceof Root) root._handleRemove(this);\n    this.parent = null;\n    this.resolved = false;\n};\n/**\n * Resolves this objects type references.\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.resolve = function resolve() {\n    if (this.resolved) return this;\n    if (this.root instanceof Root) this.resolved = true; // only if part of a root\n    return this;\n};\n/**\n * Gets an option value.\n * @param {string} name Option name\n * @returns {*} Option value or `undefined` if not set\n */ ReflectionObject.prototype.getOption = function getOption(name) {\n    if (this.options) return this.options[name];\n    return undefined;\n};\n/**\n * Sets an option.\n * @param {string} name Option name\n * @param {*} value Option value\n * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (!ifNotSet || !this.options || this.options[name] === undefined) (this.options || (this.options = {}))[name] = value;\n    return this;\n};\n/**\n * Sets a parsed option.\n * @param {string} name parsed Option name\n * @param {*} value Option value\n * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\n    if (!this.parsedOptions) {\n        this.parsedOptions = [];\n    }\n    var parsedOptions = this.parsedOptions;\n    if (propName) {\n        // If setting a sub property of an option then try to merge it\n        // with an existing option\n        var opt = parsedOptions.find(function(opt) {\n            return Object.prototype.hasOwnProperty.call(opt, name);\n        });\n        if (opt) {\n            // If we found an existing option - just merge the property value\n            var newValue = opt[name];\n            util.setProperty(newValue, propName, value);\n        } else {\n            // otherwise, create a new option, set it's property and add it to the list\n            opt = {};\n            opt[name] = util.setProperty({}, propName, value);\n            parsedOptions.push(opt);\n        }\n    } else {\n        // Always create a new option when setting the value of the option itself\n        var newOpt = {};\n        newOpt[name] = value;\n        parsedOptions.push(newOpt);\n    }\n    return this;\n};\n/**\n * Sets multiple options.\n * @param {Object.<string,*>} options Options to set\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n    if (options) for(var keys = Object.keys(options), i = 0; i < keys.length; ++i)this.setOption(keys[i], options[keys[i]], ifNotSet);\n    return this;\n};\n/**\n * Converts this instance to its string representation.\n * @returns {string} Class name[, space, full name]\n */ ReflectionObject.prototype.toString = function toString() {\n    var className = this.constructor.className, fullName = this.fullName;\n    if (fullName.length) return className + \" \" + fullName;\n    return className;\n};\n// Sets up cyclic dependencies (called in index-light)\nReflectionObject._configure = function(Root_) {\n    Root = Root_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvb2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakJBLGlCQUFpQkMsU0FBUyxHQUFHO0FBRTdCLElBQUlDLE9BQU9DLG1CQUFPQSxDQUFDLDJEQUFRO0FBRTNCLElBQUlDLE1BQU0sU0FBUztBQUVuQjs7Ozs7OztDQU9DLEdBQ0QsU0FBU0osaUJBQWlCSyxJQUFJLEVBQUVDLE9BQU87SUFFbkMsSUFBSSxDQUFDSixLQUFLSyxRQUFRLENBQUNGLE9BQ2YsTUFBTUcsVUFBVTtJQUVwQixJQUFJRixXQUFXLENBQUNKLEtBQUtPLFFBQVEsQ0FBQ0gsVUFDMUIsTUFBTUUsVUFBVTtJQUVwQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNGLE9BQU8sR0FBR0EsU0FBUyxTQUFTO0lBRWpDOzs7S0FHQyxHQUNELElBQUksQ0FBQ0ksYUFBYSxHQUFHO0lBRXJCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0wsSUFBSSxHQUFHQTtJQUVaOzs7S0FHQyxHQUNELElBQUksQ0FBQ00sTUFBTSxHQUFHO0lBRWQ7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFFaEI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFFZjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBRztBQUNwQjtBQUVBQyxPQUFPQyxnQkFBZ0IsQ0FBQ2hCLGlCQUFpQmlCLFNBQVMsRUFBRTtJQUVoRDs7Ozs7S0FLQyxHQUNEQyxNQUFNO1FBQ0ZDLEtBQUs7WUFDRCxJQUFJQyxNQUFNLElBQUk7WUFDZCxNQUFPQSxJQUFJVCxNQUFNLEtBQUssS0FDbEJTLE1BQU1BLElBQUlULE1BQU07WUFDcEIsT0FBT1M7UUFDWDtJQUNKO0lBRUE7Ozs7O0tBS0MsR0FDREMsVUFBVTtRQUNORixLQUFLO1lBQ0QsSUFBSUcsT0FBTztnQkFBRSxJQUFJLENBQUNqQixJQUFJO2FBQUUsRUFDcEJl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bm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL29iamVjdC5qcz84Mjg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0aW9uT2JqZWN0O1xuXG5SZWZsZWN0aW9uT2JqZWN0LmNsYXNzTmFtZSA9IFwiUmVmbGVjdGlvbk9iamVjdFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBSb290OyAvLyBjeWNsaWNcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlZmxlY3Rpb24gb2JqZWN0IGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBCYXNlIGNsYXNzIG9mIGFsbCByZWZsZWN0aW9uIG9iamVjdHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9iamVjdCBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQGFic3RyYWN0XG4gKi9cbmZ1bmN0aW9uIFJlZmxlY3Rpb25PYmplY3QobmFtZSwgb3B0aW9ucykge1xuXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKG5hbWUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICBpZiAob3B0aW9ucyAmJiAhdXRpbC5pc09iamVjdChvcHRpb25zKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFBhcnNlZCBPcHRpb25zLlxuICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0LjxzdHJpbmcsKj4+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnBhcnNlZE9wdGlvbnMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVW5pcXVlIG5hbWUgd2l0aGluIGl0cyBuYW1lc3BhY2UuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgLyoqXG4gICAgICogUGFyZW50IG5hbWVzcGFjZS5cbiAgICAgKiBAdHlwZSB7TmFtZXNwYWNlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhbHJlYWR5IHJlc29sdmVkIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDb21tZW50IHRleHQsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIERlZmluaW5nIGZpbGUgbmFtZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5maWxlbmFtZSA9IG51bGw7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLCB7XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHJvb3QgbmFtZXNwYWNlLlxuICAgICAqIEBuYW1lIFJlZmxlY3Rpb25PYmplY3Qjcm9vdFxuICAgICAqIEB0eXBlIHtSb290fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHJvb3Q6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwdHIgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKHB0ci5wYXJlbnQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgICAgIHJldHVybiBwdHI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVsbCBuYW1lIGluY2x1ZGluZyBsZWFkaW5nIGRvdC5cbiAgICAgKiBAbmFtZSBSZWZsZWN0aW9uT2JqZWN0I2Z1bGxOYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBmdWxsTmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBbIHRoaXMubmFtZSBdLFxuICAgICAgICAgICAgICAgIHB0ciA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKHB0cikge1xuICAgICAgICAgICAgICAgIHBhdGgudW5zaGlmdChwdHIubmFtZSk7XG4gICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoLmpvaW4oXCIuXCIpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyByZWZsZWN0aW9uIG9iamVjdCB0byBpdHMgZGVzY3JpcHRvciByZXByZXNlbnRhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzY3JpcHRvclxuICogQGFic3RyYWN0XG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnRvSlNPTiA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICB0aHJvdyBFcnJvcigpOyAvLyBub3QgaW1wbGVtZW50ZWQsIHNob3VsZG4ndCBoYXBwZW5cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhpcyBvYmplY3QgaXMgYWRkZWQgdG8gYSBwYXJlbnQuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IHBhcmVudCBQYXJlbnQgYWRkZWQgdG9cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gb25BZGQocGFyZW50KSB7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50ICE9PSBwYXJlbnQpXG4gICAgICAgIHRoaXMucGFyZW50LnJlbW92ZSh0aGlzKTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7XG4gICAgdmFyIHJvb3QgPSBwYXJlbnQucm9vdDtcbiAgICBpZiAocm9vdCBpbnN0YW5jZW9mIFJvb3QpXG4gICAgICAgIHJvb3QuX2hhbmRsZUFkZCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhpcyBvYmplY3QgaXMgcmVtb3ZlZCBmcm9tIGEgcGFyZW50LlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBwYXJlbnQgUGFyZW50IHJlbW92ZWQgZnJvbVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiBvblJlbW92ZShwYXJlbnQpIHtcbiAgICB2YXIgcm9vdCA9IHBhcmVudC5yb290O1xuICAgIGlmIChyb290IGluc3RhbmNlb2YgUm9vdClcbiAgICAgICAgcm9vdC5faGFuZGxlUmVtb3ZlKHRoaXMpO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHRoaXMgb2JqZWN0cyB0eXBlIHJlZmVyZW5jZXMuXG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdH0gYHRoaXNgXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIGlmICh0aGlzLnJlc29sdmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yb290IGluc3RhbmNlb2YgUm9vdClcbiAgICAgICAgdGhpcy5yZXNvbHZlZCA9IHRydWU7IC8vIG9ubHkgaWYgcGFydCBvZiBhIHJvb3RcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0cyBhbiBvcHRpb24gdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPcHRpb24gbmFtZVxuICogQHJldHVybnMgeyp9IE9wdGlvbiB2YWx1ZSBvciBgdW5kZWZpbmVkYCBpZiBub3Qgc2V0XG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLmdldE9wdGlvbiA9IGZ1bmN0aW9uIGdldE9wdGlvbihuYW1lKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucylcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lXTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBTZXRzIGFuIG9wdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9wdGlvbiBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlIE9wdGlvbiB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXRdIFNldHMgdGhlIG9wdGlvbiBvbmx5IGlmIGl0IGlzbid0IGN1cnJlbnRseSBzZXRcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fSBgdGhpc2BcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuc2V0T3B0aW9uID0gZnVuY3Rpb24gc2V0T3B0aW9uKG5hbWUsIHZhbHVlLCBpZk5vdFNldCkge1xuICAgIGlmICghaWZOb3RTZXQgfHwgIXRoaXMub3B0aW9ucyB8fCB0aGlzLm9wdGlvbnNbbmFtZV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgKHRoaXMub3B0aW9ucyB8fCAodGhpcy5vcHRpb25zID0ge30pKVtuYW1lXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcGFyc2VkIG9wdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHBhcnNlZCBPcHRpb24gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBPcHRpb24gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wTmFtZSBkb3QgJy4nIGRlbGltaXRlZCBmdWxsIHBhdGggb2YgcHJvcGVydHkgd2l0aGluIHRoZSBvcHRpb24gdG8gc2V0LiBpZiB1bmRlZmluZWRcXGVtcHR5LCB3aWxsIGFkZCBhIG5ldyBvcHRpb24gd2l0aCB0aGF0IHZhbHVlXG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdH0gYHRoaXNgXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldFBhcnNlZE9wdGlvbiA9IGZ1bmN0aW9uIHNldFBhcnNlZE9wdGlvbihuYW1lLCB2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgICBpZiAoIXRoaXMucGFyc2VkT3B0aW9ucykge1xuICAgICAgICB0aGlzLnBhcnNlZE9wdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgdmFyIHBhcnNlZE9wdGlvbnMgPSB0aGlzLnBhcnNlZE9wdGlvbnM7XG4gICAgaWYgKHByb3BOYW1lKSB7XG4gICAgICAgIC8vIElmIHNldHRpbmcgYSBzdWIgcHJvcGVydHkgb2YgYW4gb3B0aW9uIHRoZW4gdHJ5IHRvIG1lcmdlIGl0XG4gICAgICAgIC8vIHdpdGggYW4gZXhpc3Rpbmcgb3B0aW9uXG4gICAgICAgIHZhciBvcHQgPSBwYXJzZWRPcHRpb25zLmZpbmQoZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHQsIG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYW4gZXhpc3Rpbmcgb3B0aW9uIC0ganVzdCBtZXJnZSB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IG9wdFtuYW1lXTtcbiAgICAgICAgICAgIHV0aWwuc2V0UHJvcGVydHkobmV3VmFsdWUsIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIGNyZWF0ZSBhIG5ldyBvcHRpb24sIHNldCBpdCdzIHByb3BlcnR5IGFuZCBhZGQgaXQgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgIG9wdCA9IHt9O1xuICAgICAgICAgICAgb3B0W25hbWVdID0gdXRpbC5zZXRQcm9wZXJ0eSh7fSwgcHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMucHVzaChvcHQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWx3YXlzIGNyZWF0ZSBhIG5ldyBvcHRpb24gd2hlbiBzZXR0aW5nIHRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIGl0c2VsZlxuICAgICAgICB2YXIgbmV3T3B0ID0ge307XG4gICAgICAgIG5ld09wdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICBwYXJzZWRPcHRpb25zLnB1c2gobmV3T3B0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgbXVsdGlwbGUgb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9wdGlvbnMgT3B0aW9ucyB0byBzZXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0XSBTZXRzIGFuIG9wdGlvbiBvbmx5IGlmIGl0IGlzbid0IGN1cnJlbnRseSBzZXRcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fSBgdGhpc2BcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgaWZOb3RTZXQpIHtcbiAgICBpZiAob3B0aW9ucylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0aGlzLnNldE9wdGlvbihrZXlzW2ldLCBvcHRpb25zW2tleXNbaV1dLCBpZk5vdFNldCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgaW5zdGFuY2UgdG8gaXRzIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IENsYXNzIG5hbWVbLCBzcGFjZSwgZnVsbCBuYW1lXVxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLmNsYXNzTmFtZSxcbiAgICAgICAgZnVsbE5hbWUgID0gdGhpcy5mdWxsTmFtZTtcbiAgICBpZiAoZnVsbE5hbWUubGVuZ3RoKVxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lICsgXCIgXCIgKyBmdWxsTmFtZTtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xufTtcblxuLy8gU2V0cyB1cCBjeWNsaWMgZGVwZW5kZW5jaWVzIChjYWxsZWQgaW4gaW5kZXgtbGlnaHQpXG5SZWZsZWN0aW9uT2JqZWN0Ll9jb25maWd1cmUgPSBmdW5jdGlvbihSb290Xykge1xuICAgIFJvb3QgPSBSb290Xztcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIlJlZmxlY3Rpb25PYmplY3QiLCJjbGFzc05hbWUiLCJ1dGlsIiwicmVxdWlyZSIsIlJvb3QiLCJuYW1lIiwib3B0aW9ucyIsImlzU3RyaW5nIiwiVHlwZUVycm9yIiwiaXNPYmplY3QiLCJwYXJzZWRPcHRpb25zIiwicGFyZW50IiwicmVzb2x2ZWQiLCJjb21tZW50IiwiZmlsZW5hbWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwicm9vdCIsImdldCIsInB0ciIsImZ1bGxOYW1lIiwicGF0aCIsInVuc2hpZnQiLCJqb2luIiwidG9KU09OIiwiRXJyb3IiLCJvbkFkZCIsInJlbW92ZSIsIl9oYW5kbGVBZGQiLCJvblJlbW92ZSIsIl9oYW5kbGVSZW1vdmUiLCJyZXNvbHZlIiwiZ2V0T3B0aW9uIiwidW5kZWZpbmVkIiwic2V0T3B0aW9uIiwidmFsdWUiLCJpZk5vdFNldCIsInNldFBhcnNlZE9wdGlvbiIsInByb3BOYW1lIiwib3B0IiwiZmluZCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm5ld1ZhbHVlIiwic2V0UHJvcGVydHkiLCJwdXNoIiwibmV3T3B0Iiwic2V0T3B0aW9ucyIsImtleXMiLCJpIiwibGVuZ3RoIiwidG9TdHJpbmciLCJjb25zdHJ1Y3RvciIsIl9jb25maWd1cmUiLCJSb290XyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/object.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/oneof.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/oneof.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = OneOf;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/protobufjs/src/object.js\");\n((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = \"OneOf\";\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/protobufjs/src/field.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new oneof instance.\n * @classdesc Reflected oneof.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Oneof name\n * @param {string[]|Object.<string,*>} [fieldNames] Field names\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */ function OneOf(name, fieldNames, options, comment) {\n    if (!Array.isArray(fieldNames)) {\n        options = fieldNames;\n        fieldNames = undefined;\n    }\n    ReflectionObject.call(this, name, options);\n    /* istanbul ignore if */ if (!(fieldNames === undefined || Array.isArray(fieldNames))) throw TypeError(\"fieldNames must be an Array\");\n    /**\n     * Field names that belong to this oneof.\n     * @type {string[]}\n     */ this.oneof = fieldNames || []; // toJSON, marker\n    /**\n     * Fields that belong to this oneof as an array for iteration.\n     * @type {Field[]}\n     * @readonly\n     */ this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */ this.comment = comment;\n}\n/**\n * Oneof descriptor.\n * @interface IOneOf\n * @property {Array.<string>} oneof Oneof field names\n * @property {Object.<string,*>} [options] Oneof options\n */ /**\n * Constructs a oneof from a oneof descriptor.\n * @param {string} name Oneof name\n * @param {IOneOf} json Oneof descriptor\n * @returns {OneOf} Created oneof\n * @throws {TypeError} If arguments are invalid\n */ OneOf.fromJSON = function fromJSON(name, json) {\n    return new OneOf(name, json.oneof, json.options, json.comment);\n};\n/**\n * Converts this oneof to a oneof descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IOneOf} Oneof descriptor\n */ OneOf.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\",\n        this.options,\n        \"oneof\",\n        this.oneof,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * Adds the fields of the specified oneof to the parent if not already done so.\n * @param {OneOf} oneof The oneof\n * @returns {undefined}\n * @inner\n * @ignore\n */ function addFieldsToParent(oneof) {\n    if (oneof.parent) {\n        for(var i = 0; i < oneof.fieldsArray.length; ++i)if (!oneof.fieldsArray[i].parent) oneof.parent.add(oneof.fieldsArray[i]);\n    }\n}\n/**\n * Adds a field to this oneof and removes it from its current parent, if any.\n * @param {Field} field Field to add\n * @returns {OneOf} `this`\n */ OneOf.prototype.add = function add(field) {\n    /* istanbul ignore if */ if (!(field instanceof Field)) throw TypeError(\"field must be a Field\");\n    if (field.parent && field.parent !== this.parent) field.parent.remove(field);\n    this.oneof.push(field.name);\n    this.fieldsArray.push(field);\n    field.partOf = this; // field.parent remains null\n    addFieldsToParent(this);\n    return this;\n};\n/**\n * Removes a field from this oneof and puts it back to the oneof's parent.\n * @param {Field} field Field to remove\n * @returns {OneOf} `this`\n */ OneOf.prototype.remove = function remove(field) {\n    /* istanbul ignore if */ if (!(field instanceof Field)) throw TypeError(\"field must be a Field\");\n    var index = this.fieldsArray.indexOf(field);\n    /* istanbul ignore if */ if (index < 0) throw Error(field + \" is not a member of \" + this);\n    this.fieldsArray.splice(index, 1);\n    index = this.oneof.indexOf(field.name);\n    /* istanbul ignore else */ if (index > -1) this.oneof.splice(index, 1);\n    field.partOf = null;\n    return this;\n};\n/**\n * @override\n */ OneOf.prototype.onAdd = function onAdd(parent) {\n    ReflectionObject.prototype.onAdd.call(this, parent);\n    var self = this;\n    // Collect present fields\n    for(var i = 0; i < this.oneof.length; ++i){\n        var field = parent.get(this.oneof[i]);\n        if (field && !field.partOf) {\n            field.partOf = self;\n            self.fieldsArray.push(field);\n        }\n    }\n    // Add not yet present fields\n    addFieldsToParent(this);\n};\n/**\n * @override\n */ OneOf.prototype.onRemove = function onRemove(parent) {\n    for(var i = 0, field; i < this.fieldsArray.length; ++i)if ((field = this.fieldsArray[i]).parent) field.parent.remove(field);\n    ReflectionObject.prototype.onRemove.call(this, parent);\n};\n/**\n * Decorator function as returned by {@link OneOf.d} (TypeScript).\n * @typedef OneOfDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} oneofName OneOf name\n * @returns {undefined}\n */ /**\n * OneOf decorator (TypeScript).\n * @function\n * @param {...string} fieldNames Field names\n * @returns {OneOfDecorator} Decorator function\n * @template T extends string\n */ OneOf.d = function decorateOneOf() {\n    var fieldNames = new Array(arguments.length), index = 0;\n    while(index < arguments.length)fieldNames[index] = arguments[index++];\n    return function oneOfDecorator(prototype, oneofName) {\n        util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));\n        Object.defineProperty(prototype, oneofName, {\n            get: util.oneOfGetter(fieldNames),\n            set: util.oneOfSetter(fieldNames)\n        });\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvb25lb2YuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQiwyQkFBMkI7QUFDM0IsSUFBSUMsbUJBQW1CQyxtQkFBT0EsQ0FBQywrREFBVTtBQUN4QyxFQUFDRixNQUFNRyxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0osaUJBQWlCRSxTQUFTLEdBQUdHLFdBQVcsR0FBR04sS0FBSSxFQUFHTyxTQUFTLEdBQUc7QUFFaEcsSUFBSUMsUUFBUU4sbUJBQU9BLENBQUMsNkRBQVMsR0FDekJPLE9BQVFQLG1CQUFPQSxDQUFDLDJEQUFRO0FBRTVCOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNGLE1BQU1VLElBQUksRUFBRUMsVUFBVSxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFDN0MsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNKLGFBQWE7UUFDNUJDLFVBQVVEO1FBQ1ZBLGFBQWFLO0lBQ2pCO0lBQ0FmLGlCQUFpQmdCLElBQUksQ0FBQyxJQUFJLEVBQUVQLE1BQU1FO0lBRWxDLHNCQUFzQixHQUN0QixJQUFJLENBQUVELENBQUFBLGVBQWVLLGFBQWFGLE1BQU1DLE9BQU8sQ0FBQ0osV0FBVSxHQUN0RCxNQUFNTyxVQUFVO0lBRXBCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsS0FBSyxHQUFHUixjQUFjLEVBQUUsRUFBRSxpQkFBaUI7SUFFaEQ7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ1MsV0FBVyxHQUFHLEVBQUUsRUFBRSxzRUFBc0U7SUFFN0Y7OztLQUdDLEdBQ0QsSUFBSSxDQUFDUCxPQUFPLEdBQUdBO0FBQ25CO0FBRUE7Ozs7O0NBS0MsR0FFRDs7Ozs7O0NBTUMsR0FDRGIsTUFBTXFCLFFBQVEsR0FBRyxTQUFTQSxTQUFTWCxJQUFJLEVBQUVZLElBQUk7SUFDekMsT0FBTyxJQUFJdEIsTUFBTVUsTUFBTVksS0FBS0gsS0FBSyxFQUFFRyxLQUFLVixPQUFPLEVB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QUNBLDZCQUE2QjtJQUM3Qkwsa0JBQWtCLElBQUk7QUFDMUI7QUFFQTs7Q0FFQyxHQUNENUIsTUFBTUcsU0FBUyxDQUFDeUMsUUFBUSxHQUFHLFNBQVNBLFNBQVNmLE1BQU07SUFDL0MsSUFBSyxJQUFJQyxJQUFJLEdBQUdHLE9BQU9ILElBQUksSUFBSSxDQUFDVixXQUFXLENBQUNXLE1BQU0sRUFBRSxFQUFFRCxFQUNsRCxJQUFJLENBQUNHLFFBQVEsSUFBSSxDQUFDYixXQUFXLENBQUNVLEVBQUUsRUFBRUQsTUFBTSxFQUNwQ0ksTUFBTUosTUFBTSxDQUFDSyxNQUFNLENBQUNEO0lBQzVCaEMsaUJBQWlCRSxTQUFTLENBQUN5QyxRQUFRLENBQUMzQixJQUFJLENBQUMsSUFBSSxFQUFFWTtBQUNuRDtBQUVBOzs7Ozs7O0NBT0MsR0FFRDs7Ozs7O0NBTUMsR0FDRDdCLE1BQU02QyxDQUFDLEdBQUcsU0FBU0M7SUFDZixJQUFJbkMsYUFBYSxJQUFJRyxNQUFNaUMsVUFBVWhCLE1BQU0sR0FDdkNNLFFBQVE7SUFDWixNQUFPQSxRQUFRVSxVQUFVaEIsTUFBTSxDQUMzQnBCLFVBQVUsQ0FBQzBCLE1BQU0sR0FBR1UsU0FBUyxDQUFDVixRQUFRO0lBQzFDLE9BQU8sU0FBU1csZUFBZTdDLFNBQVMsRUFBRThDLFNBQVM7UUFDL0N4QyxLQUFLeUMsWUFBWSxDQUFDL0MsVUFBVUcsV0FBVyxFQUNsQzBCLEdBQUcsQ0FBQyxJQUFJaEMsTUFBTWlELFdBQVd0QztRQUM5QlAsT0FBTytDLGNBQWMsQ0FBQ2hELFdBQVc4QyxXQUFXO1lBQ3hDTixLQUFLbEMsS0FBSzJDLFdBQVcsQ0FBQ3pDO1lBQ3RCMEMsS0FBSzVDLEtBQUs2QyxXQUFXLENBQUMzQztRQUMxQjtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL29uZW9mLmpzPzE1NmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE9uZU9mO1xuXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuKChPbmVPZi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBPbmVPZikuY2xhc3NOYW1lID0gXCJPbmVPZlwiO1xuXG52YXIgRmllbGQgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICB1dGlsICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBvbmVvZiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIG9uZW9mLlxuICogQGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPbmVvZiBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ1tdfE9iamVjdC48c3RyaW5nLCo+fSBbZmllbGROYW1lc10gRmllbGQgbmFtZXNcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZmllbGRcbiAqL1xuZnVuY3Rpb24gT25lT2YobmFtZSwgZmllbGROYW1lcywgb3B0aW9ucywgY29tbWVudCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShmaWVsZE5hbWVzKSkge1xuICAgICAgICBvcHRpb25zID0gZmllbGROYW1lcztcbiAgICAgICAgZmllbGROYW1lcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgUmVmbGVjdGlvbk9iamVjdC5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCEoZmllbGROYW1lcyA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkoZmllbGROYW1lcykpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJmaWVsZE5hbWVzIG11c3QgYmUgYW4gQXJyYXlcIik7XG5cbiAgICAvKipcbiAgICAgKiBGaWVsZCBuYW1lcyB0aGF0IGJlbG9uZyB0byB0aGlzIG9uZW9mLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICB0aGlzLm9uZW9mID0gZmllbGROYW1lcyB8fCBbXTsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIEZpZWxkcyB0aGF0IGJlbG9uZyB0byB0aGlzIG9uZW9mIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gICAgICogQHR5cGUge0ZpZWxkW119XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5maWVsZHNBcnJheSA9IFtdOyAvLyBkZWNsYXJlZCByZWFkb25seSBmb3IgY29uZm9ybWFuY2UsIHBvc3NpYmx5IG5vdCB5ZXQgYWRkZWQgdG8gcGFyZW50XG5cbiAgICAvKipcbiAgICAgKiBDb21tZW50IGZvciB0aGlzIGZpZWxkLlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbW1lbnQgPSBjb21tZW50O1xufVxuXG4vKipcbiAqIE9uZW9mIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElPbmVPZlxuICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPn0gb25lb2YgT25lb2YgZmllbGQgbmFtZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBPbmVvZiBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgb25lb2YgZnJvbSBhIG9uZW9mIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPbmVvZiBuYW1lXG4gKiBAcGFyYW0ge0lPbmVPZn0ganNvbiBPbmVvZiBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7T25lT2Z9IENyZWF0ZWQgb25lb2ZcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbk9uZU9mLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgT25lT2YobmFtZSwganNvbi5vbmVvZiwganNvbi5vcHRpb25zLCBqc29uLmNvbW1lbnQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG9uZW9mIHRvIGEgb25lb2YgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lPbmVPZn0gT25lb2YgZGVzY3JpcHRvclxuICovXG5PbmVPZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcIm9wdGlvbnNcIiAsIHRoaXMub3B0aW9ucyxcbiAgICAgICAgXCJvbmVvZlwiICAgLCB0aGlzLm9uZW9mLFxuICAgICAgICBcImNvbW1lbnRcIiAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBBZGRzIHRoZSBmaWVsZHMgb2YgdGhlIHNwZWNpZmllZCBvbmVvZiB0byB0aGUgcGFyZW50IGlmIG5vdCBhbHJlYWR5IGRvbmUgc28uXG4gKiBAcGFyYW0ge09uZU9mfSBvbmVvZiBUaGUgb25lb2ZcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAaW5uZXJcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gYWRkRmllbGRzVG9QYXJlbnQob25lb2YpIHtcbiAgICBpZiAob25lb2YucGFyZW50KVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9uZW9mLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKCFvbmVvZi5maWVsZHNBcnJheVtpXS5wYXJlbnQpXG4gICAgICAgICAgICAgICAgb25lb2YucGFyZW50LmFkZChvbmVvZi5maWVsZHNBcnJheVtpXSk7XG59XG5cbi8qKlxuICogQWRkcyBhIGZpZWxkIHRvIHRoaXMgb25lb2YgYW5kIHJlbW92ZXMgaXQgZnJvbSBpdHMgY3VycmVudCBwYXJlbnQsIGlmIGFueS5cbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIEZpZWxkIHRvIGFkZFxuICogQHJldHVybnMge09uZU9mfSBgdGhpc2BcbiAqL1xuT25lT2YucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChmaWVsZCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBGaWVsZCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImZpZWxkIG11c3QgYmUgYSBGaWVsZFwiKTtcblxuICAgIGlmIChmaWVsZC5wYXJlbnQgJiYgZmllbGQucGFyZW50ICE9PSB0aGlzLnBhcmVudClcbiAgICAgICAgZmllbGQucGFyZW50LnJlbW92ZShmaWVsZCk7XG4gICAgdGhpcy5vbmVvZi5wdXNoKGZpZWxkLm5hbWUpO1xuICAgIHRoaXMuZmllbGRzQXJyYXkucHVzaChmaWVsZCk7XG4gICAgZmllbGQucGFydE9mID0gdGhpczsgLy8gZmllbGQucGFyZW50IHJlbWFpbnMgbnVsbFxuICAgIGFkZEZpZWxkc1RvUGFyZW50KHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgZmllbGQgZnJvbSB0aGlzIG9uZW9mIGFuZCBwdXRzIGl0IGJhY2sgdG8gdGhlIG9uZW9mJ3MgcGFyZW50LlxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgRmllbGQgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB7T25lT2Z9IGB0aGlzYFxuICovXG5PbmVPZi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGZpZWxkKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIEZpZWxkKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZmllbGQgbXVzdCBiZSBhIEZpZWxkXCIpO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5maWVsZHNBcnJheS5pbmRleE9mKGZpZWxkKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgIHRocm93IEVycm9yKGZpZWxkICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICB0aGlzLmZpZWxkc0FycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgaW5kZXggPSB0aGlzLm9uZW9mLmluZGV4T2YoZmllbGQubmFtZSk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbmRleCA+IC0xKSAvLyB0aGVvcmV0aWNhbFxuICAgICAgICB0aGlzLm9uZW9mLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBmaWVsZC5wYXJ0T2YgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuT25lT2YucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gb25BZGQocGFyZW50KSB7XG4gICAgUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBDb2xsZWN0IHByZXNlbnQgZmllbGRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9uZW9mLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHBhcmVudC5nZXQodGhpcy5vbmVvZltpXSk7XG4gICAgICAgIGlmIChmaWVsZCAmJiAhZmllbGQucGFydE9mKSB7XG4gICAgICAgICAgICBmaWVsZC5wYXJ0T2YgPSBzZWxmO1xuICAgICAgICAgICAgc2VsZi5maWVsZHNBcnJheS5wdXNoKGZpZWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgbm90IHlldCBwcmVzZW50IGZpZWxkc1xuICAgIGFkZEZpZWxkc1RvUGFyZW50KHRoaXMpO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuT25lT2YucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gb25SZW1vdmUocGFyZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGZpZWxkOyBpIDwgdGhpcy5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKChmaWVsZCA9IHRoaXMuZmllbGRzQXJyYXlbaV0pLnBhcmVudClcbiAgICAgICAgICAgIGZpZWxkLnBhcmVudC5yZW1vdmUoZmllbGQpO1xuICAgIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgcGFyZW50KTtcbn07XG5cbi8qKlxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIGFzIHJldHVybmVkIGJ5IHtAbGluayBPbmVPZi5kfSAoVHlwZVNjcmlwdCkuXG4gKiBAdHlwZWRlZiBPbmVPZkRlY29yYXRvclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUYXJnZXQgcHJvdG90eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gb25lb2ZOYW1lIE9uZU9mIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBPbmVPZiBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mRGVjb3JhdG9yfSBEZWNvcmF0b3IgZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgc3RyaW5nXG4gKi9cbk9uZU9mLmQgPSBmdW5jdGlvbiBkZWNvcmF0ZU9uZU9mKCkge1xuICAgIHZhciBmaWVsZE5hbWVzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpLFxuICAgICAgICBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgZmllbGROYW1lc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uZU9mRGVjb3JhdG9yKHByb3RvdHlwZSwgb25lb2ZOYW1lKSB7XG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHByb3RvdHlwZS5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgIC5hZGQobmV3IE9uZU9mKG9uZW9mTmFtZSwgZmllbGROYW1lcykpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBvbmVvZk5hbWUsIHtcbiAgICAgICAgICAgIGdldDogdXRpbC5vbmVPZkdldHRlcihmaWVsZE5hbWVzKSxcbiAgICAgICAgICAgIHNldDogdXRpbC5vbmVPZlNldHRlcihmaWVsZE5hbWVzKVxuICAgICAgICB9KTtcbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiT25lT2YiLCJSZWZsZWN0aW9uT2JqZWN0IiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiY2xhc3NOYW1lIiwiRmllbGQiLCJ1dGlsIiwibmFtZSIsImZpZWxkTmFtZXMiLCJvcHRpb25zIiwiY29tbWVudCIsIkFycmF5IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsImNhbGwiLCJUeXBlRXJyb3IiLCJvbmVvZiIsImZpZWxkc0FycmF5IiwiZnJvbUpTT04iLCJqc29uIiwidG9KU09OIiwidG9KU09OT3B0aW9ucyIsImtlZXBDb21tZW50cyIsIkJvb2xlYW4iLCJ0b09iamVjdCIsImFkZEZpZWxkc1RvUGFyZW50IiwicGFyZW50IiwiaSIsImxlbmd0aCIsImFkZCIsImZpZWxkIiwicmVtb3ZlIiwicHVzaCIsInBhcnRPZiIsImluZGV4IiwiaW5kZXhPZiIsIkVycm9yIiwic3BsaWNlIiwib25BZGQiLCJzZWxmIiwiZ2V0Iiwib25SZW1vdmUiLCJkIiwiZGVjb3JhdGVPbmVPZiIsImFyZ3VtZW50cyIsIm9uZU9mRGVjb3JhdG9yIiwib25lb2ZOYW1lIiwiZGVjb3JhdGVUeXBlIiwiZGVmaW5lUHJvcGVydHkiLCJvbmVPZkdldHRlciIsInNldCIsIm9uZU9mU2V0dGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/oneof.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/parse.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/parse.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = parse;\nparse.filename = null;\nparse.defaults = {\n    keepCase: false\n};\nvar tokenize = __webpack_require__(/*! ./tokenize */ \"(ssr)/./node_modules/protobufjs/src/tokenize.js\"), Root = __webpack_require__(/*! ./root */ \"(ssr)/./node_modules/protobufjs/src/root.js\"), Type = __webpack_require__(/*! ./type */ \"(ssr)/./node_modules/protobufjs/src/type.js\"), Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/protobufjs/src/field.js\"), MapField = __webpack_require__(/*! ./mapfield */ \"(ssr)/./node_modules/protobufjs/src/mapfield.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/protobufjs/src/oneof.js\"), Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/protobufjs/src/enum.js\"), Service = __webpack_require__(/*! ./service */ \"(ssr)/./node_modules/protobufjs/src/service.js\"), Method = __webpack_require__(/*! ./method */ \"(ssr)/./node_modules/protobufjs/src/method.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\");\nvar base10Re = /^[1-9][0-9]*$/, base10NegRe = /^-?[1-9][0-9]*$/, base16Re = /^0[x][0-9a-fA-F]+$/, base16NegRe = /^-?0[x][0-9a-fA-F]+$/, base8Re = /^0[0-7]+$/, base8NegRe = /^-?0[0-7]+$/, numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/, nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/, typeRefRe = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/, fqTypeRefRe = /^(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;\n/**\n * Result object returned from {@link parse}.\n * @interface IParserResult\n * @property {string|undefined} package Package name, if declared\n * @property {string[]|undefined} imports Imports, if any\n * @property {string[]|undefined} weakImports Weak imports, if any\n * @property {string|undefined} syntax Syntax, if specified (either `\"proto2\"` or `\"proto3\"`)\n * @property {Root} root Populated root instance\n */ /**\n * Options modifying the behavior of {@link parse}.\n * @interface IParseOptions\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\n * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.\n */ /**\n * Options modifying the behavior of JSON serialization.\n * @interface IToJSONOptions\n * @property {boolean} [keepComments=false] Serializes comments.\n */ /**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @param {string} source Source contents\n * @param {Root} root Root to populate\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n */ function parse(source, root, options) {\n    /* eslint-disable callback-return */ if (!(root instanceof Root)) {\n        options = root;\n        root = new Root();\n    }\n    if (!options) options = parse.defaults;\n    var preferTrailingComment = options.preferTrailingComment || false;\n    var tn = tokenize(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;\n    var head = true, pkg, imports, weakImports, syntax, isProto3 = false;\n    var ptr = root;\n    var applyCase = options.keepCase ? function(name) {\n        return name;\n    } : util.camelCase;\n    /* istanbul ignore next */ function illegal(token, name, insideTryCatch) {\n        var filename = parse.filename;\n        if (!insideTryCatch) parse.filename = null;\n        return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\n    }\n    function readString() {\n        var values = [], token;\n        do {\n            /* istanbul ignore if */ if ((token = next()) !== '\"' && token !== \"'\") throw illegal(token);\n            values.push(next());\n            skip(token);\n            token = peek();\n        }while (token === '\"' || token === \"'\");\n        return values.join(\"\");\n    }\n    function readValue(acceptTypeRef) {\n        var token = next();\n        switch(token){\n            case \"'\":\n            case '\"':\n                push(token);\n                return readString();\n            case \"true\":\n            case \"TRUE\":\n                return true;\n            case \"false\":\n            case \"FALSE\":\n                return false;\n        }\n        try {\n            return parseNumber(token, /* insideTryCatch */ true);\n        } catch (e) {\n            /* istanbul ignore else */ if (acceptTypeRef && typeRefRe.test(token)) return token;\n            /* istanbul ignore next */ throw illegal(token, \"value\");\n        }\n    }\n    function readRanges(target, acceptStrings) {\n        var token, start;\n        do {\n            if (acceptStrings && ((token = peek()) === '\"' || token === \"'\")) target.push(readString());\n            else target.push([\n                start = parseId(next()),\n                skip(\"to\", true) ? parseId(next()) : start\n            ]);\n        }while (skip(\",\", true));\n        skip(\";\");\n    }\n    function parseNumber(token, insideTryCatch) {\n        var sign = 1;\n        if (token.charAt(0) === \"-\") {\n            sign = -1;\n            token = token.substring(1);\n        }\n        switch(token){\n            case \"inf\":\n            case \"INF\":\n            case \"Inf\":\n                return sign * Infinity;\n            case \"nan\":\n            case \"NAN\":\n            case \"Nan\":\n            case \"NaN\":\n                return NaN;\n            case \"0\":\n                return 0;\n        }\n        if (base10Re.test(token)) return sign * parseInt(token, 10);\n        if (base16Re.test(token)) return sign * parseInt(token, 16);\n        if (base8Re.test(token)) return sign * parseInt(token, 8);\n        /* istanbul ignore else */ if (numberRe.test(token)) return sign * parseFloat(token);\n        /* istanbul ignore next */ throw illegal(token, \"number\", insideTryCatch);\n    }\n    function parseId(token, acceptNegative) {\n        switch(token){\n            case \"max\":\n            case \"MAX\":\n            case \"Max\":\n                return 536870911;\n            case \"0\":\n                return 0;\n        }\n        /* istanbul ignore if */ if (!acceptNegative && token.charAt(0) === \"-\") throw illegal(token, \"id\");\n        if (base10NegRe.test(token)) return parseInt(token, 10);\n        if (base16NegRe.test(token)) return parseInt(token, 16);\n        /* istanbul ignore else */ if (base8NegRe.test(token)) return parseInt(token, 8);\n        /* istanbul ignore next */ throw illegal(token, \"id\");\n    }\n    function parsePackage() {\n        /* istanbul ignore if */ if (pkg !== undefined) throw illegal(\"package\");\n        pkg = next();\n        /* istanbul ignore if */ if (!typeRefRe.test(pkg)) throw illegal(pkg, \"name\");\n        ptr = ptr.define(pkg);\n        skip(\";\");\n    }\n    function parseImport() {\n        var token = peek();\n        var whichImports;\n        switch(token){\n            case \"weak\":\n                whichImports = weakImports || (weakImports = []);\n                next();\n                break;\n            case \"public\":\n                next();\n            // eslint-disable-next-line no-fallthrough\n            default:\n                whichImports = imports || (imports = []);\n                break;\n        }\n        token = readString();\n        skip(\";\");\n        whichImports.push(token);\n    }\n    function parseSyntax() {\n        skip(\"=\");\n        syntax = readString();\n        isProto3 = syntax === \"proto3\";\n        /* istanbul ignore if */ if (!isProto3 && syntax !== \"proto2\") throw illegal(syntax, \"syntax\");\n        skip(\";\");\n    }\n    function parseCommon(parent, token) {\n        switch(token){\n            case \"option\":\n                parseOption(parent, token);\n                skip(\";\");\n                return true;\n            case \"message\":\n                parseType(parent, token);\n                return true;\n            case \"enum\":\n                parseEnum(parent, token);\n                return true;\n            case \"service\":\n                parseService(parent, token);\n                return true;\n            case \"extend\":\n                parseExtension(parent, token);\n                return true;\n        }\n        return false;\n    }\n    function ifBlock(obj, fnIf, fnElse) {\n        var trailingLine = tn.line;\n        if (obj) {\n            if (typeof obj.comment !== \"string\") {\n                obj.comment = cmnt(); // try block-type comment\n            }\n            obj.filename = parse.filename;\n        }\n        if (skip(\"{\", true)) {\n            var token;\n            while((token = next()) !== \"}\")fnIf(token);\n            skip(\";\", true);\n        } else {\n            if (fnElse) fnElse();\n            skip(\";\");\n            if (obj && (typeof obj.comment !== \"string\" || preferTrailingComment)) obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment\n        }\n    }\n    function parseType(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"type name\");\n        var type = new Type(token);\n        ifBlock(type, function parseType_block(token) {\n            if (parseCommon(type, token)) return;\n            switch(token){\n                case \"map\":\n                    parseMapField(type, token);\n                    break;\n                case \"required\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n                case \"optional\":\n                    /* istanbul ignore if */ if (isProto3) {\n                        parseField(type, \"proto3_optional\");\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n                case \"oneof\":\n                    parseOneOf(type, token);\n                    break;\n                case \"extensions\":\n                    readRanges(type.extensions || (type.extensions = []));\n                    break;\n                case \"reserved\":\n                    readRanges(type.reserved || (type.reserved = []), true);\n                    break;\n                default:\n                    /* istanbul ignore if */ if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);\n                    push(token);\n                    parseField(type, \"optional\");\n                    break;\n            }\n        });\n        parent.add(type);\n    }\n    function parseField(parent, rule, extend) {\n        var type = next();\n        if (type === \"group\") {\n            parseGroup(parent, rule);\n            return;\n        }\n        // Type names can consume multiple tokens, in multiple variants:\n        //    package.subpackage   field       tokens: \"package.subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package . subpackage field       tokens: \"package\" \".\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package.  subpackage field       tokens: \"package.\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package  .subpackage field       tokens: \"package\" \".subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        // Keep reading tokens until we get a type name with no period at the end,\n        // and the next token does not start with a period.\n        while(type.endsWith(\".\") || peek().startsWith(\".\")){\n            type += next();\n        }\n        /* istanbul ignore if */ if (!typeRefRe.test(type)) throw illegal(type, \"type\");\n        var name = next();\n        /* istanbul ignore if */ if (!nameRe.test(name)) throw illegal(name, \"name\");\n        name = applyCase(name);\n        skip(\"=\");\n        var field = new Field(name, parseId(next()), type, rule, extend);\n        ifBlock(field, function parseField_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else throw illegal(token);\n        }, function parseField_line() {\n            parseInlineOptions(field);\n        });\n        if (rule === \"proto3_optional\") {\n            // for proto3 optional fields, we create a single-member Oneof to mimic \"optional\" behavior\n            var oneof = new OneOf(\"_\" + name);\n            field.setOption(\"proto3_optional\", true);\n            oneof.add(field);\n            parent.add(oneof);\n        } else {\n            parent.add(field);\n        }\n        // JSON defaults to packed=true if not set so we have to set packed=false explicity when\n        // parsing proto2 descriptors without the option, where applicable. This must be done for\n        // all known packable types and anything that could be an enum (= is not a basic type).\n        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined)) field.setOption(\"packed\", false, /* ifNotSet */ true);\n    }\n    function parseGroup(parent, rule) {\n        var name = next();\n        /* istanbul ignore if */ if (!nameRe.test(name)) throw illegal(name, \"name\");\n        var fieldName = util.lcFirst(name);\n        if (name === fieldName) name = util.ucFirst(name);\n        skip(\"=\");\n        var id = parseId(next());\n        var type = new Type(name);\n        type.group = true;\n        var field = new Field(fieldName, id, name, rule);\n        field.filename = parse.filename;\n        ifBlock(type, function parseGroup_block(token) {\n            switch(token){\n                case \"option\":\n                    parseOption(type, token);\n                    skip(\";\");\n                    break;\n                case \"required\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n                case \"optional\":\n                    /* istanbul ignore if */ if (isProto3) {\n                        parseField(type, \"proto3_optional\");\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n                case \"message\":\n                    parseType(type, token);\n                    break;\n                case \"enum\":\n                    parseEnum(type, token);\n                    break;\n                /* istanbul ignore next */ default:\n                    throw illegal(token); // there are no groups with proto3 semantics\n            }\n        });\n        parent.add(type).add(field);\n    }\n    function parseMapField(parent) {\n        skip(\"<\");\n        var keyType = next();\n        /* istanbul ignore if */ if (types.mapKey[keyType] === undefined) throw illegal(keyType, \"type\");\n        skip(\",\");\n        var valueType = next();\n        /* istanbul ignore if */ if (!typeRefRe.test(valueType)) throw illegal(valueType, \"type\");\n        skip(\">\");\n        var name = next();\n        /* istanbul ignore if */ if (!nameRe.test(name)) throw illegal(name, \"name\");\n        skip(\"=\");\n        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\n        ifBlock(field, function parseMapField_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else throw illegal(token);\n        }, function parseMapField_line() {\n            parseInlineOptions(field);\n        });\n        parent.add(field);\n    }\n    function parseOneOf(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n        var oneof = new OneOf(applyCase(token));\n        ifBlock(oneof, function parseOneOf_block(token) {\n            if (token === \"option\") {\n                parseOption(oneof, token);\n                skip(\";\");\n            } else {\n                push(token);\n                parseField(oneof, \"optional\");\n            }\n        });\n        parent.add(oneof);\n    }\n    function parseEnum(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n        var enm = new Enum(token);\n        ifBlock(enm, function parseEnum_block(token) {\n            switch(token){\n                case \"option\":\n                    parseOption(enm, token);\n                    skip(\";\");\n                    break;\n                case \"reserved\":\n                    readRanges(enm.reserved || (enm.reserved = []), true);\n                    break;\n                default:\n                    parseEnumValue(enm, token);\n            }\n        });\n        parent.add(enm);\n    }\n    function parseEnumValue(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token)) throw illegal(token, \"name\");\n        skip(\"=\");\n        var value = parseId(next(), true), dummy = {\n            options: undefined\n        };\n        dummy.setOption = function(name, value) {\n            if (this.options === undefined) this.options = {};\n            this.options[name] = value;\n        };\n        ifBlock(dummy, function parseEnumValue_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(dummy, token); // skip\n                skip(\";\");\n            } else throw illegal(token);\n        }, function parseEnumValue_line() {\n            parseInlineOptions(dummy); // skip\n        });\n        parent.add(token, value, dummy.comment, dummy.options);\n    }\n    function parseOption(parent, token) {\n        var isCustom = skip(\"(\", true);\n        /* istanbul ignore if */ if (!typeRefRe.test(token = next())) throw illegal(token, \"name\");\n        var name = token;\n        var option = name;\n        var propName;\n        if (isCustom) {\n            skip(\")\");\n            name = \"(\" + name + \")\";\n            option = name;\n            token = peek();\n            if (fqTypeRefRe.test(token)) {\n                propName = token.slice(1); //remove '.' before property name\n                name += token;\n                next();\n            }\n        }\n        skip(\"=\");\n        var optionValue = parseOptionValue(parent, name);\n        setParsedOption(parent, option, optionValue, propName);\n    }\n    function parseOptionValue(parent, name) {\n        // { a: \"foo\" b { c: \"bar\" } }\n        if (skip(\"{\", true)) {\n            var objectResult = {};\n            while(!skip(\"}\", true)){\n                /* istanbul ignore if */ if (!nameRe.test(token = next())) {\n                    throw illegal(token, \"name\");\n                }\n                if (token === null) {\n                    throw illegal(token, \"end of input\");\n                }\n                var value;\n                var propName = token;\n                skip(\":\", true);\n                if (peek() === \"{\") value = parseOptionValue(parent, name + \".\" + token);\n                else if (peek() === \"[\") {\n                    // option (my_option) = {\n                    //     repeated_value: [ \"foo\", \"bar\" ]\n                    // };\n                    value = [];\n                    var lastValue;\n                    if (skip(\"[\", true)) {\n                        do {\n                            lastValue = readValue(true);\n                            value.push(lastValue);\n                        }while (skip(\",\", true));\n                        skip(\"]\");\n                        if (typeof lastValue !== \"undefined\") {\n                            setOption(parent, name + \".\" + token, lastValue);\n                        }\n                    }\n                } else {\n                    value = readValue(true);\n                    setOption(parent, name + \".\" + token, value);\n                }\n                var prevValue = objectResult[propName];\n                if (prevValue) value = [].concat(prevValue).concat(value);\n                objectResult[propName] = value;\n                // Semicolons and commas can be optional\n                skip(\",\", true);\n                skip(\";\", true);\n            }\n            return objectResult;\n        }\n        var simpleValue = readValue(true);\n        setOption(parent, name, simpleValue);\n        return simpleValue;\n    // Does not enforce a delimiter to be universal\n    }\n    function setOption(parent, name, value) {\n        if (parent.setOption) parent.setOption(name, value);\n    }\n    function setParsedOption(parent, name, value, propName) {\n        if (parent.setParsedOption) parent.setParsedOption(name, value, propName);\n    }\n    function parseInlineOptions(parent) {\n        if (skip(\"[\", true)) {\n            do {\n                parseOption(parent, \"option\");\n            }while (skip(\",\", true));\n            skip(\"]\");\n        }\n        return parent;\n    }\n    function parseService(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"service name\");\n        var service = new Service(token);\n        ifBlock(service, function parseService_block(token) {\n            if (parseCommon(service, token)) return;\n            /* istanbul ignore else */ if (token === \"rpc\") parseMethod(service, token);\n            else throw illegal(token);\n        });\n        parent.add(service);\n    }\n    function parseMethod(parent, token) {\n        // Get the comment of the preceding line now (if one exists) in case the\n        // method is defined across multiple lines.\n        var commentText = cmnt();\n        var type = token;\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n        var name = token, requestType, requestStream, responseType, responseStream;\n        skip(\"(\");\n        if (skip(\"stream\", true)) requestStream = true;\n        /* istanbul ignore if */ if (!typeRefRe.test(token = next())) throw illegal(token);\n        requestType = token;\n        skip(\")\");\n        skip(\"returns\");\n        skip(\"(\");\n        if (skip(\"stream\", true)) responseStream = true;\n        /* istanbul ignore if */ if (!typeRefRe.test(token = next())) throw illegal(token);\n        responseType = token;\n        skip(\")\");\n        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\n        method.comment = commentText;\n        ifBlock(method, function parseMethod_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(method, token);\n                skip(\";\");\n            } else throw illegal(token);\n        });\n        parent.add(method);\n    }\n    function parseExtension(parent, token) {\n        /* istanbul ignore if */ if (!typeRefRe.test(token = next())) throw illegal(token, \"reference\");\n        var reference = token;\n        ifBlock(null, function parseExtension_block(token) {\n            switch(token){\n                case \"required\":\n                case \"repeated\":\n                    parseField(parent, token, reference);\n                    break;\n                case \"optional\":\n                    /* istanbul ignore if */ if (isProto3) {\n                        parseField(parent, \"proto3_optional\", reference);\n                    } else {\n                        parseField(parent, \"optional\", reference);\n                    }\n                    break;\n                default:\n                    /* istanbul ignore if */ if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);\n                    push(token);\n                    parseField(parent, \"optional\", reference);\n                    break;\n            }\n        });\n    }\n    var token;\n    while((token = next()) !== null){\n        switch(token){\n            case \"package\":\n                /* istanbul ignore if */ if (!head) throw illegal(token);\n                parsePackage();\n                break;\n            case \"import\":\n                /* istanbul ignore if */ if (!head) throw illegal(token);\n                parseImport();\n                break;\n            case \"syntax\":\n                /* istanbul ignore if */ if (!head) throw illegal(token);\n                parseSyntax();\n                break;\n            case \"option\":\n                parseOption(ptr, token);\n                skip(\";\");\n                break;\n            default:\n                /* istanbul ignore else */ if (parseCommon(ptr, token)) {\n                    head = false;\n                    continue;\n                }\n                /* istanbul ignore next */ throw illegal(token);\n        }\n    }\n    parse.filename = null;\n    return {\n        \"package\": pkg,\n        \"imports\": imports,\n        weakImports: weakImports,\n        syntax: syntax,\n        root: root\n    };\n} /**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @name parse\n * @function\n * @param {string} source Source contents\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n * @variation 2\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcGFyc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQkEsTUFBTUMsUUFBUSxHQUFHO0FBQ2pCRCxNQUFNRSxRQUFRLEdBQUc7SUFBRUMsVUFBVTtBQUFNO0FBRW5DLElBQUlDLFdBQVlDLG1CQUFPQSxDQUFDLG1FQUFZLEdBQ2hDQyxPQUFZRCxtQkFBT0EsQ0FBQywyREFBUSxHQUM1QkUsT0FBWUYsbUJBQU9BLENBQUMsMkRBQVEsR0FDNUJHLFFBQVlILG1CQUFPQSxDQUFDLDZEQUFTLEdBQzdCSSxXQUFZSixtQkFBT0EsQ0FBQyxtRUFBWSxHQUNoQ0ssUUFBWUwsbUJBQU9BLENBQUMsNkRBQVMsR0FDN0JNLE9BQVlOLG1CQUFPQSxDQUFDLDJEQUFRLEdBQzVCTyxVQUFZUCxtQkFBT0EsQ0FBQyxpRUFBVyxHQUMvQlEsU0FBWVIsbUJBQU9BLENBQUMsK0RBQVUsR0FDOUJTLFFBQVlULG1CQUFPQSxDQUFDLDZEQUFTLEdBQzdCVSxPQUFZVixtQkFBT0EsQ0FBQywyREFBUTtBQUVoQyxJQUFJVyxXQUFjLGlCQUNkQyxjQUFjLG1CQUNkQyxXQUFjLHNCQUNkQyxjQUFjLHdCQUNkQyxVQUFjLGFBQ2RDLGFBQWMsZUFDZEMsV0FBYyxxREFDZEMsU0FBYyw0QkFDZEMsWUFBYyxnRUFDZEMsY0FBYztBQUVsQjs7Ozs7Ozs7Q0FRQyxHQUVEOzs7Ozs7Q0FNQyxHQUVEOzs7O0NBSUMsR0FFRDs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVN6QixNQUFNMEIsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE9BQU87SUFDaEMsa0NBQWtDLEdBQ2xDLElBQUksQ0FBRUQsQ0FBQUEsZ0JBQWdCckIsSUFBRyxHQUFJO1FBQ3pCc0IsVUFBVUQ7UUFDVkEsT0FBTyxJQUFJckI7SUFDZjtJQUNBLElBQUksQ0FBQ3NCLFNBQ0RBLFVBQVU1QixNQUFNRSxRQUFRO0lBRTVCLElBQUkyQix3QkFBd0JELFFBQVFDLHFCQUFxQixJQUFJO0lBQzdELElBQUlDLEtBQUsxQixTQUFTc0IsUUFBUUUsUUFBUUcsb0JBQW9CLElBQUksUUFDdERDLE9BQU9GLEdBQUdFLElBQUksRUFDZEMsT0FBT0gsR0FBR0csSUFBSSxFQUNkQyxPQUFPSixHQUFHSSxJQUFJLEVBQ2RDLE9BQU9MLEdBQUdLLElBQUksRUFDZEMsT0FBT04sR0FBR00sSUFBSTtJQUVsQixJQUFJQyxPQUFPLE1BQ1BDLEtBQ0FDLFNBQ0FDLGFBQ0FDLFFBQ0FDLFdBQVc7SUFFZixJQUFJQyxNQUFNaEI7SUFFVixJQUFJaUIsWUFBWWhCLFFBQVF6QixRQUFRLEdBQUcsU0FBUzBDLElBQUk7UUFBSSxPQUFPQTtJQUFNLElBQUk5QixLQUFLK0IsU0FBUztJQUVuRix3QkFBd0IsR0FDeEIsU0FBU0MsUUFBUUMsS0FBSyxFQUFFSCxJQUFJLEVBQUVJLGNBQWM7UUFDeEMsSUFBSWhELFdBQVdELE1BQU1DLFFBQVE7UUFDN0IsSUFBSSxDQUFDZ0QsZ0JBQ0RqRCxNQUFNQyxRQUFRLEdBQUc7UUFDckIsT0FBT2lELE1BQU0sYUFBY0wsQ0FBQUEsUUFBUSxPQUFNLElBQUssT0FBT0csUUFBUSxRQUFTL0MsQ0FBQUEsV0FBV0EsV0FBVyxPQUFPLEVBQUMsSUFBSyxVQUFVNkIsR0FBR3FCLElBQUksR0FBRztJQUNqSTtJQUVBLFNBQVNDO1FBQ0wsSUFBSUMsU0FBUyxFQUFFLEVBQ1hMO1FBQ0osR0FBRztZQUNDLHNCQUFzQixHQUN0QixJQUFJLENBQUNBLFFBQVFoQixNQUFLLE1BQU8sT0FBUWdCLFVBQVUsS0FDdkMsTUFBTUQsUUFBUUM7WUFFbEJLLE9BQU9wQixJQUFJLENBQUNEO1lBQ1pHLEtBQUthO1lBQ0xBLFFBQVFkO1FBQ1osUUFBU2MsVUFBVSxPQUFRQSxVQUFVLEtBQUs7UUFDMUMsT0FBT0ssT0FBT0MsSUFBSSxDQUFDO0lBQ3ZCO0lBRUEsU0FBU0MsVUFBVUMsYUFBYTtRQUM1QixJQUFJUixRQUFRaEI7UUFDWixPQUFRZ0I7WUFDSixLQUFLO1lBQ0wsS0FBSztnQkFDRGYsS0FBS2U7Z0JBQ0wsT0FBT0k7WUFDWCxLQUFLO1lBQVEsS0FBSztnQkFDZCxPQUFPO1lBQ1gsS0FBSztZQUFTLEtBQUs7Z0JBQ2YsT0FBTztRQUNmO1FBQ0EsSUFBSTtZQUNBLE9BQU9LLFlBQVlULE9BQU8sa0JBQWtCLEdBQUc7UUFDbkQsRUFBRSxPQUFPVSxHQUFHO1lBRVIsd0JBQXdCLEdBQ3hCLElBQUlGLGlCQUFpQmhDLFVBQVVtQyxJQUFJLENBQUNYLFFBQ2hDLE9BQU9BO1lBRVgsd0JBQXdCLEdBQ3hCLE1BQU1ELFFBQVFDLE9BQU87UUFDekI7SUFDSjtJQUVBLFNBQVNZLFdBQVdDLE1BQU0sRUFBRUMsYUFBYTtRQUNyQyxJQUFJZCxPQUFPZTtRQUNYLEdBQUc7WUFDQyxJQUFJRCxpQkFBa0IsRUFBQ2QsUUFBUWQsTUFBSyxNQUFPLE9BQVFjLFVBQVUsR0FBRSxHQUMzRGEsT0FBTzVCLElBQUksQ0FBQ21CO2lCQUVaUyxPQUFPNUIsSUFBSSxDQUFDO2dCQUFFOEIsUUFBUUMsUUFBUWhDO2dCQUFTRyxLQUFLLE1BQU0sUUFBUTZCLFFBQVFoQyxVQUFVK0I7YUFBTztRQUMzRixRQUFTNUIsS0FBSyxLQUFLLE9BQU87UUFDMUJBLEtBQUs7SUFDVDtJQUVBLFNBQVNzQixZQUFZVCxLQUFLLEVBQUVDLGNBQWM7UUFDdEMsSUFBSWdCLE9BQU87UUFDWCxJQUFJakIsTUFBTWtCLE1BQU0sQ0FBQyxPQUFPLEtBQUs7WUFDekJELE9BQU8sQ0FBQztZQUNSakIsUUFBUUEsTUFBTW1CLFNBQVMsQ0FBQztRQUM1QjtRQUNBLE9BQVFuQjtZQUNKLEtBQUs7WUFBTyxLQUFLO1lBQU8sS0FBSztnQkFDekIsT0FBT2lCLE9BQU9HO1lBQ2xCLEtBQUs7WUFBTyxLQUFLO1lBQU8sS0FBSztZQUFPLEtBQUs7Z0JBQ3JDLE9BQU9DO1lBQ1gsS0FBSztnQkFDRCxPQUFPO1FBQ2Y7UUFDQSxJQUFJckQsU0FBUzJDLElBQUksQ0FBQ1gsUUFDZCxPQUFPaUIsT0FBT0ssU0FBU3RCLE9BQU87UUFDbEMsSUFBSTlCLFNBQVN5QyxJQUFJLENBQUNYLFFBQ2QsT0FBT2lCLE9BQU9LLFNBQVN0QixPQUFPO1FBQ2xDLElBQUk1QixRQUFRdUMsSUFBSSxDQUFDWCxRQUNiLE9BQU9pQixPQUFPSyxTQUFTdEIsT0FBTztRQUVsQyx3QkFBd0IsR0FDeEIsSUFBSTFCLFNBQVNxQyxJQUFJLENBQUNYLFFBQ2QsT0FBT2lCLE9BQU9NLFdBQVd2QjtRQUU3Qix3QkFBd0IsR0FDeEIsTUFBTUQsUUFBUUMsT0FBTyxVQUFVQztJQUNuQztJQUVBLFNBQVNlLFFBQVFoQixLQUFLLEVBQUV3QixjQUFjO1FBQ2xDLE9BQVF4QjtZQUNKLEtBQUs7WUFBTyxLQUFLO1lBQU8sS0FBSztnQkFDekIsT0FBTztZQUNYLEtBQUs7Z0JBQ0QsT0FBTztRQUNmO1FBRUEsc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ3dCLGtCQUFrQnhCLE1BQU1rQixNQUFNLENBQUMsT0FBTyxLQUN2QyxNQUFNbkIsUUFBUUMsT0FBTztRQUV6QixJQUFJL0IsWUFBWTBDLElBQUksQ0FBQ1gsUUFDakIsT0FBT3NCLFNBQVN0QixPQUFPO1FBQzNCLElBQUk3QixZQUFZd0MsSUFBSSxDQUFDWCxRQUNqQixPQUFPc0IsU0FBU3RCLE9BQU87UUFFM0Isd0JBQXdCLEdBQ3hCLElBQUkzQixXQUFXc0MsSUFBSSxDQUFDWCxRQUNoQixPQUFPc0IsU0FBU3RCLE9BQU87UUFFM0Isd0JBQXdCLEdBQ3hCLE1BQU1ELFFBQVFDLE9BQU87SUFDekI7SUFFQSxTQUFTeUI7UUFFTCxzQkFBc0IsR0FDdEIsSUFBSW5DLFFBQVFvQyxXQUNSLE1BQU0zQixRQUFRO1FBRWxCVCxNQUFNTjtRQUVOLHNCQUFzQixHQUN0QixJQUFJLENBQUNSLFVBQVVtQyxJQUFJLENBQUNyQixNQUNoQixNQUFNUyxRQUFRVCxLQUFLO1FBRXZCSyxNQUFNQSxJQUFJZ0MsTUFBTSxDQUFDckM7UUFDakJILEtBQUs7SUFDVDtJQUVBLFNBQVN5QztRQUNMLElBQUk1QixRQUFRZDtRQUNaLElBQUkyQztRQUNKLE9BQVE3QjtZQUNKLEtBQUs7Z0JBQ0Q2QixlQUFlckMsZUFBZ0JBLENBQUFBLGNBQWMsRUFBRTtnQkFDL0NSO2dCQUNBO1lBQ0osS0FBSztnQkFDREE7WUFDQSwwQ0FBMEM7WUFDOUM7Z0JBQ0k2QyxlQUFldEMsV0FBWUEsQ0FBQUEsVUFBVSxFQUFFO2dCQUN2QztRQUNSO1FBQ0FTLFFBQVFJO1FBQ1JqQixLQUFLO1FBQ0wwQyxhQUFhNUMsSUFBSSxDQUFDZTtJQUN0QjtJQUVBLFNBQVM4QjtRQUNMM0MsS0FBSztRQUNMTSxTQUFTVztRQUNUVixXQUFXRCxXQUFXO1FBRXRCLHNCQUFzQixHQUN0QixJQUFJLENBQUNDLFlBQVlELFdBQVcsVUFDeEIsTUFBTU0sUUFBUU4sUUFBUTtRQUUxQk4sS0FBSztJQUNUO0lBRUEsU0FBUzRDLFlBQVlDLE1BQU0sRUFBRWhDLEtBQUs7UUFDOUIsT0FBUUE7WUFFSixLQUFLO2dCQUNEaUMsWUFBWUQsUUFBUWhDO2dCQUNwQmIsS0FBSztnQkFDTCxPQUFPO1lBRVgsS0FBSztnQkFDRCtDLFVBQVVGLFFBQVFoQztnQkFDbEIsT0FBTztZQUVYLEtBQUs7Z0JBQ0RtQyxVQUFVSCxRQUFRaEM7Z0JBQ2xCLE9BQU87WUFFWCxLQUFLO2dCQUNEb0MsYUFBYUosUUFBUWhDO2dCQUNyQixPQUFPO1lBRVgsS0FBSztnQkFDRHFDLGVBQWVMLFFBQVFoQztnQkFDdkIsT0FBTztRQUNmO1FBQ0EsT0FBTztJQUNYO0lBRUEsU0FBU3NDLFFBQVFDLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxNQUFNO1FBQzlCLElBQUlDLGVBQWU1RCxHQUFHcUIsSUFBSTtRQUMxQixJQUFJb0MsS0FBSztZQUNMLElBQUcsT0FBT0EsSUFBSUksT0FBTyxLQUFLLFVBQVU7Z0JBQ2xDSixJQUFJSSxPQUFPLEdBQUd2RCxRQUFRLHlCQUF5QjtZQUNqRDtZQUNBbUQsSUFBSXRGLFFBQVEsR0FBR0QsTUFBTUMsUUFBUTtRQUNqQztRQUNBLElBQUlrQyxLQUFLLEtBQUssT0FBTztZQUNqQixJQUFJYTtZQUNKLE1BQU8sQ0FBQ0EsUUFBUWhCLE1BQUssTUFBTyxJQUN4QndELEtBQUt4QztZQUNUYixLQUFLLEtBQUs7UUFDZCxPQUFPO1lBQ0gsSUFBSXNELFFBQ0FBO1lBQ0p0RCxLQUFLO1lBQ0wsSUFBSW9ELE9BQVEsUUFBT0EsSUFBSUksT0FBTyxLQUFLLFlBQVk5RCxxQkFBb0IsR0FDL0QwRCxJQUFJSSxPQUFPLEdBQUd2RCxLQUFLc0QsaUJBQWlCSCxJQUFJSSxPQUFPLEVBQUUsd0JBQXdCO1FBQ2pGO0lBQ0o7SUFFQSxTQUFTVCxVQUFVRixNQUFNLEVBQUVoQyxLQUFLO1FBRTVCLHNCQUFzQixHQUN0QixJQUFJLENBQUN6QixPQUFPb0MsSUFBSSxDQUFDWCxRQUFRaEIsU0FDckIsTUFBTWUsUUFBUUMsT0FBTztRQUV6QixJQUFJNEMsT0FBTyxJQUFJckYsS0FBS3lDO1FBQ3BCc0MsUUFBUU0sTUFBTSxTQUFTQyxnQkFBZ0I3QyxLQUFLO1lBQ3hDLElBQUkrQixZQUFZYSxNQUFNNUMsUUFDbEI7WUFFSixPQUFRQTtnQkFFSixLQUFLO29CQUNEOEMsY0FBY0YsTUFBTTVDO29CQUNwQjtnQkFFSixLQUFLO2dCQUNMLEtBQUs7b0JBQ0QrQyxXQUFXSCxNQUFNNUM7b0JBQ2pCO2dCQUVKLEtBQUs7b0JBQ0Qsc0JBQXNCLEdBQ3RCLElBQUlOLFVBQVU7d0JBQ1ZxRCxXQUFXSCxNQUFNO29CQUNyQixPQUFPO3dCQUNIRyxXQUFXSCxNQUFNO29CQUNyQjtvQkFDQTtnQkFFSixLQUFLO29CQUNESSxXQUFXSixNQUFNNUM7b0JBQ2pCO2dCQUVKLEtBQUs7b0JBQ0RZLFdBQVdnQyxLQUFLSyxVQUFVLElBQUtMLENBQUFBLEtBQUtLLFVBQVUsR0FBRyxFQUFFO29CQUNuRDtnQkFFSixLQUFLO29CQUNEckMsV0FBV2dDLEtBQUtNLFFBQVEsSUFBS04sQ0FBQUEsS0FBS00sUUFBUSxHQUFHLEVBQUUsR0FBRztvQkFDbEQ7Z0JBRUo7b0JBQ0ksc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ3hELFlBQVksQ0FBQ2xCLFVBQVVtQyxJQUFJLENBQUNYLFFBQzdCLE1BQU1ELFFBQVFDO29CQUVsQmYsS0FBS2U7b0JBQ0wrQyxXQUFXSCxNQUFNO29CQUNqQjtZQUNSO1FBQ0o7UUFDQVosT0FBT21CLEdBQUcsQ0FBQ1A7SUFDZjtJQUVBLFNBQVNHLFdBQVdmLE1BQU0sRUFBRW9CLElBQUksRUFBRUMsTUFBTTtRQUNwQyxJQUFJVCxPQUFPNUQ7UUFDWCxJQUFJNEQsU0FBUyxTQUFTO1lBQ2xCVSxXQUFXdEIsUUFBUW9CO1lBQ25CO1FBQ0o7UUFDQSxnRUFBZ0U7UUFDaEUsaUdBQWlHO1FBQ2pHLHVHQUF1RztRQUN2RyxvR0FBb0c7UUFDcEcsb0dBQW9HO1FBQ3BHLDBFQUEwRTtRQUMxRSxtREFBbUQ7UUFDbkQsTUFBT1IsS0FBS1csUUFBUSxDQUFDLFFBQVFyRSxPQUFPc0UsVUFBVSxDQUFDLEtBQU07WUFDakRaLFFBQVE1RDtRQUNaO1FBRUEsc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ1IsVUFBVW1DLElBQUksQ0FBQ2lDLE9BQ2hCLE1BQU03QyxRQUFRNkMsTUFBTTtRQUV4QixJQUFJL0MsT0FBT2I7UUFFWCxzQkFBc0IsR0FDdEIsSUFBSSxDQUFDVCxPQUFPb0MsSUFBSSxDQUFDZCxPQUNiLE1BQU1FLFFBQVFGLE1BQU07UUFFeEJBLE9BQU9ELFVBQVVDO1FBQ2pCVixLQUFLO1FBRUwsSUFBSXNFLFFBQVEsSUFBSWpHLE1BQU1xQyxNQUFNbUIsUUFBUWhDLFNBQVM0RCxNQUFNUSxNQUFNQztRQUN6RGYsUUFBUW1CLE9BQU8sU0FBU0MsaUJBQWlCMUQsS0FBSztZQUUxQyx3QkFBd0IsR0FDeEIsSUFBSUEsVUFBVSxVQUFVO2dCQUNwQmlDLFlBQVl3QixPQUFPekQ7Z0JBQ25CYixLQUFLO1lBQ1QsT0FDSSxNQUFNWSxRQUFRQztRQUV0QixHQUFHLFNBQVMyRDtZQUNSQyxtQkFBbUJIO1FBQ3ZCO1FBRUEsSUFBSUwsU0FBUyxtQkFBbUI7WUFDNUIsMkZBQTJGO1lBQzNGLElBQUlTLFFBQVEsSUFBSW5HLE1BQU0sTUFBTW1DO1lBQzVCNEQsTUFBTUssU0FBUyxDQUFDLG1CQUFtQjtZQUNuQ0QsTUFBTVYsR0FBRyxDQUFDTTtZQUNWekIsT0FBT21CLEdBQUcsQ0FBQ1U7UUFDZixPQUFPO1lBQ0g3QixPQUFPbUIsR0FBRyxDQUFDTTtRQUNmO1FBRUEsd0ZBQXdGO1FBQ3hGLHlGQUF5RjtRQUN6Rix1RkFBdUY7UUFDdkYsSUFBSSxDQUFDL0QsWUFBWStELE1BQU1NLFFBQVEsSUFBS2pHLENBQUFBLE1BQU1rRyxNQUFNLENBQUNwQixLQUFLLEtBQUtsQixhQUFhNUQsTUFBTW1HLEtBQUssQ0FBQ3JCLEtBQUssS0FBS2xCLFNBQVEsR0FDbEcrQixNQUFNSyxTQUFTLENBQUMsVUFBVSxPQUFPLFlBQVksR0FBRztJQUN4RDtJQUVBLFNBQVNSLFdBQVd0QixNQUFNLEVBQUVvQixJQUFJO1FBQzVCLElBQUl2RCxPQUFPYjtRQUVYLHNCQUFzQixHQUN0QixJQUFJLENBQUNULE9BQU9vQyxJQUFJLENBQUNkLE9BQ2IsTUFBTUUsUUFBUUYsTUFBTTtRQUV4QixJQUFJcUUsWUFBWW5HLEtBQUtvRyxPQUFPLENBQUN0RTtRQUM3QixJQUFJQSxTQUFTcUUsV0FDVHJFLE9BQU85QixLQUFLcUcsT0FBTyxDQUFDdkU7UUFDeEJWLEtBQUs7UUFDTCxJQUFJa0YsS0FBS3JELFFBQVFoQztRQUNqQixJQUFJNEQsT0FBTyxJQUFJckYsS0FBS3NDO1FBQ3BCK0MsS0FBSzBCLEtBQUssR0FBRztRQUNiLElBQUliLFFBQVEsSUFBSWpHLE1BQU0wRyxXQUFXRyxJQUFJeEUsTUFBTXVEO1FBQzNDSyxNQUFNeEcsUUFBUSxHQUFHRCxNQUFNQyxRQUFRO1FBQy9CcUYsUUFBUU0sTUFBTSxTQUFTMkIsaUJBQWlCdkUsS0FBSztZQUN6QyxPQUFRQTtnQkFFSixLQUFLO29CQUNEaUMsWUFBWVcsTUFBTTVDO29CQUNsQmIsS0FBSztvQkFDTDtnQkFFSixLQUFLO2dCQUNMLEtBQUs7b0JBQ0Q0RCxXQUFXSCxNQUFNNUM7b0JBQ2pCO2dCQUVKLEtBQUs7b0JBQ0Qsc0JBQXNCLEdBQ3RCLElBQUlOLFVBQVU7d0JBQ1ZxRCxXQUFXSCxNQUFNO29CQUNyQixPQUFPO3dCQUNIRyxXQUFXSCxNQUFNO29CQUNyQjtvQkFDQTtnQkFFSixLQUFLO29CQUNEVixVQUFVVSxNQUFNNUM7b0JBQ2hCO2dCQUVKLEtBQUs7b0JBQ0RtQyxVQUFVUyxNQUFNNUM7b0JBQ2hCO2dCQUVKLHdCQUF3QixHQUN4QjtvQkFDSSxNQUFNRCxRQUFRQyxRQUFRLDRDQUE0QztZQUMxRTtRQUNKO1FBQ0FnQyxPQUFPbUIsR0FBRyxDQUFDUCxNQUNKTyxHQUFHLENBQUNNO0lBQ2Y7SUFFQSxTQUFTWCxjQUFjZCxNQUFNO1FBQ3pCN0MsS0FBSztRQUNMLElBQUlxRixVQUFVeEY7UUFFZCxzQkFBc0IsR0FDdEIsSUFBSWxCLE1BQU0yRyxNQUFNLENBQUNELFFBQVEsS0FBSzlDLFdBQzFCLE1BQU0zQixRQUFReUUsU0FBUztRQUUzQnJGLEtBQUs7UUFDTCxJQUFJdUYsWUFBWTFGO1FBRWhCLHNCQUFzQixHQUN0QixJQUFJLENBQUNSLFVBQVVtQyxJQUFJLENBQUMrRCxZQUNoQixNQUFNM0UsUUFBUTJFLFdBQVc7UUFFN0J2RixLQUFLO1FBQ0wsSUFBSVUsT0FBT2I7UUFFWCxzQkFBc0IsR0FDdEIsSUFBSSxDQUFDVCxPQUFPb0MsSUFBSSxDQUFDZCxPQUNiLE1BQU1FLFFBQVFGLE1BQU07UUFFeEJWLEtBQUs7UUFDTCxJQUFJc0UsUUFBUSxJQUFJaEcsU0FBU21DLFVBQVVDLE9BQU9tQixRQUFRaEMsU0FBU3dGLFNBQVNFO1FBQ3BFcEMsUUFBUW1CLE9BQU8sU0FBU2tCLG9CQUFvQjNFLEtBQUs7WUFFN0Msd0JBQXdCLEdBQ3hCLElBQUlBLFVBQVUsVUFBVTtnQkFDcEJpQyxZQUFZd0IsT0FBT3pEO2dCQUNuQmIsS0FBSztZQUNULE9BQ0ksTUFBTVksUUFBUUM7UUFFdEIsR0FBRyxTQUFTNEU7WUFDUmhCLG1CQUFtQkg7UUFDdkI7UUFDQXpCLE9BQU9tQixHQUFHLENBQUNNO0lBQ2Y7SUFFQSxTQUFTVCxXQUFXaEIsTUFBTSxFQUFFaEMsS0FBSztRQUU3QixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDekIsT0FBT29DLElBQUksQ0FBQ1gsUUFBUWhCLFNBQ3JCLE1BQU1lLFFBQVFDLE9BQU87UUFFekIsSUFBSTZELFFBQVEsSUFBSW5HLE1BQU1rQyxVQUFVSTtRQUNoQ3NDLFFBQVF1QixPQUFPLFNBQVNnQixpQkFBaUI3RSxLQUFLO1lBQzFDLElBQUlBLFVBQVUsVUFBVTtnQkFDcEJpQyxZQUFZNEIsT0FBTzdEO2dCQUNuQmIsS0FBSztZQUNULE9BQU87Z0JBQ0hGLEtBQUtlO2dCQUNMK0MsV0FBV2MsT0FBTztZQUN0QjtRQUNKO1FBQ0E3QixPQUFPbUIsR0FBRyxDQUFDVTtJQUNmO0lBRUEsU0FBUzFCLFVBQVVILE1BQU0sRUFBRWhDLEtBQUs7UUFFNUIsc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ3pCLE9BQU9vQyxJQUFJLENBQUNYLFFBQVFoQixTQUNyQixNQUFNZSxRQUFRQyxPQUFPO1FBRXpCLElBQUk4RSxNQUFNLElBQUluSCxLQUFLcUM7UUFDbkJzQyxRQUFRd0MsS0FBSyxTQUFTQyxnQkFBZ0IvRSxLQUFLO1lBQ3pDLE9BQU9BO2dCQUNMLEtBQUs7b0JBQ0hpQyxZQUFZNkMsS0FBSzlFO29CQUNqQmIsS0FBSztvQkFDTDtnQkFFRixLQUFLO29CQUNIeUIsV0FBV2tFLElBQUk1QixRQUFRLElBQUs0QixDQUFBQSxJQUFJNUIsUUFBUSxHQUFHLEVBQUUsR0FBRztvQkFDaEQ7Z0JBRUY7b0JBQ0U4QixlQUFlRixLQUFLOUU7WUFDeEI7UUFDRjtRQUNBZ0MsT0FBT21CLEdBQUcsQ0FBQzJCO0lBQ2Y7SUFFQSxTQUFTRSxlQUFlaEQsTUFBTSxFQUFFaEMsS0FBSztRQUVqQyxzQkFBc0IsR0FDdEIsSUFBSSxDQUFDekIsT0FBT29DLElBQUksQ0FBQ1gsUUFDYixNQUFNRCxRQUFRQyxPQUFPO1FBRXpCYixLQUFLO1FBQ0wsSUFBSThGLFFBQVFqRSxRQUFRaEMsUUFBUSxPQUN4QmtHLFFBQVE7WUFDSnRHLFNBQVM4QztRQUNiO1FBQ0p3RCxNQUFNcEIsU0FBUyxHQUFHLFNBQVNqRSxJQUFJLEVBQUVvRixLQUFLO1lBQ2xDLElBQUksSUFBSSxDQUFDckcsT0FBTyxLQUFLOEMsV0FDakIsSUFBSSxDQUFDOUMsT0FBTyxHQUFHLENBQUM7WUFDcEIsSUFBSSxDQUFDQSxPQUFPLENBQUNpQixLQUFLLEdBQUdvRjtRQUN6QjtRQUNBM0MsUUFBUTRDLE9BQU8sU0FBU0MscUJBQXFCbkYsS0FBSztZQUU5Qyx3QkFBd0IsR0FDeEIsSUFBSUEsVUFBVSxVQUFVO2dCQUNwQmlDLFlBQVlpRCxPQUFPbEYsUUFBUSxPQUFPO2dCQUNsQ2IsS0FBSztZQUNULE9BQ0ksTUFBTVksUUFBUUM7UUFFdEIsR0FBRyxTQUFTb0Y7WUFDUnhCLG1CQUFtQnNCLFFBQVEsT0FBTztRQUN0QztRQUNBbEQsT0FBT21CLEdBQUcsQ0FBQ25ELE9BQU9pRixPQUFPQyxNQUFNdkMsT0FBTyxFQUFFdUMsTUFBTXRHLE9BQU87SUFDekQ7SUFFQSxTQUFTcUQsWUFBWUQsTUFBTSxFQUFFaEMsS0FBSztRQUM5QixJQUFJcUYsV0FBV2xHLEtBQUssS0FBSztRQUV6QixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDWCxVQUFVbUMsSUFBSSxDQUFDWCxRQUFRaEIsU0FDeEIsTUFBTWUsUUFBUUMsT0FBTztRQUV6QixJQUFJSCxPQUFPRztRQUNYLElBQUlzRixTQUFTekY7UUFDYixJQUFJMEY7UUFFSixJQUFJRixVQUFVO1lBQ1ZsRyxLQUFLO1lBQ0xVLE9BQU8sTUFBTUEsT0FBTztZQUNwQnlGLFNBQVN6RjtZQUNURyxRQUFRZDtZQUNSLElBQUlULFlBQVlrQyxJQUFJLENBQUNYLFFBQVE7Z0JBQ3pCdUYsV0FBV3ZGLE1BQU13RixLQUFLLENBQUMsSUFBSSxpQ0FBaUM7Z0JBQzVEM0YsUUFBUUc7Z0JBQ1JoQjtZQUNKO1FBQ0o7UUFDQUcsS0FBSztRQUNMLElBQUlzRyxjQUFjQyxpQkFBaUIxRCxRQUFRbkM7UUFDM0M4RixnQkFBZ0IzRCxRQUFRc0QsUUFBUUcsYUFBYUY7SUFDakQ7SUFFQSxTQUFTRyxpQkFBaUIxRCxNQUFNLEVBQUVuQyxJQUFJO1FBQ2xDLDhCQUE4QjtRQUM5QixJQUFJVixLQUFLLEtBQUssT0FBTztZQUNqQixJQUFJeUcsZUFBZSxDQUFDO1lBRXBCLE1BQU8sQ0FBQ3pHLEtBQUssS0FBSyxNQUFPO2dCQUNyQixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDWixPQUFPb0MsSUFBSSxDQUFDWCxRQUFRaEIsU0FBUztvQkFDOUIsTUFBTWUsUUFBUUMsT0FBTztnQkFDekI7Z0JBQ0EsSUFBSUEsVUFBVSxNQUFNO29CQUNsQixNQUFNRCxRQUFRQyxPQUFPO2dCQUN2QjtnQkFFQSxJQUFJaUY7Z0JBQ0osSUFBSU0sV0FBV3ZGO2dCQUVmYixLQUFLLEtBQUs7Z0JBRVYsSUFBSUQsV0FBVyxLQUNYK0YsUUFBUVMsaUJBQWlCMUQsUUFBUW5DLE9BQU8sTUFBTUc7cUJBQzdDLElBQUlkLFdBQVcsS0FBSztvQkFDckIseUJBQXlCO29CQUN6Qix1Q0FBdUM7b0JBQ3ZDLEtBQUs7b0JBQ0wrRixRQUFRLEVBQUU7b0JBQ1YsSUFBSVk7b0JBQ0osSUFBSTFHLEtBQUssS0FBSyxPQUFPO3dCQUNqQixHQUFHOzRCQUNDMEcsWUFBWXRGLFVBQVU7NEJBQ3RCMEUsTUFBTWhHLElBQUksQ0FBQzRHO3dCQUNmLFFBQVMxRyxLQUFLLEtBQUssT0FBTzt3QkFDMUJBLEtBQUs7d0JBQ0wsSUFBSSxPQUFPMEcsY0FBYyxhQUFhOzRCQUNsQy9CLFVBQVU5QixRQUFRbkMsT0FBTyxNQUFNRyxPQUFPNkY7d0JBQzFDO29CQUNKO2dCQUNKLE9BQU87b0JBQ0haLFFBQVExRSxVQUFVO29CQUNsQnVELFVBQVU5QixRQUFRbkMsT0FBTyxNQUFNRyxPQUFPaUY7Z0JBQzFDO2dCQUVBLElBQUlhLFlBQVlGLFlBQVksQ0FBQ0wsU0FBUztnQkFFdEMsSUFBSU8sV0FDQWIsUUFBUSxFQUFFLENBQUNjLE1BQU0sQ0FBQ0QsV0FBV0MsTUFBTSxDQUFDZDtnQkFFeENXLFlBQVksQ0FBQ0wsU0FBUyxHQUFHTjtnQkFFekIsd0NBQXdDO2dCQUN4QzlGLEtBQUssS0FBSztnQkFDVkEsS0FBSyxLQUFLO1lBQ2Q7WUFFQSxPQUFPeUc7UUFDWDtRQUVBLElBQUlJLGNBQWN6RixVQUFVO1FBQzVCdUQsVUFBVTlCLFFBQVFuQyxNQUFNbUc7UUFDeEIsT0FBT0E7SUFDUCwrQ0FBK0M7SUFDbkQ7SUFFQSxTQUFTbEMsVUFBVTlCLE1BQU0sRUFBRW5DLElBQUksRUFBRW9GLEtBQUs7UUFDbEMsSUFBSWpELE9BQU84QixTQUFTLEVBQ2hCOUIsT0FBTzhCLFNBQVMsQ0FBQ2pFLE1BQU1vRjtJQUMvQjtJQUVBLFNBQVNVLGdCQUFnQjNELE1BQU0sRUFBRW5DLElBQUksRUFBRW9GLEtBQUssRUFBRU0sUUFBUTtRQUNsRCxJQUFJdkQsT0FBTzJELGVBQWUsRUFDdEIzRCxPQUFPMkQsZUFBZSxDQUFDOUYsTUFBTW9GLE9BQU9NO0lBQzVDO0lBRUEsU0FBUzNCLG1CQUFtQjVCLE1BQU07UUFDOUIsSUFBSTdDLEtBQUssS0FBSyxPQUFPO1lBQ2pCLEdBQUc7Z0JBQ0M4QyxZQUFZRCxRQUFRO1lBQ3hCLFFBQVM3QyxLQUFLLEtBQUssT0FBTztZQUMxQkEsS0FBSztRQUNUO1FBQ0EsT0FBTzZDO0lBQ1g7SUFFQSxTQUFTSSxhQUFhSixNQUFNLEVBQUVoQyxLQUFLO1FBRS9CLHNCQUFzQixHQUN0QixJQUFJLENBQUN6QixPQUFPb0MsSUFBSSxDQUFDWCxRQUFRaEIsU0FDckIsTUFBTWUsUUFBUUMsT0FBTztRQUV6QixJQUFJaUcsVUFBVSxJQUFJckksUUFBUW9DO1FBQzFCc0MsUUFBUTJELFNBQVMsU0FBU0MsbUJBQW1CbEcsS0FBSztZQUM5QyxJQUFJK0IsWUFBWWtFLFNBQVNqRyxRQUNyQjtZQUVKLHdCQUF3QixHQUN4QixJQUFJQSxVQUFVLE9BQ1ZtRyxZQUFZRixTQUFTakc7aUJBRXJCLE1BQU1ELFFBQVFDO1FBQ3RCO1FBQ0FnQyxPQUFPbUIsR0FBRyxDQUFDOEM7SUFDZjtJQUVBLFNBQVNFLFlBQVluRSxNQUFNLEVBQUVoQyxLQUFLO1FBQzlCLHdFQUF3RTtRQUN4RSwyQ0FBMkM7UUFDM0MsSUFBSW9HLGNBQWNoSDtRQUVsQixJQUFJd0QsT0FBTzVDO1FBRVgsc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ3pCLE9BQU9vQyxJQUFJLENBQUNYLFFBQVFoQixTQUNyQixNQUFNZSxRQUFRQyxPQUFPO1FBRXpCLElBQUlILE9BQU9HLE9BQ1BxRyxhQUFhQyxlQUNiQyxjQUFjQztRQUVsQnJILEtBQUs7UUFDTCxJQUFJQSxLQUFLLFVBQVUsT0FDZm1ILGdCQUFnQjtRQUVwQixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDOUgsVUFBVW1DLElBQUksQ0FBQ1gsUUFBUWhCLFNBQ3hCLE1BQU1lLFFBQVFDO1FBRWxCcUcsY0FBY3JHO1FBQ2RiLEtBQUs7UUFBTUEsS0FBSztRQUFZQSxLQUFLO1FBQ2pDLElBQUlBLEtBQUssVUFBVSxPQUNmcUgsaUJBQWlCO1FBRXJCLHNCQUFzQixHQUN0QixJQUFJLENBQUNoSSxVQUFVbUMsSUFBSSxDQUFDWCxRQUFRaEIsU0FDeEIsTUFBTWUsUUFBUUM7UUFFbEJ1RyxlQUFldkc7UUFDZmIsS0FBSztRQUVMLElBQUlzSCxTQUFTLElBQUk1SSxPQUFPZ0MsTUFBTStDLE1BQU15RCxhQUFhRSxjQUFjRCxlQUFlRTtRQUM5RUMsT0FBTzlELE9BQU8sR0FBR3lEO1FBQ2pCOUQsUUFBUW1FLFFBQVEsU0FBU0Msa0JBQWtCMUcsS0FBSztZQUU1Qyx3QkFBd0IsR0FDeEIsSUFBSUEsVUFBVSxVQUFVO2dCQUNwQmlDLFlBQVl3RSxRQUFRekc7Z0JBQ3BCYixLQUFLO1lBQ1QsT0FDSSxNQUFNWSxRQUFRQztRQUV0QjtRQUNBZ0MsT0FBT21CLEdBQUcsQ0FBQ3NEO0lBQ2Y7SUFFQSxTQUFTcEUsZUFBZUwsTUFBTSxFQUFFaEMsS0FBSztRQUVqQyxzQkFBc0IsR0FDdEIsSUFBSSxDQUFDeEIsVUFBVW1DLElBQUksQ0FBQ1gsUUFBUWhCLFNBQ3hCLE1BQU1lLFFBQVFDLE9BQU87UUFFekIsSUFBSTJHLFlBQVkzRztRQUNoQnNDLFFBQVEsTUFBTSxTQUFTc0UscUJBQXFCNUcsS0FBSztZQUM3QyxPQUFRQTtnQkFFSixLQUFLO2dCQUNMLEtBQUs7b0JBQ0QrQyxXQUFXZixRQUFRaEMsT0FBTzJHO29CQUMxQjtnQkFFSixLQUFLO29CQUNELHNCQUFzQixHQUN0QixJQUFJakgsVUFBVTt3QkFDVnFELFdBQVdmLFFBQVEsbUJBQW1CMkU7b0JBQzFDLE9BQU87d0JBQ0g1RCxXQUFXZixRQUFRLFlBQVkyRTtvQkFDbkM7b0JBQ0E7Z0JBRUo7b0JBQ0ksc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ2pILFlBQVksQ0FBQ2xCLFVBQVVtQyxJQUFJLENBQUNYLFFBQzdCLE1BQU1ELFFBQVFDO29CQUNsQmYsS0FBS2U7b0JBQ0wrQyxXQUFXZixRQUFRLFlBQVkyRTtvQkFDL0I7WUFDUjtRQUNKO0lBQ0o7SUFFQSxJQUFJM0c7SUFDSixNQUFPLENBQUNBLFFBQVFoQixNQUFLLE1BQU8sS0FBTTtRQUM5QixPQUFRZ0I7WUFFSixLQUFLO2dCQUVELHNCQUFzQixHQUN0QixJQUFJLENBQUNYLE1BQ0QsTUFBTVUsUUFBUUM7Z0JBRWxCeUI7Z0JBQ0E7WUFFSixLQUFLO2dCQUVELHNCQUFzQixHQUN0QixJQUFJLENBQUNwQyxNQUNELE1BQU1VLFFBQVFDO2dCQUVsQjRCO2dCQUNBO1lBRUosS0FBSztnQkFFRCxzQkFBc0IsR0FDdEIsSUFBSSxDQUFDdkMsTUFDRCxNQUFNVSxRQUFRQztnQkFFbEI4QjtnQkFDQTtZQUVKLEtBQUs7Z0JBRURHLFlBQVl0QyxLQUFLSztnQkFDakJiLEtBQUs7Z0JBQ0w7WUFFSjtnQkFFSSx3QkFBd0IsR0FDeEIsSUFBSTRDLFlBQVlwQyxLQUFLSyxRQUFRO29CQUN6QlgsT0FBTztvQkFDUDtnQkFDSjtnQkFFQSx3QkFBd0IsR0FDeEIsTUFBTVUsUUFBUUM7UUFDdEI7SUFDSjtJQUVBaEQsTUFBTUMsUUFBUSxHQUFHO0lBQ2pCLE9BQU87UUFDSCxXQUFnQnFDO1FBQ2hCLFdBQWdCQztRQUNmQyxhQUFlQTtRQUNmQyxRQUFlQTtRQUNmZCxNQUFlQTtJQUNwQjtBQUNKLEVBRUE7Ozs7Ozs7Ozs7Q0FVQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXByb2plY3QvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcGFyc2UuanM/ZTcyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG5cbnBhcnNlLmZpbGVuYW1lID0gbnVsbDtcbnBhcnNlLmRlZmF1bHRzID0geyBrZWVwQ2FzZTogZmFsc2UgfTtcblxudmFyIHRva2VuaXplICA9IHJlcXVpcmUoXCIuL3Rva2VuaXplXCIpLFxuICAgIFJvb3QgICAgICA9IHJlcXVpcmUoXCIuL3Jvb3RcIiksXG4gICAgVHlwZSAgICAgID0gcmVxdWlyZShcIi4vdHlwZVwiKSxcbiAgICBGaWVsZCAgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICBNYXBGaWVsZCAgPSByZXF1aXJlKFwiLi9tYXBmaWVsZFwiKSxcbiAgICBPbmVPZiAgICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKSxcbiAgICBFbnVtICAgICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIFNlcnZpY2UgICA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIiksXG4gICAgTWV0aG9kICAgID0gcmVxdWlyZShcIi4vbWV0aG9kXCIpLFxuICAgIHR5cGVzICAgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBiYXNlMTBSZSAgICA9IC9eWzEtOV1bMC05XSokLyxcbiAgICBiYXNlMTBOZWdSZSA9IC9eLT9bMS05XVswLTldKiQvLFxuICAgIGJhc2UxNlJlICAgID0gL14wW3hdWzAtOWEtZkEtRl0rJC8sXG4gICAgYmFzZTE2TmVnUmUgPSAvXi0/MFt4XVswLTlhLWZBLUZdKyQvLFxuICAgIGJhc2U4UmUgICAgID0gL14wWzAtN10rJC8sXG4gICAgYmFzZThOZWdSZSAgPSAvXi0/MFswLTddKyQvLFxuICAgIG51bWJlclJlICAgID0gL14oPyFbZUVdKVswLTldKig/OlxcLlswLTldKik/KD86W2VFXVsrLV0/WzAtOV0rKT8kLyxcbiAgICBuYW1lUmUgICAgICA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKiQvLFxuICAgIHR5cGVSZWZSZSAgID0gL14oPzpcXC4/W2EtekEtWl9dW2EtekEtWl8wLTldKikoPzpcXC5bYS16QS1aX11bYS16QS1aXzAtOV0qKSokLyxcbiAgICBmcVR5cGVSZWZSZSA9IC9eKD86XFwuW2EtekEtWl9dW2EtekEtWl8wLTldKikrJC87XG5cbi8qKlxuICogUmVzdWx0IG9iamVjdCByZXR1cm5lZCBmcm9tIHtAbGluayBwYXJzZX0uXG4gKiBAaW50ZXJmYWNlIElQYXJzZXJSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHVuZGVmaW5lZH0gcGFja2FnZSBQYWNrYWdlIG5hbWUsIGlmIGRlY2xhcmVkXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfHVuZGVmaW5lZH0gaW1wb3J0cyBJbXBvcnRzLCBpZiBhbnlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW118dW5kZWZpbmVkfSB3ZWFrSW1wb3J0cyBXZWFrIGltcG9ydHMsIGlmIGFueVxuICogQHByb3BlcnR5IHtzdHJpbmd8dW5kZWZpbmVkfSBzeW50YXggU3ludGF4LCBpZiBzcGVjaWZpZWQgKGVpdGhlciBgXCJwcm90bzJcImAgb3IgYFwicHJvdG8zXCJgKVxuICogQHByb3BlcnR5IHtSb290fSByb290IFBvcHVsYXRlZCByb290IGluc3RhbmNlXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb2Yge0BsaW5rIHBhcnNlfS5cbiAqIEBpbnRlcmZhY2UgSVBhcnNlT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBba2VlcENhc2U9ZmFsc2VdIEtlZXBzIGZpZWxkIGNhc2luZyBpbnN0ZWFkIG9mIGNvbnZlcnRpbmcgdG8gY2FtZWwgY2FzZVxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWx0ZXJuYXRlQ29tbWVudE1vZGU9ZmFsc2VdIFJlY29nbml6ZSBkb3VibGUtc2xhc2ggY29tbWVudHMgaW4gYWRkaXRpb24gdG8gZG9jLWJsb2NrIGNvbW1lbnRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcHJlZmVyVHJhaWxpbmdDb21tZW50PWZhbHNlXSBVc2UgdHJhaWxpbmcgY29tbWVudCB3aGVuIGJvdGggbGVhZGluZyBjb21tZW50IGFuZCB0cmFpbGluZyBjb21tZW50IGV4aXN0LlxuICovXG5cbi8qKlxuICogT3B0aW9ucyBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9mIEpTT04gc2VyaWFsaXphdGlvbi5cbiAqIEBpbnRlcmZhY2UgSVRvSlNPTk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2tlZXBDb21tZW50cz1mYWxzZV0gU2VyaWFsaXplcyBjb21tZW50cy5cbiAqL1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gLnByb3RvIHNvdXJjZSBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgcGFyc2VkIGNvbnRlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBTb3VyY2UgY29udGVudHNcbiAqIEBwYXJhbSB7Um9vdH0gcm9vdCBSb290IHRvIHBvcHVsYXRlXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IFtvcHRpb25zXSBQYXJzZSBvcHRpb25zLiBEZWZhdWx0cyB0byB7QGxpbmsgcGFyc2UuZGVmYXVsdHN9IHdoZW4gb21pdHRlZC5cbiAqIEByZXR1cm5zIHtJUGFyc2VyUmVzdWx0fSBQYXJzZXIgcmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gZmlsZW5hbWU9bnVsbCBDdXJyZW50bHkgcHJvY2Vzc2luZyBmaWxlIG5hbWUgZm9yIGVycm9yIHJlcG9ydGluZywgaWYga25vd25cbiAqIEBwcm9wZXJ0eSB7SVBhcnNlT3B0aW9uc30gZGVmYXVsdHMgRGVmYXVsdCB7QGxpbmsgSVBhcnNlT3B0aW9uc31cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc291cmNlLCByb290LCBvcHRpb25zKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgY2FsbGJhY2stcmV0dXJuICovXG4gICAgaWYgKCEocm9vdCBpbnN0YW5jZW9mIFJvb3QpKSB7XG4gICAgICAgIG9wdGlvbnMgPSByb290O1xuICAgICAgICByb290ID0gbmV3IFJvb3QoKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgICBvcHRpb25zID0gcGFyc2UuZGVmYXVsdHM7XG5cbiAgICB2YXIgcHJlZmVyVHJhaWxpbmdDb21tZW50ID0gb3B0aW9ucy5wcmVmZXJUcmFpbGluZ0NvbW1lbnQgfHwgZmFsc2U7XG4gICAgdmFyIHRuID0gdG9rZW5pemUoc291cmNlLCBvcHRpb25zLmFsdGVybmF0ZUNvbW1lbnRNb2RlIHx8IGZhbHNlKSxcbiAgICAgICAgbmV4dCA9IHRuLm5leHQsXG4gICAgICAgIHB1c2ggPSB0bi5wdXNoLFxuICAgICAgICBwZWVrID0gdG4ucGVlayxcbiAgICAgICAgc2tpcCA9IHRuLnNraXAsXG4gICAgICAgIGNtbnQgPSB0bi5jbW50O1xuXG4gICAgdmFyIGhlYWQgPSB0cnVlLFxuICAgICAgICBwa2csXG4gICAgICAgIGltcG9ydHMsXG4gICAgICAgIHdlYWtJbXBvcnRzLFxuICAgICAgICBzeW50YXgsXG4gICAgICAgIGlzUHJvdG8zID0gZmFsc2U7XG5cbiAgICB2YXIgcHRyID0gcm9vdDtcblxuICAgIHZhciBhcHBseUNhc2UgPSBvcHRpb25zLmtlZXBDYXNlID8gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gbmFtZTsgfSA6IHV0aWwuY2FtZWxDYXNlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBpbGxlZ2FsKHRva2VuLCBuYW1lLCBpbnNpZGVUcnlDYXRjaCkge1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXJzZS5maWxlbmFtZTtcbiAgICAgICAgaWYgKCFpbnNpZGVUcnlDYXRjaClcbiAgICAgICAgICAgIHBhcnNlLmZpbGVuYW1lID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIEVycm9yKFwiaWxsZWdhbCBcIiArIChuYW1lIHx8IFwidG9rZW5cIikgKyBcIiAnXCIgKyB0b2tlbiArIFwiJyAoXCIgKyAoZmlsZW5hbWUgPyBmaWxlbmFtZSArIFwiLCBcIiA6IFwiXCIpICsgXCJsaW5lIFwiICsgdG4ubGluZSArIFwiKVwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkU3RyaW5nKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gW10sXG4gICAgICAgICAgICB0b2tlbjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoKHRva2VuID0gbmV4dCgpKSAhPT0gXCJcXFwiXCIgJiYgdG9rZW4gIT09IFwiJ1wiKVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChuZXh0KCkpO1xuICAgICAgICAgICAgc2tpcCh0b2tlbik7XG4gICAgICAgICAgICB0b2tlbiA9IHBlZWsoKTtcbiAgICAgICAgfSB3aGlsZSAodG9rZW4gPT09IFwiXFxcIlwiIHx8IHRva2VuID09PSBcIidcIik7XG4gICAgICAgIHJldHVybiB2YWx1ZXMuam9pbihcIlwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkVmFsdWUoYWNjZXB0VHlwZVJlZikge1xuICAgICAgICB2YXIgdG9rZW4gPSBuZXh0KCk7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgICBjYXNlIFwiXFxcIlwiOlxuICAgICAgICAgICAgICAgIHB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkU3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlIFwidHJ1ZVwiOiBjYXNlIFwiVFJVRVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSBcImZhbHNlXCI6IGNhc2UgXCJGQUxTRVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyKHRva2VuLCAvKiBpbnNpZGVUcnlDYXRjaCAqLyB0cnVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGFjY2VwdFR5cGVSZWYgJiYgdHlwZVJlZlJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwidmFsdWVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkUmFuZ2VzKHRhcmdldCwgYWNjZXB0U3RyaW5ncykge1xuICAgICAgICB2YXIgdG9rZW4sIHN0YXJ0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0U3RyaW5ncyAmJiAoKHRva2VuID0gcGVlaygpKSA9PT0gXCJcXFwiXCIgfHwgdG9rZW4gPT09IFwiJ1wiKSlcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChyZWFkU3RyaW5nKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKFsgc3RhcnQgPSBwYXJzZUlkKG5leHQoKSksIHNraXAoXCJ0b1wiLCB0cnVlKSA/IHBhcnNlSWQobmV4dCgpKSA6IHN0YXJ0IF0pO1xuICAgICAgICB9IHdoaWxlIChza2lwKFwiLFwiLCB0cnVlKSk7XG4gICAgICAgIHNraXAoXCI7XCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTnVtYmVyKHRva2VuLCBpbnNpZGVUcnlDYXRjaCkge1xuICAgICAgICB2YXIgc2lnbiA9IDE7XG4gICAgICAgIGlmICh0b2tlbi5jaGFyQXQoMCkgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW5mXCI6IGNhc2UgXCJJTkZcIjogY2FzZSBcIkluZlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduICogSW5maW5pdHk7XG4gICAgICAgICAgICBjYXNlIFwibmFuXCI6IGNhc2UgXCJOQU5cIjogY2FzZSBcIk5hblwiOiBjYXNlIFwiTmFOXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2UxMFJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh0b2tlbiwgMTApO1xuICAgICAgICBpZiAoYmFzZTE2UmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHRva2VuLCAxNik7XG4gICAgICAgIGlmIChiYXNlOFJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh0b2tlbiwgOCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKG51bWJlclJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHRva2VuKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm51bWJlclwiLCBpbnNpZGVUcnlDYXRjaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJZCh0b2tlbiwgYWNjZXB0TmVnYXRpdmUpIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSBcIm1heFwiOiBjYXNlIFwiTUFYXCI6IGNhc2UgXCJNYXhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gNTM2ODcwOTExO1xuICAgICAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWFjY2VwdE5lZ2F0aXZlICYmIHRva2VuLmNoYXJBdCgwKSA9PT0gXCItXCIpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcImlkXCIpO1xuXG4gICAgICAgIGlmIChiYXNlMTBOZWdSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0b2tlbiwgMTApO1xuICAgICAgICBpZiAoYmFzZTE2TmVnUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodG9rZW4sIDE2KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoYmFzZThOZWdSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0b2tlbiwgOCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJpZFwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBhY2thZ2UoKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwa2cgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwoXCJwYWNrYWdlXCIpO1xuXG4gICAgICAgIHBrZyA9IG5leHQoKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdChwa2cpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChwa2csIFwibmFtZVwiKTtcblxuICAgICAgICBwdHIgPSBwdHIuZGVmaW5lKHBrZyk7XG4gICAgICAgIHNraXAoXCI7XCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSW1wb3J0KCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBwZWVrKCk7XG4gICAgICAgIHZhciB3aGljaEltcG9ydHM7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWFrXCI6XG4gICAgICAgICAgICAgICAgd2hpY2hJbXBvcnRzID0gd2Vha0ltcG9ydHMgfHwgKHdlYWtJbXBvcnRzID0gW10pO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwdWJsaWNcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHdoaWNoSW1wb3J0cyA9IGltcG9ydHMgfHwgKGltcG9ydHMgPSBbXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSByZWFkU3RyaW5nKCk7XG4gICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICB3aGljaEltcG9ydHMucHVzaCh0b2tlbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTeW50YXgoKSB7XG4gICAgICAgIHNraXAoXCI9XCIpO1xuICAgICAgICBzeW50YXggPSByZWFkU3RyaW5nKCk7XG4gICAgICAgIGlzUHJvdG8zID0gc3ludGF4ID09PSBcInByb3RvM1wiO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWlzUHJvdG8zICYmIHN5bnRheCAhPT0gXCJwcm90bzJcIilcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwoc3ludGF4LCBcInN5bnRheFwiKTtcblxuICAgICAgICBza2lwKFwiO1wiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbW1vbihwYXJlbnQsIHRva2VuKSB7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcblxuICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKHBhcmVudCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHBhcnNlVHlwZShwYXJlbnQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICBwYXJzZUVudW0ocGFyZW50LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgXCJzZXJ2aWNlXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VTZXJ2aWNlKHBhcmVudCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFwiZXh0ZW5kXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VFeHRlbnNpb24ocGFyZW50LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlmQmxvY2sob2JqLCBmbklmLCBmbkVsc2UpIHtcbiAgICAgICAgdmFyIHRyYWlsaW5nTGluZSA9IHRuLmxpbmU7XG4gICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBvYmouY29tbWVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICBvYmouY29tbWVudCA9IGNtbnQoKTsgLy8gdHJ5IGJsb2NrLXR5cGUgY29tbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqLmZpbGVuYW1lID0gcGFyc2UuZmlsZW5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXAoXCJ7XCIsIHRydWUpKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgICB3aGlsZSAoKHRva2VuID0gbmV4dCgpKSAhPT0gXCJ9XCIpXG4gICAgICAgICAgICAgICAgZm5JZih0b2tlbik7XG4gICAgICAgICAgICBza2lwKFwiO1wiLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmbkVsc2UpXG4gICAgICAgICAgICAgICAgZm5FbHNlKCk7XG4gICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIGlmIChvYmogJiYgKHR5cGVvZiBvYmouY29tbWVudCAhPT0gXCJzdHJpbmdcIiB8fCBwcmVmZXJUcmFpbGluZ0NvbW1lbnQpKVxuICAgICAgICAgICAgICAgIG9iai5jb21tZW50ID0gY21udCh0cmFpbGluZ0xpbmUpIHx8IG9iai5jb21tZW50OyAvLyB0cnkgbGluZS10eXBlIGNvbW1lbnRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVHlwZShwYXJlbnQsIHRva2VuKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJ0eXBlIG5hbWVcIik7XG5cbiAgICAgICAgdmFyIHR5cGUgPSBuZXcgVHlwZSh0b2tlbik7XG4gICAgICAgIGlmQmxvY2sodHlwZSwgZnVuY3Rpb24gcGFyc2VUeXBlX2Jsb2NrKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VDb21tb24odHlwZSwgdG9rZW4pKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZU1hcEZpZWxkKHR5cGUsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVwZWF0ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvbmFsXCI6XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm90bzMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQodHlwZSwgXCJwcm90bzNfb3B0aW9uYWxcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIFwib3B0aW9uYWxcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwib25lb2ZcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VPbmVPZih0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcImV4dGVuc2lvbnNcIjpcbiAgICAgICAgICAgICAgICAgICAgcmVhZFJhbmdlcyh0eXBlLmV4dGVuc2lvbnMgfHwgKHR5cGUuZXh0ZW5zaW9ucyA9IFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlc2VydmVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRSYW5nZXModHlwZS5yZXNlcnZlZCB8fCAodHlwZS5yZXNlcnZlZCA9IFtdKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNQcm90bzMgfHwgIXR5cGVSZWZSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgICAgIHB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIFwib3B0aW9uYWxcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZCh0eXBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZpZWxkKHBhcmVudCwgcnVsZSwgZXh0ZW5kKSB7XG4gICAgICAgIHZhciB0eXBlID0gbmV4dCgpO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgICAgICBwYXJzZUdyb3VwKHBhcmVudCwgcnVsZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHlwZSBuYW1lcyBjYW4gY29uc3VtZSBtdWx0aXBsZSB0b2tlbnMsIGluIG11bHRpcGxlIHZhcmlhbnRzOlxuICAgICAgICAvLyAgICBwYWNrYWdlLnN1YnBhY2thZ2UgICBmaWVsZCAgICAgICB0b2tlbnM6IFwicGFja2FnZS5zdWJwYWNrYWdlXCIgW1RZUEUgTkFNRSBFTkRTIEhFUkVdIFwiZmllbGRcIlxuICAgICAgICAvLyAgICBwYWNrYWdlIC4gc3VicGFja2FnZSBmaWVsZCAgICAgICB0b2tlbnM6IFwicGFja2FnZVwiIFwiLlwiIFwic3VicGFja2FnZVwiIFtUWVBFIE5BTUUgRU5EUyBIRVJFXSBcImZpZWxkXCJcbiAgICAgICAgLy8gICAgcGFja2FnZS4gIHN1YnBhY2thZ2UgZmllbGQgICAgICAgdG9rZW5zOiBcInBhY2thZ2UuXCIgXCJzdWJwYWNrYWdlXCIgW1RZUEUgTkFNRSBFTkRTIEhFUkVdIFwiZmllbGRcIlxuICAgICAgICAvLyAgICBwYWNrYWdlICAuc3VicGFja2FnZSBmaWVsZCAgICAgICB0b2tlbnM6IFwicGFja2FnZVwiIFwiLnN1YnBhY2thZ2VcIiBbVFlQRSBOQU1FIEVORFMgSEVSRV0gXCJmaWVsZFwiXG4gICAgICAgIC8vIEtlZXAgcmVhZGluZyB0b2tlbnMgdW50aWwgd2UgZ2V0IGEgdHlwZSBuYW1lIHdpdGggbm8gcGVyaW9kIGF0IHRoZSBlbmQsXG4gICAgICAgIC8vIGFuZCB0aGUgbmV4dCB0b2tlbiBkb2VzIG5vdCBzdGFydCB3aXRoIGEgcGVyaW9kLlxuICAgICAgICB3aGlsZSAodHlwZS5lbmRzV2l0aChcIi5cIikgfHwgcGVlaygpLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICAgICAgICB0eXBlICs9IG5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHR5cGUpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0eXBlLCBcInR5cGVcIik7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKG5hbWUsIFwibmFtZVwiKTtcblxuICAgICAgICBuYW1lID0gYXBwbHlDYXNlKG5hbWUpO1xuICAgICAgICBza2lwKFwiPVwiKTtcblxuICAgICAgICB2YXIgZmllbGQgPSBuZXcgRmllbGQobmFtZSwgcGFyc2VJZChuZXh0KCkpLCB0eXBlLCBydWxlLCBleHRlbmQpO1xuICAgICAgICBpZkJsb2NrKGZpZWxkLCBmdW5jdGlvbiBwYXJzZUZpZWxkX2Jsb2NrKHRva2VuKSB7XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihmaWVsZCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24gcGFyc2VGaWVsZF9saW5lKCkge1xuICAgICAgICAgICAgcGFyc2VJbmxpbmVPcHRpb25zKGZpZWxkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJ1bGUgPT09IFwicHJvdG8zX29wdGlvbmFsXCIpIHtcbiAgICAgICAgICAgIC8vIGZvciBwcm90bzMgb3B0aW9uYWwgZmllbGRzLCB3ZSBjcmVhdGUgYSBzaW5nbGUtbWVtYmVyIE9uZW9mIHRvIG1pbWljIFwib3B0aW9uYWxcIiBiZWhhdmlvclxuICAgICAgICAgICAgdmFyIG9uZW9mID0gbmV3IE9uZU9mKFwiX1wiICsgbmFtZSk7XG4gICAgICAgICAgICBmaWVsZC5zZXRPcHRpb24oXCJwcm90bzNfb3B0aW9uYWxcIiwgdHJ1ZSk7XG4gICAgICAgICAgICBvbmVvZi5hZGQoZmllbGQpO1xuICAgICAgICAgICAgcGFyZW50LmFkZChvbmVvZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnQuYWRkKGZpZWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEpTT04gZGVmYXVsdHMgdG8gcGFja2VkPXRydWUgaWYgbm90IHNldCBzbyB3ZSBoYXZlIHRvIHNldCBwYWNrZWQ9ZmFsc2UgZXhwbGljaXR5IHdoZW5cbiAgICAgICAgLy8gcGFyc2luZyBwcm90bzIgZGVzY3JpcHRvcnMgd2l0aG91dCB0aGUgb3B0aW9uLCB3aGVyZSBhcHBsaWNhYmxlLiBUaGlzIG11c3QgYmUgZG9uZSBmb3JcbiAgICAgICAgLy8gYWxsIGtub3duIHBhY2thYmxlIHR5cGVzIGFuZCBhbnl0aGluZyB0aGF0IGNvdWxkIGJlIGFuIGVudW0gKD0gaXMgbm90IGEgYmFzaWMgdHlwZSkuXG4gICAgICAgIGlmICghaXNQcm90bzMgJiYgZmllbGQucmVwZWF0ZWQgJiYgKHR5cGVzLnBhY2tlZFt0eXBlXSAhPT0gdW5kZWZpbmVkIHx8IHR5cGVzLmJhc2ljW3R5cGVdID09PSB1bmRlZmluZWQpKVxuICAgICAgICAgICAgZmllbGQuc2V0T3B0aW9uKFwicGFja2VkXCIsIGZhbHNlLCAvKiBpZk5vdFNldCAqLyB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUdyb3VwKHBhcmVudCwgcnVsZSkge1xuICAgICAgICB2YXIgbmFtZSA9IG5leHQoKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdChuYW1lKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwobmFtZSwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHZhciBmaWVsZE5hbWUgPSB1dGlsLmxjRmlyc3QobmFtZSk7XG4gICAgICAgIGlmIChuYW1lID09PSBmaWVsZE5hbWUpXG4gICAgICAgICAgICBuYW1lID0gdXRpbC51Y0ZpcnN0KG5hbWUpO1xuICAgICAgICBza2lwKFwiPVwiKTtcbiAgICAgICAgdmFyIGlkID0gcGFyc2VJZChuZXh0KCkpO1xuICAgICAgICB2YXIgdHlwZSA9IG5ldyBUeXBlKG5hbWUpO1xuICAgICAgICB0eXBlLmdyb3VwID0gdHJ1ZTtcbiAgICAgICAgdmFyIGZpZWxkID0gbmV3IEZpZWxkKGZpZWxkTmFtZSwgaWQsIG5hbWUsIHJ1bGUpO1xuICAgICAgICBmaWVsZC5maWxlbmFtZSA9IHBhcnNlLmZpbGVuYW1lO1xuICAgICAgICBpZkJsb2NrKHR5cGUsIGZ1bmN0aW9uIHBhcnNlR3JvdXBfYmxvY2sodG9rZW4pIHtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VPcHRpb24odHlwZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVwZWF0ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvbmFsXCI6XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm90bzMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQodHlwZSwgXCJwcm90bzNfb3B0aW9uYWxcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIFwib3B0aW9uYWxcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVR5cGUodHlwZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRW51bSh0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTsgLy8gdGhlcmUgYXJlIG5vIGdyb3VwcyB3aXRoIHByb3RvMyBzZW1hbnRpY3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQodHlwZSlcbiAgICAgICAgICAgICAgLmFkZChmaWVsZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNYXBGaWVsZChwYXJlbnQpIHtcbiAgICAgICAgc2tpcChcIjxcIik7XG4gICAgICAgIHZhciBrZXlUeXBlID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodHlwZXMubWFwS2V5W2tleVR5cGVdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKGtleVR5cGUsIFwidHlwZVwiKTtcblxuICAgICAgICBza2lwKFwiLFwiKTtcbiAgICAgICAgdmFyIHZhbHVlVHlwZSA9IG5leHQoKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh2YWx1ZVR5cGUpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh2YWx1ZVR5cGUsIFwidHlwZVwiKTtcblxuICAgICAgICBza2lwKFwiPlwiKTtcbiAgICAgICAgdmFyIG5hbWUgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKG5hbWUsIFwibmFtZVwiKTtcblxuICAgICAgICBza2lwKFwiPVwiKTtcbiAgICAgICAgdmFyIGZpZWxkID0gbmV3IE1hcEZpZWxkKGFwcGx5Q2FzZShuYW1lKSwgcGFyc2VJZChuZXh0KCkpLCBrZXlUeXBlLCB2YWx1ZVR5cGUpO1xuICAgICAgICBpZkJsb2NrKGZpZWxkLCBmdW5jdGlvbiBwYXJzZU1hcEZpZWxkX2Jsb2NrKHRva2VuKSB7XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihmaWVsZCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24gcGFyc2VNYXBGaWVsZF9saW5lKCkge1xuICAgICAgICAgICAgcGFyc2VJbmxpbmVPcHRpb25zKGZpZWxkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQoZmllbGQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT25lT2YocGFyZW50LCB0b2tlbikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwibmFtZVwiKTtcblxuICAgICAgICB2YXIgb25lb2YgPSBuZXcgT25lT2YoYXBwbHlDYXNlKHRva2VuKSk7XG4gICAgICAgIGlmQmxvY2sob25lb2YsIGZ1bmN0aW9uIHBhcnNlT25lT2ZfYmxvY2sodG9rZW4pIHtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKG9uZW9mLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIHBhcnNlRmllbGQob25lb2YsIFwib3B0aW9uYWxcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKG9uZW9mKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUVudW0ocGFyZW50LCB0b2tlbikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwibmFtZVwiKTtcblxuICAgICAgICB2YXIgZW5tID0gbmV3IEVudW0odG9rZW4pO1xuICAgICAgICBpZkJsb2NrKGVubSwgZnVuY3Rpb24gcGFyc2VFbnVtX2Jsb2NrKHRva2VuKSB7XG4gICAgICAgICAgc3dpdGNoKHRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICAgICAgICAgIHBhcnNlT3B0aW9uKGVubSwgdG9rZW4pO1xuICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJyZXNlcnZlZFwiOlxuICAgICAgICAgICAgICByZWFkUmFuZ2VzKGVubS5yZXNlcnZlZCB8fCAoZW5tLnJlc2VydmVkID0gW10pLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHBhcnNlRW51bVZhbHVlKGVubSwgdG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQoZW5tKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUVudW1WYWx1ZShwYXJlbnQsIHRva2VuKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHNraXAoXCI9XCIpO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUlkKG5leHQoKSwgdHJ1ZSksXG4gICAgICAgICAgICBkdW1teSA9IHtcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIGR1bW15LnNldE9wdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWZCbG9jayhkdW1teSwgZnVuY3Rpb24gcGFyc2VFbnVtVmFsdWVfYmxvY2sodG9rZW4pIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKGR1bW15LCB0b2tlbik7IC8vIHNraXBcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIH0sIGZ1bmN0aW9uIHBhcnNlRW51bVZhbHVlX2xpbmUoKSB7XG4gICAgICAgICAgICBwYXJzZUlubGluZU9wdGlvbnMoZHVtbXkpOyAvLyBza2lwXG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKHRva2VuLCB2YWx1ZSwgZHVtbXkuY29tbWVudCwgZHVtbXkub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPcHRpb24ocGFyZW50LCB0b2tlbikge1xuICAgICAgICB2YXIgaXNDdXN0b20gPSBza2lwKFwiKFwiLCB0cnVlKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG5cbiAgICAgICAgdmFyIG5hbWUgPSB0b2tlbjtcbiAgICAgICAgdmFyIG9wdGlvbiA9IG5hbWU7XG4gICAgICAgIHZhciBwcm9wTmFtZTtcblxuICAgICAgICBpZiAoaXNDdXN0b20pIHtcbiAgICAgICAgICAgIHNraXAoXCIpXCIpO1xuICAgICAgICAgICAgbmFtZSA9IFwiKFwiICsgbmFtZSArIFwiKVwiO1xuICAgICAgICAgICAgb3B0aW9uID0gbmFtZTtcbiAgICAgICAgICAgIHRva2VuID0gcGVlaygpO1xuICAgICAgICAgICAgaWYgKGZxVHlwZVJlZlJlLnRlc3QodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcHJvcE5hbWUgPSB0b2tlbi5zbGljZSgxKTsgLy9yZW1vdmUgJy4nIGJlZm9yZSBwcm9wZXJ0eSBuYW1lXG4gICAgICAgICAgICAgICAgbmFtZSArPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2tpcChcIj1cIik7XG4gICAgICAgIHZhciBvcHRpb25WYWx1ZSA9IHBhcnNlT3B0aW9uVmFsdWUocGFyZW50LCBuYW1lKTtcbiAgICAgICAgc2V0UGFyc2VkT3B0aW9uKHBhcmVudCwgb3B0aW9uLCBvcHRpb25WYWx1ZSwgcHJvcE5hbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT3B0aW9uVmFsdWUocGFyZW50LCBuYW1lKSB7XG4gICAgICAgIC8vIHsgYTogXCJmb29cIiBiIHsgYzogXCJiYXJcIiB9IH1cbiAgICAgICAgaWYgKHNraXAoXCJ7XCIsIHRydWUpKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0UmVzdWx0ID0ge307XG5cbiAgICAgICAgICAgIHdoaWxlICghc2tpcChcIn1cIiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJlbmQgb2YgaW5wdXRcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHRva2VuO1xuXG4gICAgICAgICAgICAgICAgc2tpcChcIjpcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGVlaygpID09PSBcIntcIilcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU9wdGlvblZhbHVlKHBhcmVudCwgbmFtZSArIFwiLlwiICsgdG9rZW4pO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBlZWsoKSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uIChteV9vcHRpb24pID0ge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgcmVwZWF0ZWRfdmFsdWU6IFsgXCJmb29cIiwgXCJiYXJcIiBdXG4gICAgICAgICAgICAgICAgICAgIC8vIH07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwKFwiW1wiLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHJlYWRWYWx1ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKGxhc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChza2lwKFwiLFwiLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwKFwiXVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdFZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKHBhcmVudCwgbmFtZSArIFwiLlwiICsgdG9rZW4sIGxhc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlYWRWYWx1ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKHBhcmVudCwgbmFtZSArIFwiLlwiICsgdG9rZW4sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gb2JqZWN0UmVzdWx0W3Byb3BOYW1lXTtcblxuICAgICAgICAgICAgICAgIGlmIChwcmV2VmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW10uY29uY2F0KHByZXZWYWx1ZSkuY29uY2F0KHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIG9iamVjdFJlc3VsdFtwcm9wTmFtZV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIFNlbWljb2xvbnMgYW5kIGNvbW1hcyBjYW4gYmUgb3B0aW9uYWxcbiAgICAgICAgICAgICAgICBza2lwKFwiLFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaW1wbGVWYWx1ZSA9IHJlYWRWYWx1ZSh0cnVlKTtcbiAgICAgICAgc2V0T3B0aW9uKHBhcmVudCwgbmFtZSwgc2ltcGxlVmFsdWUpO1xuICAgICAgICByZXR1cm4gc2ltcGxlVmFsdWU7XG4gICAgICAgIC8vIERvZXMgbm90IGVuZm9yY2UgYSBkZWxpbWl0ZXIgdG8gYmUgdW5pdmVyc2FsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T3B0aW9uKHBhcmVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHBhcmVudC5zZXRPcHRpb24pXG4gICAgICAgICAgICBwYXJlbnQuc2V0T3B0aW9uKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRQYXJzZWRPcHRpb24ocGFyZW50LCBuYW1lLCB2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgICAgICAgaWYgKHBhcmVudC5zZXRQYXJzZWRPcHRpb24pXG4gICAgICAgICAgICBwYXJlbnQuc2V0UGFyc2VkT3B0aW9uKG5hbWUsIHZhbHVlLCBwcm9wTmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbmxpbmVPcHRpb25zKHBhcmVudCkge1xuICAgICAgICBpZiAoc2tpcChcIltcIiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihwYXJlbnQsIFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgfSB3aGlsZSAoc2tpcChcIixcIiwgdHJ1ZSkpO1xuICAgICAgICAgICAgc2tpcChcIl1cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNlcnZpY2UocGFyZW50LCB0b2tlbikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwic2VydmljZSBuYW1lXCIpO1xuXG4gICAgICAgIHZhciBzZXJ2aWNlID0gbmV3IFNlcnZpY2UodG9rZW4pO1xuICAgICAgICBpZkJsb2NrKHNlcnZpY2UsIGZ1bmN0aW9uIHBhcnNlU2VydmljZV9ibG9jayh0b2tlbikge1xuICAgICAgICAgICAgaWYgKHBhcnNlQ29tbW9uKHNlcnZpY2UsIHRva2VuKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFwicnBjXCIpXG4gICAgICAgICAgICAgICAgcGFyc2VNZXRob2Qoc2VydmljZSwgdG9rZW4pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChzZXJ2aWNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1ldGhvZChwYXJlbnQsIHRva2VuKSB7XG4gICAgICAgIC8vIEdldCB0aGUgY29tbWVudCBvZiB0aGUgcHJlY2VkaW5nIGxpbmUgbm93IChpZiBvbmUgZXhpc3RzKSBpbiBjYXNlIHRoZVxuICAgICAgICAvLyBtZXRob2QgaXMgZGVmaW5lZCBhY3Jvc3MgbXVsdGlwbGUgbGluZXMuXG4gICAgICAgIHZhciBjb21tZW50VGV4dCA9IGNtbnQoKTtcblxuICAgICAgICB2YXIgdHlwZSA9IHRva2VuO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwibmFtZVwiKTtcblxuICAgICAgICB2YXIgbmFtZSA9IHRva2VuLFxuICAgICAgICAgICAgcmVxdWVzdFR5cGUsIHJlcXVlc3RTdHJlYW0sXG4gICAgICAgICAgICByZXNwb25zZVR5cGUsIHJlc3BvbnNlU3RyZWFtO1xuXG4gICAgICAgIHNraXAoXCIoXCIpO1xuICAgICAgICBpZiAoc2tpcChcInN0cmVhbVwiLCB0cnVlKSlcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW0gPSB0cnVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIHJlcXVlc3RUeXBlID0gdG9rZW47XG4gICAgICAgIHNraXAoXCIpXCIpOyBza2lwKFwicmV0dXJuc1wiKTsgc2tpcChcIihcIik7XG4gICAgICAgIGlmIChza2lwKFwic3RyZWFtXCIsIHRydWUpKVxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW0gPSB0cnVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIHJlc3BvbnNlVHlwZSA9IHRva2VuO1xuICAgICAgICBza2lwKFwiKVwiKTtcblxuICAgICAgICB2YXIgbWV0aG9kID0gbmV3IE1ldGhvZChuYW1lLCB0eXBlLCByZXF1ZXN0VHlwZSwgcmVzcG9uc2VUeXBlLCByZXF1ZXN0U3RyZWFtLCByZXNwb25zZVN0cmVhbSk7XG4gICAgICAgIG1ldGhvZC5jb21tZW50ID0gY29tbWVudFRleHQ7XG4gICAgICAgIGlmQmxvY2sobWV0aG9kLCBmdW5jdGlvbiBwYXJzZU1ldGhvZF9ibG9jayh0b2tlbikge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24obWV0aG9kLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChtZXRob2QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXh0ZW5zaW9uKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcInJlZmVyZW5jZVwiKTtcblxuICAgICAgICB2YXIgcmVmZXJlbmNlID0gdG9rZW47XG4gICAgICAgIGlmQmxvY2sobnVsbCwgZnVuY3Rpb24gcGFyc2VFeHRlbnNpb25fYmxvY2sodG9rZW4pIHtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXBlYXRlZFwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHBhcmVudCwgdG9rZW4sIHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvbmFsXCI6XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm90bzMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQocGFyZW50LCBcInByb3RvM19vcHRpb25hbFwiLCByZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZChwYXJlbnQsIFwib3B0aW9uYWxcIiwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJvdG8zIHx8ICF0eXBlUmVmUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQocGFyZW50LCBcIm9wdGlvbmFsXCIsIHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW47XG4gICAgd2hpbGUgKCh0b2tlbiA9IG5leHQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuXG4gICAgICAgICAgICBjYXNlIFwicGFja2FnZVwiOlxuXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICAgICAgICAgIHBhcnNlUGFja2FnZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiaW1wb3J0XCI6XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VJbXBvcnQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInN5bnRheFwiOlxuXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICAgICAgICAgIHBhcnNlU3ludGF4KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjpcblxuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKHB0ciwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VDb21tb24ocHRyLCB0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2UuZmlsZW5hbWUgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIFwicGFja2FnZVwiICAgICA6IHBrZyxcbiAgICAgICAgXCJpbXBvcnRzXCIgICAgIDogaW1wb3J0cyxcbiAgICAgICAgIHdlYWtJbXBvcnRzICA6IHdlYWtJbXBvcnRzLFxuICAgICAgICAgc3ludGF4ICAgICAgIDogc3ludGF4LFxuICAgICAgICAgcm9vdCAgICAgICAgIDogcm9vdFxuICAgIH07XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiAucHJvdG8gc291cmNlIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBwYXJzZWQgY29udGVudHMuXG4gKiBAbmFtZSBwYXJzZVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFNvdXJjZSBjb250ZW50c1xuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBbb3B0aW9uc10gUGFyc2Ugb3B0aW9ucy4gRGVmYXVsdHMgdG8ge0BsaW5rIHBhcnNlLmRlZmF1bHRzfSB3aGVuIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7SVBhcnNlclJlc3VsdH0gUGFyc2VyIHJlc3VsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZpbGVuYW1lPW51bGwgQ3VycmVudGx5IHByb2Nlc3NpbmcgZmlsZSBuYW1lIGZvciBlcnJvciByZXBvcnRpbmcsIGlmIGtub3duXG4gKiBAcHJvcGVydHkge0lQYXJzZU9wdGlvbnN9IGRlZmF1bHRzIERlZmF1bHQge0BsaW5rIElQYXJzZU9wdGlvbnN9XG4gKiBAdmFyaWF0aW9uIDJcbiAqL1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJwYXJzZSIsImZpbGVuYW1lIiwiZGVmYXVsdHMiLCJrZWVwQ2FzZSIsInRva2VuaXplIiwicmVxdWlyZSIsIlJvb3QiLCJUeXBlIiwiRmllbGQiLCJNYXBGaWVsZCIsIk9uZU9mIiwiRW51bSIsIlNlcnZpY2UiLCJNZXRob2QiLCJ0eXBlcyIsInV0aWwiLCJiYXNlMTBSZSIsImJhc2UxME5lZ1JlIiwiYmFzZTE2UmUiLCJiYXNlMTZOZWdSZSIsImJhc2U4UmUiLCJiYXNlOE5lZ1JlIiwibnVtYmVyUmUiLCJuYW1lUmUiLCJ0eXBlUmVmUmUiLCJmcVR5cGVSZWZSZSIsInNvdXJjZSIsInJvb3QiLCJvcHRpb25zIiwicHJlZmVyVHJhaWxpbmdDb21tZW50IiwidG4iLCJhbHRlcm5hdGVDb21tZW50TW9kZSIsIm5leHQiLCJwdXNoIiwicGVlayIsInNraXAiLCJjbW50IiwiaGVhZCIsInBrZyIsImltcG9ydHMiLCJ3ZWFrSW1wb3J0cyIsInN5bnRheCIsImlzUHJvdG8zIiwicHRyIiwiYXBwbHlDYXNlIiwibmFtZSIsImNhbWVsQ2FzZSIsImlsbGVnYWwiLCJ0b2tlbiIsImluc2lkZVRyeUNhdGNoIiwiRXJyb3IiLCJsaW5lIiwicmVhZFN0cmluZyIsInZhbHVlcyIsImpvaW4iLCJyZWFkVmFsdWUiLCJhY2NlcHRUeXBlUmVmIiwicGFyc2VOdW1iZXIiLCJlIiwidGVzdCIsInJlYWRSYW5nZXMiLCJ0YXJnZXQiLCJhY2NlcHRTdHJpbmdzIiwic3RhcnQiLCJwYXJzZUlkIiwic2lnbiIsImNoYXJBdCIsInN1YnN0cmluZyIsIkluZmluaXR5IiwiTmFOIiwicGFyc2VJbnQiLCJwYXJzZUZsb2F0IiwiYWNjZXB0TmVnYXRpdmUiLCJwYXJzZVBhY2thZ2UiLCJ1bmRlZmluZWQiLCJkZWZpbmUiLCJwYXJzZUltcG9ydCIsIndoaWNoSW1wb3J0cyIsInBhcnNlU3ludGF4IiwicGFyc2VDb21tb24iLCJwYXJlbnQiLCJwYXJzZU9wdGlvbiIsInBhcnNlVHlwZSIsInBhcnNlRW51bSIsInBhcnNlU2VydmljZSIsInBhcnNlRXh0ZW5zaW9uIiwiaWZCbG9jayIsIm9iaiIsImZuSWYiLCJmbkVsc2UiLCJ0cmFpbGluZ0xpbmUiLCJjb21tZW50IiwidHlwZSIsInBhcnNlVHlwZV9ibG9jayIsInBhcnNlTWFwRmllbGQiLCJwYXJzZUZpZWxkIiwicGFyc2VPbmVPZiIsImV4dGVuc2lvbnMiLCJyZXNlcnZlZCIsImFkZCIsInJ1bGUiLCJleHRlbmQiLCJwYXJzZUdyb3VwIiwiZW5kc1dpdGgiLCJzdGFydHNXaXRoIiwiZmllbGQiLCJwYXJzZUZpZWxkX2Jsb2NrIiwicGFyc2VGaWVsZF9saW5lIiwicGFyc2VJbmxpbmVPcHRpb25zIiwib25lb2YiLCJzZXRPcHRpb24iLCJyZXBlYXRlZCIsInBhY2tlZCIsImJhc2ljIiwiZmllbGROYW1lIiwibGNGaXJzdCIsInVjRmlyc3QiLCJpZCIsImdyb3VwIiwicGFyc2VHcm91cF9ibG9jayIsImtleVR5cGUiLCJtYXBLZXkiLCJ2YWx1ZVR5cGUiLCJwYXJzZU1hcEZpZWxkX2Jsb2NrIiwicGFyc2VNYXBGaWVsZF9saW5lIiwicGFyc2VPbmVPZl9ibG9jayIsImVubSIsInBhcnNlRW51bV9ibG9jayIsInBhcnNlRW51bVZhbHVlIiwidmFsdWUiLCJkdW1teSIsInBhcnNlRW51bVZhbHVlX2Jsb2NrIiwicGFyc2VFbnVtVmFsdWVfbGluZSIsImlzQ3VzdG9tIiwib3B0aW9uIiwicHJvcE5hbWUiLCJzbGljZSIsIm9wdGlvblZhbHVlIiwicGFyc2VPcHRpb25WYWx1ZSIsInNldFBhcnNlZE9wdGlvbiIsIm9iamVjdFJlc3VsdCIsImxhc3RWYWx1ZSIsInByZXZWYWx1ZSIsImNvbmNhdCIsInNpbXBsZVZhbHVlIiwic2VydmljZSIsInBhcnNlU2VydmljZV9ibG9jayIsInBhcnNlTWV0aG9kIiwiY29tbWVudFRleHQiLCJyZXF1ZXN0VHlwZSIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVN0cmVhbSIsIm1ldGhvZCIsInBhcnNlTWV0aG9kX2Jsb2NrIiwicmVmZXJlbmNlIiwicGFyc2VFeHRlbnNpb25fYmxvY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Reader;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/protobufjs/src/util/minimal.js\");\nvar BufferReader; // cyclic\nvar LongBits = util.LongBits, utf8 = util.utf8;\n/* istanbul ignore next */ function indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */ function Reader(buffer) {\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */ this.buf = buffer;\n    /**\n     * Read buffer position.\n     * @type {number}\n     */ this.pos = 0;\n    /**\n     * Read buffer length.\n     * @type {number}\n     */ this.len = buffer.length;\n}\nvar create_array = typeof Uint8Array !== \"undefined\" ? function create_typed_array(buffer) {\n    if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);\n    throw Error(\"illegal buffer\");\n} : function create_array(buffer) {\n    if (Array.isArray(buffer)) return new Reader(buffer);\n    throw Error(\"illegal buffer\");\n};\nvar create = function create() {\n    return util.Buffer ? function create_buffer_setup(buffer) {\n        return (Reader.create = function create_buffer(buffer) {\n            return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer) : create_array(buffer);\n        })(buffer);\n    } : create_array;\n};\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */ Reader.create = create();\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */ Reader.prototype.uint32 = function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (this.buf[this.pos] & 127) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        /* istanbul ignore if */ if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n}();\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */ Reader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */ Reader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n/* eslint-disable no-invalid-this */ function readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) {\n        for(; i < 4; ++i){\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n        if (this.buf[this.pos++] < 128) return bits;\n        i = 0;\n    } else {\n        for(; i < 3; ++i){\n            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) {\n        for(; i < 5; ++i){\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n    } else {\n        for(; i < 5; ++i){\n            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n    }\n    /* istanbul ignore next */ throw Error(\"invalid varint encoding\");\n}\n/* eslint-enable no-invalid-this */ /**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */ Reader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\nfunction readFixed32_end(buf, end) {\n    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;\n}\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */ Reader.prototype.fixed32 = function read_fixed32() {\n    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */ Reader.prototype.sfixed32 = function read_sfixed32() {\n    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n/* eslint-disable no-invalid-this */ function readFixed64() {\n    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n/* eslint-enable no-invalid-this */ /**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */ Reader.prototype.float = function read_float() {\n    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */ Reader.prototype.double = function read_double() {\n    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */ Reader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(), start = this.pos, end = this.pos + length;\n    /* istanbul ignore if */ if (end > this.len) throw indexOutOfRange(this, length);\n    this.pos += length;\n    if (Array.isArray(this.buf)) return this.buf.slice(start, end);\n    if (start === end) {\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */ Reader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */ Reader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */ if (this.pos + length > this.len) throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);\n        }while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */ Reader.prototype.skipType = function(wireType) {\n    switch(wireType){\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while((wireType = this.uint32() & 7) !== 4){\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n        /* istanbul ignore next */ default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsT0FBWUMsbUJBQU9BLENBQUMsMkVBQWdCO0FBRXhDLElBQUlDLGNBQWMsU0FBUztBQUUzQixJQUFJQyxXQUFZSCxLQUFLRyxRQUFRLEVBQ3pCQyxPQUFZSixLQUFLSSxJQUFJO0FBRXpCLHdCQUF3QixHQUN4QixTQUFTQyxnQkFBZ0JDLE1BQU0sRUFBRUMsV0FBVztJQUN4QyxPQUFPQyxXQUFXLHlCQUF5QkYsT0FBT0csR0FBRyxHQUFHLFFBQVNGLENBQUFBLGVBQWUsS0FBSyxRQUFRRCxPQUFPSSxHQUFHO0FBQzNHO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTWCxPQUFPWSxNQUFNO0lBRWxCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsR0FBRyxHQUFHRDtJQUVYOzs7S0FHQyxHQUNELElBQUksQ0FBQ0YsR0FBRyxHQUFHO0lBRVg7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxHQUFHLEdBQUdDLE9BQU9FLE1BQU07QUFDNUI7QUFFQSxJQUFJQyxlQUFlLE9BQU9DLGVBQWUsY0FDbkMsU0FBU0MsbUJBQW1CTCxNQUFNO0lBQ2hDLElBQUlBLGtCQUFrQkksY0FBY0UsTUFBTUMsT0FBTyxDQUFDUCxTQUM5QyxPQUFPLElBQUlaLE9BQU9ZO0lBQ3RCLE1BQU1RLE1BQU07QUFDaEIsSUFFRSxTQUFTTCxhQUFhSCxNQUFNO0lBQzFCLElBQUlNLE1BQU1DLE9BQU8sQ0FBQ1AsU0FDZCxPQUFPLElBQUlaLE9BQU9ZO0lBQ3RCLE1BQU1RLE1BQU07QUFDaEI7QUFFSixJQUFJQyxTQUFTLFNBQVNBO0lBQ2xCLE9BQU9wQixLQUFLcUIsTUFBTSxHQUNaLFNBQVNDLG9CQUFvQlgsTUFBTTtRQUNqQyxPQUFPLENBQUNaLE9BQU9xQixNQUFNLEdBQUcsU0FBU0csY0FBY1osTUFBTTtZQUNqRCxPQUFPWCxLQUFL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WUFBWWEsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDUyxHQUFHLENBQUM7UUFDdEM7SUFFSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXIuanM/ZTVjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyUmVhZGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcbiAgICByZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIgKyByZWFkZXIucG9zICsgXCIgKyBcIiArICh3cml0ZUxlbmd0aCB8fCAxKSArIFwiID4gXCIgKyByZWFkZXIubGVuKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlYWRlciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihidWZmZXIpIHtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYnVmID0gYnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgcG9zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGJ1ZmZlci5sZW5ndGg7XG59XG5cbnZhciBjcmVhdGVfYXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9O1xuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlX2FycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICB9KShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogY3JlYXRlX2FycmF5O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWRlciB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fEJ1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqIEByZXR1cm5zIHtSZWFkZXJ8QnVmZmVyUmVhZGVyfSBBIHtAbGluayBCdWZmZXJSZWFkZXJ9IGlmIGBidWZmZXJgIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgYSB7QGxpbmsgUmVhZGVyfVxuICogQHRocm93cyB7RXJyb3J9IElmIGBidWZmZXJgIGlzIG5vdCBhIHZhbGlkIGJ1ZmZlclxuICovXG5SZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cblJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUudWludDMyID0gKGZ1bmN0aW9uIHJlYWRfdWludDMyX3NldHVwKCkge1xuICAgIHZhciB2YWx1ZSA9IDQyOTQ5NjcyOTU7IC8vIG9wdGltaXplciB0eXBlLWhpbnQsIHRlbmRzIHRvIGRlb3B0IG90aGVyd2lzZSAoPyEpXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRfdWludDMyKCkge1xuICAgICAgICB2YWx1ZSA9ICggICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcgICAgICAgKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgIDcpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAxNCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDIxKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmICAxNSkgPDwgMjgpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubGVuO1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gcmVhZF9pbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gcmVhZF9zaW50MzIoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy51aW50MzIoKTtcbiAgICByZXR1cm4gdmFsdWUgPj4+IDEgXiAtKHZhbHVlICYgMSkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCkge1xuICAgIC8vIHRlbmRzIHRvIGRlb3B0IHdpdGggbG9jYWwgdmFycyBmb3Igb2N0ZXQgZXRjLlxuICAgIHZhciBiaXRzID0gbmV3IExvbmdCaXRzKDAsIDApO1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAobG8pXG4gICAgICAgIGZvciAoOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAvLyAxc3QuLjR0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDV0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XG4gICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+ICA0KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyAxc3QuLjN0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDR0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChoaSlcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3VpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNzaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgYm9vbGVhbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSAhPT0gMDtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChidWYsIGVuZCkgeyAvLyBub3RlIHRoYXQgdGhpcyB1c2VzIGBlbmRgLCBub3QgYHBvc2BcbiAgICByZXR1cm4gKGJ1ZltlbmQgLSA0XVxuICAgICAgICAgIHwgYnVmW2VuZCAtIDNdIDw8IDhcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAyXSA8PCAxNlxuICAgICAgICAgIHwgYnVmW2VuZCAtIDFdIDw8IDI0KSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGEgc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNmaXhlZDMyID0gZnVuY3Rpb24gcmVhZF9zZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDY0KC8qIHRoaXM6IFJlYWRlciAqLykge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgOCk7XG5cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCksIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgemlnLXphZyBlbmNvZGVkIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjc2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgZmxvYXQgKDMyIGJpdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiByZWFkX2RvdWJsZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnVpbnQzMigpLFxuICAgICAgICBzdGFydCAgPSB0aGlzLnBvcyxcbiAgICAgICAgZW5kICAgID0gdGhpcy5wb3MgKyBsZW5ndGg7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZW5kID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuXG4gICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYnVmKSkgLy8gcGxhaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKHN0YXJ0ID09PSBlbmQpIHsgLy8gZml4IGZvciBJRSAxMC9XaW44IGFuZCBvdGhlcnMnIHN1YmFycmF5IHJldHVybmluZyBhcnJheSBvZiBzaXplIDFcbiAgICAgICAgdmFyIG5hdGl2ZUJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xuICAgICAgICByZXR1cm4gbmF0aXZlQnVmZmVyXG4gICAgICAgICAgICA/IG5hdGl2ZUJ1ZmZlci5hbGxvYygwKVxuICAgICAgICAgICAgOiBuZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zbGljZS5jYWxsKHRoaXMuYnVmLCBzdGFydCwgZW5kKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzdHJpbmcgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZygpIHtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLmJ5dGVzKCk7XG4gICAgcmV0dXJuIHV0ZjgucmVhZChieXRlcywgMCwgYnl0ZXMubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2Ugc2tpcHMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTGVuZ3RoIGlmIGtub3duLCBvdGhlcndpc2UgYSB2YXJpbnQgaXMgYXNzdW1lZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAobGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0aGlzLnBvcyArIGxlbmd0aCA+IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB3aXJlIHR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lyZVR5cGUgV2lyZSB0eXBlIHJlY2VpdmVkXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5za2lwVHlwZSA9IGZ1bmN0aW9uKHdpcmVUeXBlKSB7XG4gICAgc3dpdGNoICh3aXJlVHlwZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLnNraXAoOCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5za2lwKHRoaXMudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHdoaWxlICgod2lyZVR5cGUgPSB0aGlzLnVpbnQzMigpICYgNykgIT09IDQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBUeXBlKHdpcmVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0aGlzLnNraXAoNCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlICsgXCIgYXQgb2Zmc2V0IFwiICsgdGhpcy5wb3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyUmVhZGVyXykge1xuICAgIEJ1ZmZlclJlYWRlciA9IEJ1ZmZlclJlYWRlcl87XG4gICAgUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG5cbiAgICB2YXIgZm4gPSB1dGlsLkxvbmcgPyBcInRvTG9uZ1wiIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gXCJ0b051bWJlclwiO1xuICAgIHV0aWwubWVyZ2UoUmVhZGVyLnByb3RvdHlwZSwge1xuXG4gICAgICAgIGludDY0OiBmdW5jdGlvbiByZWFkX2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1aW50NjQ6IGZ1bmN0aW9uIHJlYWRfdWludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpbnQ2NDogZnVuY3Rpb24gcmVhZF9zaW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKS56ekRlY29kZSgpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9maXhlZDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNmaXhlZDY0OiBmdW5jdGlvbiByZWFkX3NmaXhlZDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJSZWFkZXIiLCJ1dGlsIiwicmVxdWlyZSIsIkJ1ZmZlclJlYWRlciIsIkxvbmdCaXRzIiwidXRmOCIsImluZGV4T3V0T2ZSYW5nZSIsInJlYWRlciIsIndyaXRlTGVuZ3RoIiwiUmFuZ2VFcnJvciIsInBvcyIsImxlbiIsImJ1ZmZlciIsImJ1ZiIsImxlbmd0aCIsImNyZWF0ZV9hcnJheSIsIlVpbnQ4QXJyYXkiLCJjcmVhdGVfdHlwZWRfYXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsImNyZWF0ZSIsIkJ1ZmZlciIsImNyZWF0ZV9idWZmZXJfc2V0dXAiLCJjcmVhdGVfYnVmZmVyIiwiaXNCdWZmZXIiLCJwcm90b3R5cGUiLCJfc2xpY2UiLCJzdWJhcnJheSIsInNsaWNlIiwidWludDMyIiwicmVhZF91aW50MzJfc2V0dXAiLCJ2YWx1ZSIsInJlYWRfdWludDMyIiwiaW50MzIiLCJyZWFkX2ludDMyIiwic2ludDMyIiwicmVhZF9zaW50MzIiLCJyZWFkTG9uZ1ZhcmludCIsImJpdHMiLCJpIiwibG8iLCJoaSIsImJvb2wiLCJyZWFkX2Jvb2wiLCJyZWFkRml4ZWQzMl9lbmQiLCJlbmQiLCJmaXhlZDMyIiwicmVhZF9maXhlZDMyIiwic2ZpeGVkMzIiLCJyZWFkX3NmaXhlZDMyIiwicmVhZEZpeGVkNjQiLCJmbG9hdCIsInJlYWRfZmxvYXQiLCJyZWFkRmxvYXRMRSIsImRvdWJsZSIsInJlYWRfZG91YmxlIiwicmVhZERvdWJsZUxFIiwiYnl0ZXMiLCJyZWFkX2J5dGVzIiwic3RhcnQiLCJuYXRpdmVCdWZmZXIiLCJhbGxvYyIsImNvbnN0cnVjdG9yIiwiY2FsbCIsInN0cmluZyIsInJlYWRfc3RyaW5nIiwicmVhZCIsInNraXAiLCJza2lwVHlwZSIsIndpcmVUeXBlIiwiX2NvbmZpZ3VyZSIsIkJ1ZmZlclJlYWRlcl8iLCJmbiIsIkxvbmciLCJtZXJnZSIsImludDY0IiwicmVhZF9pbnQ2NCIsInVpbnQ2NCIsInJlYWRfdWludDY0Iiwic2ludDY0IiwicmVhZF9zaW50NjQiLCJ6ekRlY29kZSIsImZpeGVkNjQiLCJyZWFkX2ZpeGVkNjQiLCJzZml4ZWQ2NCIsInJlYWRfc2ZpeGVkNjQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/reader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = BufferReader;\n// extends Reader\nvar Reader = __webpack_require__(/*! ./reader */ \"(ssr)/./node_modules/protobufjs/src/reader.js\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */ function BufferReader(buffer) {\n    Reader.call(this, buffer);\n/**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */ }\nBufferReader._configure = function() {\n    /* istanbul ignore else */ if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n/**\n * @override\n */ BufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */ BufferReader._configure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyX2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLGlCQUFpQjtBQUNqQixJQUFJQyxTQUFTQyxtQkFBT0EsQ0FBQywrREFBVTtBQUM5QkYsQ0FBQUEsYUFBYUcsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLE9BQU9FLFNBQVMsR0FBR0csV0FBVyxHQUFHTjtBQUV6RSxJQUFJTyxPQUFPTCxtQkFBT0EsQ0FBQywyRUFBZ0I7QUFFbkM7Ozs7OztDQU1DLEdBQ0QsU0FBU0YsYUFBYVEsTUFBTTtJQUN4QlAsT0FBT1EsSUFBSSxDQUFDLElBQUksRUFBRUQ7QUFFbEI7Ozs7S0FJQyxHQUNMO0FBRUFSLGFBQWFVLFVBQVUsR0FBRztJQUN0Qix3QkFBd0IsR0FDeEIsSUFBSUgsS0FBS0ksTUFBTSxFQUNYWCxhQUFhRyxTQUFTLENBQUNTLE1BQU0sR0FBR0wsS0FBS0ksTUFBTSxDQUFDUixTQUFTLENBQUNVLEtBQUs7QUFDbkU7QUFHQTs7Q0FFQyxHQUNEYixhQUFhRyxTQUFTLENBQUNXLE1BQU0sR0FBRyxTQUFTQztJQUNyQyxJQUFJQyxNQUFNLElBQUksQ0FBQ0MsTUFBTSxJQUFJLGVBQWU7SUFDeEMsT0FBTyxJQUFJLENBQUNDLEdBQUcsQ0FBQ0MsU0FBUyxHQUNuQixJQUFJLENBQUNELEdBQUcsQ0FBQ0MsU0FBUyxDQUFDLElBQUksQ0FBQ0MsR0FBRyxFQUFFLElBQUksQ0FBQ0EsR0FBRyxHQUFHQyxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDRixHQUFHLEdBQUdKLEtBQUssSUFBSSxDQUFDQSxHQUFHLEtBQ3pFLElBQUksQ0FBQ0UsR0FBRyxDQUFDSyxRQUFRLENBQUMsU0FBUyxJQUFJLENBQUNILEdBQUcsRUFBRSxJQUFJLENBQUNBLEdBQUcsR0FBR0MsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQ0YsR0FBRyxHQUFHSixLQUFLLElBQUksQ0FBQ0EsR0FBRztBQUMzRjtBQUVBOzs7OztDQUtDLEdBRURoQixhQUFhVSxVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXJfYnVmZmVyLmpzPzUwODciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlclJlYWRlcjtcblxuLy8gZXh0ZW5kcyBSZWFkZXJcbnZhciBSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG4oQnVmZmVyUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyUmVhZGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciByZWFkZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBSZWFkZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlclJlYWRlcihidWZmZXIpIHtcbiAgICBSZWFkZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQG5hbWUgQnVmZmVyUmVhZGVyI2J1ZlxuICAgICAqIEB0eXBlIHtCdWZmZXJ9XG4gICAgICovXG59XG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHV0aWwuQnVmZmVyKVxuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zbGljZTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZ19idWZmZXIoKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMudWludDMyKCk7IC8vIG1vZGlmaWVzIHBvc1xuICAgIHJldHVybiB0aGlzLmJ1Zi51dGY4U2xpY2VcbiAgICAgICAgPyB0aGlzLmJ1Zi51dGY4U2xpY2UodGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSlcbiAgICAgICAgOiB0aGlzLmJ1Zi50b1N0cmluZyhcInV0Zi04XCIsIHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQG5hbWUgQnVmZmVyUmVhZGVyI2J5dGVzXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFZhbHVlIHJlYWRcbiAqL1xuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJCdWZmZXJSZWFkZXIiLCJSZWFkZXIiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJ1dGlsIiwiYnVmZmVyIiwiY2FsbCIsIl9jb25maWd1cmUiLCJCdWZmZXIiLCJfc2xpY2UiLCJzbGljZSIsInN0cmluZyIsInJlYWRfc3RyaW5nX2J1ZmZlciIsImxlbiIsInVpbnQzMiIsImJ1ZiIsInV0ZjhTbGljZSIsInBvcyIsIk1hdGgiLCJtaW4iLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/reader_buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/root.js":
/*!*********************************************!*\
  !*** ./node_modules/protobufjs/src/root.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Root;\n// extends Namespace\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/protobufjs/src/namespace.js\");\n((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = \"Root\";\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/protobufjs/src/field.js\"), Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/protobufjs/src/enum.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/protobufjs/src/oneof.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\");\nvar Type, parse, common; // \"\n/**\n * Constructs a new root namespace instance.\n * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.\n * @extends NamespaceBase\n * @constructor\n * @param {Object.<string,*>} [options] Top level options\n */ function Root(options) {\n    Namespace.call(this, \"\", options);\n    /**\n     * Deferred extension fields.\n     * @type {Field[]}\n     */ this.deferred = [];\n    /**\n     * Resolved file names of loaded files.\n     * @type {string[]}\n     */ this.files = [];\n}\n/**\n * Loads a namespace descriptor into a root namespace.\n * @param {INamespace} json Nameespace descriptor\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted\n * @returns {Root} Root namespace\n */ Root.fromJSON = function fromJSON(json, root) {\n    if (!root) root = new Root();\n    if (json.options) root.setOptions(json.options);\n    return root.addJSON(json.nested);\n};\n/**\n * Resolves the path of an imported file, relative to the importing origin.\n * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.\n * @function\n * @param {string} origin The file name of the importing file\n * @param {string} target The file name being imported\n * @returns {string|null} Resolved path to `target` or `null` to skip the file\n */ Root.prototype.resolvePath = util.path.resolve;\n/**\n * Fetch content from file path or url\n * This method exists so you can override it with your own logic.\n * @function\n * @param {string} path File path or url\n * @param {FetchCallback} callback Callback function\n * @returns {undefined}\n */ Root.prototype.fetch = util.fetch;\n// A symbol-like function to safely signal synchronous loading\n/* istanbul ignore next */ function SYNC() {} // eslint-disable-line no-empty-function\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} options Parse options\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n */ Root.prototype.load = function load(filename, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    var self = this;\n    if (!callback) return util.asPromise(load, self, filename, options);\n    var sync = callback === SYNC; // undocumented\n    // Finishes loading by calling the callback (exactly once)\n    function finish(err, root) {\n        /* istanbul ignore if */ if (!callback) return;\n        var cb = callback;\n        callback = null;\n        if (sync) throw err;\n        cb(err, root);\n    }\n    // Bundled definition existence checking\n    function getBundledFileName(filename) {\n        var idx = filename.lastIndexOf(\"google/protobuf/\");\n        if (idx > -1) {\n            var altname = filename.substring(idx);\n            if (altname in common) return altname;\n        }\n        return null;\n    }\n    // Processes a single file\n    function process(filename, source) {\n        try {\n            if (util.isString(source) && source.charAt(0) === \"{\") source = JSON.parse(source);\n            if (!util.isString(source)) self.setOptions(source.options).addJSON(source.nested);\n            else {\n                parse.filename = filename;\n                var parsed = parse(source, self, options), resolved, i = 0;\n                if (parsed.imports) {\n                    for(; i < parsed.imports.length; ++i)if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i])) fetch(resolved);\n                }\n                if (parsed.weakImports) {\n                    for(i = 0; i < parsed.weakImports.length; ++i)if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i])) fetch(resolved, true);\n                }\n            }\n        } catch (err) {\n            finish(err);\n        }\n        if (!sync && !queued) finish(null, self); // only once anyway\n    }\n    // Fetches a single file\n    function fetch(filename, weak) {\n        filename = getBundledFileName(filename) || filename;\n        // Skip if already loaded / attempted\n        if (self.files.indexOf(filename) > -1) return;\n        self.files.push(filename);\n        // Shortcut bundled definitions\n        if (filename in common) {\n            if (sync) process(filename, common[filename]);\n            else {\n                ++queued;\n                setTimeout(function() {\n                    --queued;\n                    process(filename, common[filename]);\n                });\n            }\n            return;\n        }\n        // Otherwise fetch from disk or network\n        if (sync) {\n            var source;\n            try {\n                source = util.fs.readFileSync(filename).toString(\"utf8\");\n            } catch (err) {\n                if (!weak) finish(err);\n                return;\n            }\n            process(filename, source);\n        } else {\n            ++queued;\n            self.fetch(filename, function(err, source) {\n                --queued;\n                /* istanbul ignore if */ if (!callback) return; // terminated meanwhile\n                if (err) {\n                    /* istanbul ignore else */ if (!weak) finish(err);\n                    else if (!queued) finish(null, self);\n                    return;\n                }\n                process(filename, source);\n            });\n        }\n    }\n    var queued = 0;\n    // Assembling the root namespace doesn't require working type\n    // references anymore, so we can load everything in parallel\n    if (util.isString(filename)) filename = [\n        filename\n    ];\n    for(var i = 0, resolved; i < filename.length; ++i)if (resolved = self.resolvePath(\"\", filename[i])) fetch(resolved);\n    if (sync) return self;\n    if (!queued) finish(null, self);\n    return undefined;\n};\n// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @variation 2\n */ // function load(filename:string, callback:LoadCallback):undefined\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Promise<Root>} Promise\n * @variation 3\n */ // function load(filename:string, [options:IParseOptions]):Promise<Root>\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).\n * @function Root#loadSync\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n */ Root.prototype.loadSync = function loadSync(filename, options) {\n    if (!util.isNode) throw Error(\"not supported\");\n    return this.load(filename, options, SYNC);\n};\n/**\n * @override\n */ Root.prototype.resolveAll = function resolveAll() {\n    if (this.deferred.length) throw Error(\"unresolvable extensions: \" + this.deferred.map(function(field) {\n        return \"'extend \" + field.extend + \"' in \" + field.parent.fullName;\n    }).join(\", \"));\n    return Namespace.prototype.resolveAll.call(this);\n};\n// only uppercased (and thus conflict-free) children are exposed, see below\nvar exposeRe = /^[A-Z]/;\n/**\n * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.\n * @param {Root} root Root instance\n * @param {Field} field Declaring extension field witin the declaring type\n * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise\n * @inner\n * @ignore\n */ function tryHandleExtension(root, field) {\n    var extendedType = field.parent.lookup(field.extend);\n    if (extendedType) {\n        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);\n        //do not allow to extend same field twice to prevent the error\n        if (extendedType.get(sisterField.name)) {\n            return true;\n        }\n        sisterField.declaringField = field;\n        field.extensionField = sisterField;\n        extendedType.add(sisterField);\n        return true;\n    }\n    return false;\n}\n/**\n * Called when any object is added to this root or its sub-namespaces.\n * @param {ReflectionObject} object Object added\n * @returns {undefined}\n * @private\n */ Root.prototype._handleAdd = function _handleAdd(object) {\n    if (object instanceof Field) {\n        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField) {\n            if (!tryHandleExtension(this, object)) this.deferred.push(object);\n        }\n    } else if (object instanceof Enum) {\n        if (exposeRe.test(object.name)) object.parent[object.name] = object.values; // expose enum values as property of its parent\n    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {\n        if (object instanceof Type) for(var i = 0; i < this.deferred.length;)if (tryHandleExtension(this, this.deferred[i])) this.deferred.splice(i, 1);\n        else ++i;\n        for(var j = 0; j < /* initializes */ object.nestedArray.length; ++j)this._handleAdd(object._nestedArray[j]);\n        if (exposeRe.test(object.name)) object.parent[object.name] = object; // expose namespace as property of its parent\n    }\n// The above also adds uppercased (and thus conflict-free) nested types, services and enums as\n// properties of namespaces just like static code does. This allows using a .d.ts generated for\n// a static module with reflection-based solutions where the condition is met.\n};\n/**\n * Called when any object is removed from this root or its sub-namespaces.\n * @param {ReflectionObject} object Object removed\n * @returns {undefined}\n * @private\n */ Root.prototype._handleRemove = function _handleRemove(object) {\n    if (object instanceof Field) {\n        if (/* an extension field */ object.extend !== undefined) {\n            if (/* already handled */ object.extensionField) {\n                object.extensionField.parent.remove(object.extensionField);\n                object.extensionField = null;\n            } else {\n                var index = this.deferred.indexOf(object);\n                /* istanbul ignore else */ if (index > -1) this.deferred.splice(index, 1);\n            }\n        }\n    } else if (object instanceof Enum) {\n        if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose enum values\n    } else if (object instanceof Namespace) {\n        for(var i = 0; i < /* initializes */ object.nestedArray.length; ++i)this._handleRemove(object._nestedArray[i]);\n        if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose namespaces\n    }\n};\n// Sets up cyclic dependencies (called in index-light)\nRoot._configure = function(Type_, parse_, common_) {\n    Type = Type_;\n    parse = parse_;\n    common = common_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLG9CQUFvQjtBQUNwQixJQUFJQyxZQUFZQyxtQkFBT0EsQ0FBQyxxRUFBYTtBQUNwQyxFQUFDRixLQUFLRyxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0osVUFBVUUsU0FBUyxHQUFHRyxXQUFXLEdBQUdOLElBQUcsRUFBR08sU0FBUyxHQUFHO0FBRXZGLElBQUlDLFFBQVVOLG1CQUFPQSxDQUFDLDZEQUFTLEdBQzNCTyxPQUFVUCxtQkFBT0EsQ0FBQywyREFBUSxHQUMxQlEsUUFBVVIsbUJBQU9BLENBQUMsNkRBQVMsR0FDM0JTLE9BQVVULG1CQUFPQSxDQUFDLDJEQUFRO0FBRTlCLElBQUlVLE1BQ0FDLE9BQ0FDLFFBQVEsSUFBSTtBQUVoQjs7Ozs7O0NBTUMsR0FDRCxTQUFTZCxLQUFLZSxPQUFPO0lBQ2pCZCxVQUFVZSxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUlEO0lBRXpCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0UsUUFBUSxHQUFHLEVBQUU7SUFFbEI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtBQUNuQjtBQUVBOzs7OztDQUtDLEdBQ0RsQixLQUFLbUIsUUFBUSxHQUFHLFNBQVNBLFNBQVNDLElBQUksRUFBRUMsSUFBSTtJQUN4QyxJQUFJLENBQUNBLE1BQ0RBLE9BQU8sSUFBSXJCO0lBQ2YsSUFBSW9CLEtBQUtMLE9BQU8sRUFDWk0sS0FBS0MsVUFBVSxDQUFDRixLQUFLTCxPQUFPO0lBQ2hDLE9BQU9NLEtBQUtFLE9BQU8sQ0FBQ0gsS0FBS0ksTUFBTTtBQUNuQztBQUVBOzs7Ozs7O0NBT0MsR0FDRHhCLEtBQUtHLFNBQVMsQ0FBQ3NCLFdBQVcsR0FBR2QsS0FBS2UsSUFBSSxDQUFDQyxPQUFPO0FBRTlDOzs7Ozs7O0NBT0MsR0FDRDNCLEtBQUtHLFNBQVMsQ0FB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LFNBQVNlLElBQUksQ0FBQ0QsT0FBT0wsSUFBSSxHQUN6QixPQUFPSyxPQUFPakIsTUFBTSxDQUFDaUIsT0FBT0wsSUFBSSxDQUFDLEVBQUUsc0JBQXNCO0lBRWpFO0FBQ0o7QUFFQSxzREFBc0Q7QUFDdERuRixLQUFLa0csVUFBVSxHQUFHLFNBQVNDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxPQUFPO0lBQzdDekYsT0FBU3VGO0lBQ1R0RixRQUFTdUY7SUFDVHRGLFNBQVN1RjtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290LmpzPzY5MDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFJvb3Q7XG5cbi8vIGV4dGVuZHMgTmFtZXNwYWNlXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xuKChSb290LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gUm9vdCkuY2xhc3NOYW1lID0gXCJSb290XCI7XG5cbnZhciBGaWVsZCAgID0gcmVxdWlyZShcIi4vZmllbGRcIiksXG4gICAgRW51bSAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgT25lT2YgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpLFxuICAgIHV0aWwgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgVHlwZSwgICAvLyBjeWNsaWNcbiAgICBwYXJzZSwgIC8vIG1pZ2h0IGJlIGV4Y2x1ZGVkXG4gICAgY29tbW9uOyAvLyBcIlxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcm9vdCBuYW1lc3BhY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJvb3QgbmFtZXNwYWNlIHdyYXBwaW5nIGFsbCB0eXBlcywgZW51bXMsIHNlcnZpY2VzLCBzdWItbmFtZXNwYWNlcyBldGMuIHRoYXQgYmVsb25nIHRvZ2V0aGVyLlxuICogQGV4dGVuZHMgTmFtZXNwYWNlQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gVG9wIGxldmVsIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUm9vdChvcHRpb25zKSB7XG4gICAgTmFtZXNwYWNlLmNhbGwodGhpcywgXCJcIiwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnJlZCBleHRlbnNpb24gZmllbGRzLlxuICAgICAqIEB0eXBlIHtGaWVsZFtdfVxuICAgICAqL1xuICAgIHRoaXMuZGVmZXJyZWQgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIGZpbGUgbmFtZXMgb2YgbG9hZGVkIGZpbGVzLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGVzID0gW107XG59XG5cbi8qKlxuICogTG9hZHMgYSBuYW1lc3BhY2UgZGVzY3JpcHRvciBpbnRvIGEgcm9vdCBuYW1lc3BhY2UuXG4gKiBAcGFyYW0ge0lOYW1lc3BhY2V9IGpzb24gTmFtZWVzcGFjZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290IG5hbWVzcGFjZSwgZGVmYXVsdHMgdG8gY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkXG4gKiBAcmV0dXJucyB7Um9vdH0gUm9vdCBuYW1lc3BhY2VcbiAqL1xuUm9vdC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGpzb24sIHJvb3QpIHtcbiAgICBpZiAoIXJvb3QpXG4gICAgICAgIHJvb3QgPSBuZXcgUm9vdCgpO1xuICAgIGlmIChqc29uLm9wdGlvbnMpXG4gICAgICAgIHJvb3Quc2V0T3B0aW9ucyhqc29uLm9wdGlvbnMpO1xuICAgIHJldHVybiByb290LmFkZEpTT04oanNvbi5uZXN0ZWQpO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgcGF0aCBvZiBhbiBpbXBvcnRlZCBmaWxlLCByZWxhdGl2ZSB0byB0aGUgaW1wb3J0aW5nIG9yaWdpbi5cbiAqIFRoaXMgbWV0aG9kIGV4aXN0cyBzbyB5b3UgY2FuIG92ZXJyaWRlIGl0IHdpdGggeW91ciBvd24gbG9naWMgaW4gY2FzZSB5b3VyIGltcG9ydHMgYXJlIHNjYXR0ZXJlZCBvdmVyIG11bHRpcGxlIGRpcmVjdG9yaWVzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIFRoZSBmaWxlIG5hbWUgb2YgdGhlIGltcG9ydGluZyBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IFRoZSBmaWxlIG5hbWUgYmVpbmcgaW1wb3J0ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gUmVzb2x2ZWQgcGF0aCB0byBgdGFyZ2V0YCBvciBgbnVsbGAgdG8gc2tpcCB0aGUgZmlsZVxuICovXG5Sb290LnByb3RvdHlwZS5yZXNvbHZlUGF0aCA9IHV0aWwucGF0aC5yZXNvbHZlO1xuXG4vKipcbiAqIEZldGNoIGNvbnRlbnQgZnJvbSBmaWxlIHBhdGggb3IgdXJsXG4gKiBUaGlzIG1ldGhvZCBleGlzdHMgc28geW91IGNhbiBvdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duIGxvZ2ljLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBGaWxlIHBhdGggb3IgdXJsXG4gKiBAcGFyYW0ge0ZldGNoQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5Sb290LnByb3RvdHlwZS5mZXRjaCA9IHV0aWwuZmV0Y2g7XG5cbi8vIEEgc3ltYm9sLWxpa2UgZnVuY3Rpb24gdG8gc2FmZWx5IHNpZ25hbCBzeW5jaHJvbm91cyBsb2FkaW5nXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gU1lOQygpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIHRoaXMgcm9vdCBuYW1lc3BhY2UgYW5kIGNhbGxzIHRoZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBOYW1lcyBvZiBvbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBvcHRpb25zIFBhcnNlIG9wdGlvbnNcbiAqIEBwYXJhbSB7TG9hZENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuUm9vdC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHV0aWwuYXNQcm9taXNlKGxvYWQsIHNlbGYsIGZpbGVuYW1lLCBvcHRpb25zKTtcblxuICAgIHZhciBzeW5jID0gY2FsbGJhY2sgPT09IFNZTkM7IC8vIHVuZG9jdW1lbnRlZFxuXG4gICAgLy8gRmluaXNoZXMgbG9hZGluZyBieSBjYWxsaW5nIHRoZSBjYWxsYmFjayAoZXhhY3RseSBvbmNlKVxuICAgIGZ1bmN0aW9uIGZpbmlzaChlcnIsIHJvb3QpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBjYiA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGlmIChzeW5jKVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICBjYihlcnIsIHJvb3QpO1xuICAgIH1cblxuICAgIC8vIEJ1bmRsZWQgZGVmaW5pdGlvbiBleGlzdGVuY2UgY2hlY2tpbmdcbiAgICBmdW5jdGlvbiBnZXRCdW5kbGVkRmlsZU5hbWUoZmlsZW5hbWUpIHtcbiAgICAgICAgdmFyIGlkeCA9IGZpbGVuYW1lLmxhc3RJbmRleE9mKFwiZ29vZ2xlL3Byb3RvYnVmL1wiKTtcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICB2YXIgYWx0bmFtZSA9IGZpbGVuYW1lLnN1YnN0cmluZyhpZHgpO1xuICAgICAgICAgICAgaWYgKGFsdG5hbWUgaW4gY29tbW9uKSByZXR1cm4gYWx0bmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzZXMgYSBzaW5nbGUgZmlsZVxuICAgIGZ1bmN0aW9uIHByb2Nlc3MoZmlsZW5hbWUsIHNvdXJjZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcoc291cmNlKSAmJiBzb3VyY2UuY2hhckF0KDApID09PSBcIntcIilcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBKU09OLnBhcnNlKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTdHJpbmcoc291cmNlKSlcbiAgICAgICAgICAgICAgICBzZWxmLnNldE9wdGlvbnMoc291cmNlLm9wdGlvbnMpLmFkZEpTT04oc291cmNlLm5lc3RlZCk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZS5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZShzb3VyY2UsIHNlbGYsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCxcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5pbXBvcnRzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IHBhcnNlZC5pbXBvcnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkID0gZ2V0QnVuZGxlZEZpbGVOYW1lKHBhcnNlZC5pbXBvcnRzW2ldKSB8fCBzZWxmLnJlc29sdmVQYXRoKGZpbGVuYW1lLCBwYXJzZWQuaW1wb3J0c1tpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2gocmVzb2x2ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQud2Vha0ltcG9ydHMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJzZWQud2Vha0ltcG9ydHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQgPSBnZXRCdW5kbGVkRmlsZU5hbWUocGFyc2VkLndlYWtJbXBvcnRzW2ldKSB8fCBzZWxmLnJlc29sdmVQYXRoKGZpbGVuYW1lLCBwYXJzZWQud2Vha0ltcG9ydHNbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoKHJlc29sdmVkLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBmaW5pc2goZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN5bmMgJiYgIXF1ZXVlZClcbiAgICAgICAgICAgIGZpbmlzaChudWxsLCBzZWxmKTsgLy8gb25seSBvbmNlIGFueXdheVxuICAgIH1cblxuICAgIC8vIEZldGNoZXMgYSBzaW5nbGUgZmlsZVxuICAgIGZ1bmN0aW9uIGZldGNoKGZpbGVuYW1lLCB3ZWFrKSB7XG4gICAgICAgIGZpbGVuYW1lID0gZ2V0QnVuZGxlZEZpbGVOYW1lKGZpbGVuYW1lKSB8fCBmaWxlbmFtZTtcblxuICAgICAgICAvLyBTa2lwIGlmIGFscmVhZHkgbG9hZGVkIC8gYXR0ZW1wdGVkXG4gICAgICAgIGlmIChzZWxmLmZpbGVzLmluZGV4T2YoZmlsZW5hbWUpID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNlbGYuZmlsZXMucHVzaChmaWxlbmFtZSk7XG5cbiAgICAgICAgLy8gU2hvcnRjdXQgYnVuZGxlZCBkZWZpbml0aW9uc1xuICAgICAgICBpZiAoZmlsZW5hbWUgaW4gY29tbW9uKSB7XG4gICAgICAgICAgICBpZiAoc3luYylcbiAgICAgICAgICAgICAgICBwcm9jZXNzKGZpbGVuYW1lLCBjb21tb25bZmlsZW5hbWVdKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICsrcXVldWVkO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC0tcXVldWVkO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKGZpbGVuYW1lLCBjb21tb25bZmlsZW5hbWVdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSBmZXRjaCBmcm9tIGRpc2sgb3IgbmV0d29ya1xuICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gdXRpbC5mcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUpLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICghd2VhaylcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2VzcyhmaWxlbmFtZSwgc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrcXVldWVkO1xuICAgICAgICAgICAgc2VsZi5mZXRjaChmaWxlbmFtZSwgZnVuY3Rpb24oZXJyLCBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAtLXF1ZXVlZDtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHRlcm1pbmF0ZWQgbWVhbndoaWxlXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdlYWspXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXF1ZXVlZCkgLy8gY2FuJ3QgYmUgY292ZXJlZCByZWxpYWJseVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoKG51bGwsIHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb2Nlc3MoZmlsZW5hbWUsIHNvdXJjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcXVldWVkID0gMDtcblxuICAgIC8vIEFzc2VtYmxpbmcgdGhlIHJvb3QgbmFtZXNwYWNlIGRvZXNuJ3QgcmVxdWlyZSB3b3JraW5nIHR5cGVcbiAgICAvLyByZWZlcmVuY2VzIGFueW1vcmUsIHNvIHdlIGNhbiBsb2FkIGV2ZXJ5dGhpbmcgaW4gcGFyYWxsZWxcbiAgICBpZiAodXRpbC5pc1N0cmluZyhmaWxlbmFtZSkpXG4gICAgICAgIGZpbGVuYW1lID0gWyBmaWxlbmFtZSBdO1xuICAgIGZvciAodmFyIGkgPSAwLCByZXNvbHZlZDsgaSA8IGZpbGVuYW1lLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAocmVzb2x2ZWQgPSBzZWxmLnJlc29sdmVQYXRoKFwiXCIsIGZpbGVuYW1lW2ldKSlcbiAgICAgICAgICAgIGZldGNoKHJlc29sdmVkKTtcblxuICAgIGlmIChzeW5jKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAoIXF1ZXVlZClcbiAgICAgICAgZmluaXNoKG51bGwsIHNlbGYpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuLy8gZnVuY3Rpb24gbG9hZChmaWxlbmFtZTpzdHJpbmcsIG9wdGlvbnM6SVBhcnNlT3B0aW9ucywgY2FsbGJhY2s6TG9hZENhbGxiYWNrKTp1bmRlZmluZWRcblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIHRoaXMgcm9vdCBuYW1lc3BhY2UgYW5kIGNhbGxzIHRoZSBjYWxsYmFjay5cbiAqIEBmdW5jdGlvbiBSb290I2xvYWRcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBOYW1lcyBvZiBvbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtMb2FkQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHZhcmlhdGlvbiAyXG4gKi9cbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBjYWxsYmFjazpMb2FkQ2FsbGJhY2spOnVuZGVmaW5lZFxuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gdGhpcyByb290IG5hbWVzcGFjZSBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAZnVuY3Rpb24gUm9vdCNsb2FkXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgTmFtZXMgb2Ygb25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7SVBhcnNlT3B0aW9uc30gW29wdGlvbnNdIFBhcnNlIG9wdGlvbnMuIERlZmF1bHRzIHRvIHtAbGluayBwYXJzZS5kZWZhdWx0c30gd2hlbiBvbWl0dGVkLlxuICogQHJldHVybnMge1Byb21pc2U8Um9vdD59IFByb21pc2VcbiAqIEB2YXJpYXRpb24gM1xuICovXG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgW29wdGlvbnM6SVBhcnNlT3B0aW9uc10pOlByb21pc2U8Um9vdD5cblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGxvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gdGhpcyByb290IG5hbWVzcGFjZSAobm9kZSBvbmx5KS5cbiAqIEBmdW5jdGlvbiBSb290I2xvYWRTeW5jXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgTmFtZXMgb2Ygb25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7SVBhcnNlT3B0aW9uc30gW29wdGlvbnNdIFBhcnNlIG9wdGlvbnMuIERlZmF1bHRzIHRvIHtAbGluayBwYXJzZS5kZWZhdWx0c30gd2hlbiBvbWl0dGVkLlxuICogQHJldHVybnMge1Jvb3R9IFJvb3QgbmFtZXNwYWNlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgc3luY2hyb25vdXMgZmV0Y2hpbmcgaXMgbm90IHN1cHBvcnRlZCAoaS5lLiBpbiBicm93c2Vycykgb3IgaWYgYSBmaWxlJ3Mgc3ludGF4IGlzIGludmFsaWRcbiAqL1xuUm9vdC5wcm90b3R5cGUubG9hZFN5bmMgPSBmdW5jdGlvbiBsb2FkU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGlmICghdXRpbC5pc05vZGUpXG4gICAgICAgIHRocm93IEVycm9yKFwibm90IHN1cHBvcnRlZFwiKTtcbiAgICByZXR1cm4gdGhpcy5sb2FkKGZpbGVuYW1lLCBvcHRpb25zLCBTWU5DKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblJvb3QucHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbiByZXNvbHZlQWxsKCkge1xuICAgIGlmICh0aGlzLmRlZmVycmVkLmxlbmd0aClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJ1bnJlc29sdmFibGUgZXh0ZW5zaW9uczogXCIgKyB0aGlzLmRlZmVycmVkLm1hcChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiJ2V4dGVuZCBcIiArIGZpZWxkLmV4dGVuZCArIFwiJyBpbiBcIiArIGZpZWxkLnBhcmVudC5mdWxsTmFtZTtcbiAgICAgICAgfSkuam9pbihcIiwgXCIpKTtcbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5yZXNvbHZlQWxsLmNhbGwodGhpcyk7XG59O1xuXG4vLyBvbmx5IHVwcGVyY2FzZWQgKGFuZCB0aHVzIGNvbmZsaWN0LWZyZWUpIGNoaWxkcmVuIGFyZSBleHBvc2VkLCBzZWUgYmVsb3dcbnZhciBleHBvc2VSZSA9IC9eW0EtWl0vO1xuXG4vKipcbiAqIEhhbmRsZXMgYSBkZWZlcnJlZCBkZWNsYXJpbmcgZXh0ZW5zaW9uIGZpZWxkIGJ5IGNyZWF0aW5nIGEgc2lzdGVyIGZpZWxkIHRvIHJlcHJlc2VudCBpdCB3aXRoaW4gaXRzIGV4dGVuZGVkIHR5cGUuXG4gKiBAcGFyYW0ge1Jvb3R9IHJvb3QgUm9vdCBpbnN0YW5jZVxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgRGVjbGFyaW5nIGV4dGVuc2lvbiBmaWVsZCB3aXRpbiB0aGUgZGVjbGFyaW5nIHR5cGVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgc3VjY2Vzc2Z1bGx5IGFkZGVkIHRvIHRoZSBleHRlbmRlZCB0eXBlLCBgZmFsc2VgIG90aGVyd2lzZVxuICogQGlubmVyXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIHRyeUhhbmRsZUV4dGVuc2lvbihyb290LCBmaWVsZCkge1xuICAgIHZhciBleHRlbmRlZFR5cGUgPSBmaWVsZC5wYXJlbnQubG9va3VwKGZpZWxkLmV4dGVuZCk7XG4gICAgaWYgKGV4dGVuZGVkVHlwZSkge1xuICAgICAgICB2YXIgc2lzdGVyRmllbGQgPSBuZXcgRmllbGQoZmllbGQuZnVsbE5hbWUsIGZpZWxkLmlkLCBmaWVsZC50eXBlLCBmaWVsZC5ydWxlLCB1bmRlZmluZWQsIGZpZWxkLm9wdGlvbnMpO1xuICAgICAgICAvL2RvIG5vdCBhbGxvdyB0byBleHRlbmQgc2FtZSBmaWVsZCB0d2ljZSB0byBwcmV2ZW50IHRoZSBlcnJvclxuICAgICAgICBpZiAoZXh0ZW5kZWRUeXBlLmdldChzaXN0ZXJGaWVsZC5uYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc2lzdGVyRmllbGQuZGVjbGFyaW5nRmllbGQgPSBmaWVsZDtcbiAgICAgICAgZmllbGQuZXh0ZW5zaW9uRmllbGQgPSBzaXN0ZXJGaWVsZDtcbiAgICAgICAgZXh0ZW5kZWRUeXBlLmFkZChzaXN0ZXJGaWVsZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gYW55IG9iamVjdCBpcyBhZGRlZCB0byB0aGlzIHJvb3Qgb3IgaXRzIHN1Yi1uYW1lc3BhY2VzLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgT2JqZWN0IGFkZGVkXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqL1xuUm9vdC5wcm90b3R5cGUuX2hhbmRsZUFkZCA9IGZ1bmN0aW9uIF9oYW5kbGVBZGQob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkKSB7XG5cbiAgICAgICAgaWYgKC8qIGFuIGV4dGVuc2lvbiBmaWVsZCAoaW1wbGllcyBub3QgcGFydCBvZiBhIG9uZW9mKSAqLyBvYmplY3QuZXh0ZW5kICE9PSB1bmRlZmluZWQgJiYgLyogbm90IGFscmVhZHkgaGFuZGxlZCAqLyAhb2JqZWN0LmV4dGVuc2lvbkZpZWxkKVxuICAgICAgICAgICAgaWYgKCF0cnlIYW5kbGVFeHRlbnNpb24odGhpcywgb2JqZWN0KSlcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkLnB1c2gob2JqZWN0KTtcblxuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRW51bSkge1xuXG4gICAgICAgIGlmIChleHBvc2VSZS50ZXN0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdID0gb2JqZWN0LnZhbHVlczsgLy8gZXhwb3NlIGVudW0gdmFsdWVzIGFzIHByb3BlcnR5IG9mIGl0cyBwYXJlbnRcblxuICAgIH0gZWxzZSBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBPbmVPZikpIC8qIGV2ZXJ5dGhpbmcgZWxzZSBpcyBhIG5hbWVzcGFjZSAqLyB7XG5cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFR5cGUpIC8vIFRyeSB0byBoYW5kbGUgYW55IGRlZmVycmVkIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kZWZlcnJlZC5sZW5ndGg7KVxuICAgICAgICAgICAgICAgIGlmICh0cnlIYW5kbGVFeHRlbnNpb24odGhpcywgdGhpcy5kZWZlcnJlZFtpXSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IC8qIGluaXRpYWxpemVzICovIG9iamVjdC5uZXN0ZWRBcnJheS5sZW5ndGg7ICsraikgLy8gcmVjdXJzZSBpbnRvIHRoZSBuYW1lc3BhY2VcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUFkZChvYmplY3QuX25lc3RlZEFycmF5W2pdKTtcbiAgICAgICAgaWYgKGV4cG9zZVJlLnRlc3Qob2JqZWN0Lm5hbWUpKVxuICAgICAgICAgICAgb2JqZWN0LnBhcmVudFtvYmplY3QubmFtZV0gPSBvYmplY3Q7IC8vIGV4cG9zZSBuYW1lc3BhY2UgYXMgcHJvcGVydHkgb2YgaXRzIHBhcmVudFxuICAgIH1cblxuICAgIC8vIFRoZSBhYm92ZSBhbHNvIGFkZHMgdXBwZXJjYXNlZCAoYW5kIHRodXMgY29uZmxpY3QtZnJlZSkgbmVzdGVkIHR5cGVzLCBzZXJ2aWNlcyBhbmQgZW51bXMgYXNcbiAgICAvLyBwcm9wZXJ0aWVzIG9mIG5hbWVzcGFjZXMganVzdCBsaWtlIHN0YXRpYyBjb2RlIGRvZXMuIFRoaXMgYWxsb3dzIHVzaW5nIGEgLmQudHMgZ2VuZXJhdGVkIGZvclxuICAgIC8vIGEgc3RhdGljIG1vZHVsZSB3aXRoIHJlZmxlY3Rpb24tYmFzZWQgc29sdXRpb25zIHdoZXJlIHRoZSBjb25kaXRpb24gaXMgbWV0LlxufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBhbnkgb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSB0aGlzIHJvb3Qgb3IgaXRzIHN1Yi1uYW1lc3BhY2VzLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgT2JqZWN0IHJlbW92ZWRcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5Sb290LnByb3RvdHlwZS5faGFuZGxlUmVtb3ZlID0gZnVuY3Rpb24gX2hhbmRsZVJlbW92ZShvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRmllbGQpIHtcblxuICAgICAgICBpZiAoLyogYW4gZXh0ZW5zaW9uIGZpZWxkICovIG9iamVjdC5leHRlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKC8qIGFscmVhZHkgaGFuZGxlZCAqLyBvYmplY3QuZXh0ZW5zaW9uRmllbGQpIHsgLy8gcmVtb3ZlIGl0cyBzaXN0ZXIgZmllbGRcbiAgICAgICAgICAgICAgICBvYmplY3QuZXh0ZW5zaW9uRmllbGQucGFyZW50LnJlbW92ZShvYmplY3QuZXh0ZW5zaW9uRmllbGQpO1xuICAgICAgICAgICAgICAgIG9iamVjdC5leHRlbnNpb25GaWVsZCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBjYW5jZWwgdGhlIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZGVmZXJyZWQuaW5kZXhPZihvYmplY3QpO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBFbnVtKSB7XG5cbiAgICAgICAgaWYgKGV4cG9zZVJlLnRlc3Qob2JqZWN0Lm5hbWUpKVxuICAgICAgICAgICAgZGVsZXRlIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdOyAvLyB1bmV4cG9zZSBlbnVtIHZhbHVlc1xuXG4gICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOYW1lc3BhY2UpIHtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IC8qIGluaXRpYWxpemVzICovIG9iamVjdC5uZXN0ZWRBcnJheS5sZW5ndGg7ICsraSkgLy8gcmVjdXJzZSBpbnRvIHRoZSBuYW1lc3BhY2VcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVJlbW92ZShvYmplY3QuX25lc3RlZEFycmF5W2ldKTtcblxuICAgICAgICBpZiAoZXhwb3NlUmUudGVzdChvYmplY3QubmFtZSkpXG4gICAgICAgICAgICBkZWxldGUgb2JqZWN0LnBhcmVudFtvYmplY3QubmFtZV07IC8vIHVuZXhwb3NlIG5hbWVzcGFjZXNcblxuICAgIH1cbn07XG5cbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxuUm9vdC5fY29uZmlndXJlID0gZnVuY3Rpb24oVHlwZV8sIHBhcnNlXywgY29tbW9uXykge1xuICAgIFR5cGUgICA9IFR5cGVfO1xuICAgIHBhcnNlICA9IHBhcnNlXztcbiAgICBjb21tb24gPSBjb21tb25fO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiUm9vdCIsIk5hbWVzcGFjZSIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImNsYXNzTmFtZSIsIkZpZWxkIiwiRW51bSIsIk9uZU9mIiwidXRpbCIsIlR5cGUiLCJwYXJzZSIsImNvbW1vbiIsIm9wdGlvbnMiLCJjYWxsIiwiZGVmZXJyZWQiLCJmaWxlcyIsImZyb21KU09OIiwianNvbiIsInJvb3QiLCJzZXRPcHRpb25zIiwiYWRkSlNPTiIsIm5lc3RlZCIsInJlc29sdmVQYXRoIiwicGF0aCIsInJlc29sdmUiLCJmZXRjaCIsIlNZTkMiLCJsb2FkIiwiZmlsZW5hbWUiLCJjYWxsYmFjayIsInVuZGVmaW5lZCIsInNlbGYiLCJhc1Byb21pc2UiLCJzeW5jIiwiZmluaXNoIiwiZXJyIiwiY2IiLCJnZXRCdW5kbGVkRmlsZU5hbWUiLCJpZHgiLCJsYXN0SW5kZXhPZiIsImFsdG5hbWUiLCJzdWJzdHJpbmciLCJwcm9jZXNzIiwic291cmNlIiwiaXNTdHJpbmciLCJjaGFyQXQiLCJKU09OIiwicGFyc2VkIiwicmVzb2x2ZWQiLCJpIiwiaW1wb3J0cyIsImxlbmd0aCIsIndlYWtJbXBvcnRzIiwicXVldWVkIiwid2VhayIsImluZGV4T2YiLCJwdXNoIiwic2V0VGltZW91dCIsImZzIiwicmVhZEZpbGVTeW5jIiwidG9TdHJpbmciLCJsb2FkU3luYyIsImlzTm9kZSIsIkVycm9yIiwicmVzb2x2ZUFsbCIsIm1hcCIsImZpZWxkIiwiZXh0ZW5kIiwicGFyZW50IiwiZnVsbE5hbWUiLCJqb2luIiwiZXhwb3NlUmUiLCJ0cnlIYW5kbGVFeHRlbnNpb24iLCJleHRlbmRlZFR5cGUiLCJsb29rdXAiLCJzaXN0ZXJGaWVsZCIsImlkIiwidHlwZSIsInJ1bGUiLCJnZXQiLCJuYW1lIiwiZGVjbGFyaW5nRmllbGQiLCJleHRlbnNpb25GaWVsZCIsImFkZCIsIl9oYW5kbGVBZGQiLCJvYmplY3QiLCJ0ZXN0IiwidmFsdWVzIiwic3BsaWNlIiwiaiIsIm5lc3RlZEFycmF5IiwiX25lc3RlZEFycmF5IiwiX2hhbmRsZVJlbW92ZSIsInJlbW92ZSIsImluZGV4IiwiX2NvbmZpZ3VyZSIsIlR5cGVfIiwicGFyc2VfIiwiY29tbW9uXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/root.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\nmodule.exports = {}; /**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHLENBQUMsR0FFbEI7Ozs7Ozs7Ozs7Ozs7O0NBY0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3RzLmpzPzFmOTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKipcbiAqIE5hbWVkIHJvb3RzLlxuICogVGhpcyBpcyB3aGVyZSBwYmpzIHN0b3JlcyBnZW5lcmF0ZWQgc3RydWN0dXJlcyAodGhlIG9wdGlvbiBgLXIsIC0tcm9vdGAgc3BlY2lmaWVzIGEgbmFtZSkuXG4gKiBDYW4gYWxzbyBiZSB1c2VkIG1hbnVhbGx5IHRvIG1ha2Ugcm9vdHMgYXZhaWxhYmxlIGFjcm9zcyBtb2R1bGVzLlxuICogQG5hbWUgcm9vdHNcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSb290Pn1cbiAqIEBleGFtcGxlXG4gKiAvLyBwYmpzIC1yIG15cm9vdCAtbyBjb21waWxlZC5qcyAuLi5cbiAqXG4gKiAvLyBpbiBhbm90aGVyIG1vZHVsZTpcbiAqIHJlcXVpcmUoXCIuL2NvbXBpbGVkLmpzXCIpO1xuICpcbiAqIC8vIGluIGFueSBzdWJzZXF1ZW50IG1vZHVsZTpcbiAqIHZhciByb290ID0gcHJvdG9idWYucm9vdHNbXCJteXJvb3RcIl07XG4gKi9cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/roots.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Streaming RPC helpers.\n * @namespace\n */ var rpc = exports;\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */ /**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */ rpc.Service = __webpack_require__(/*! ./rpc/service */ \"(ssr)/./node_modules/protobufjs/src/rpc/service.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWI7OztDQUdDLEdBQ0QsSUFBSUEsTUFBTUM7QUFFVjs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUVEOzs7Ozs7O0NBT0MsR0FFREQsSUFBSUUsT0FBTyxHQUFHQyxtQkFBT0EsQ0FBQyx5RUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXByb2plY3QvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzPzRjY2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogU3RyZWFtaW5nIFJQQyBoZWxwZXJzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgcnBjID0gZXhwb3J0cztcblxuLyoqXG4gKiBSUEMgaW1wbGVtZW50YXRpb24gcGFzc2VkIHRvIHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0gcGVyZm9ybWluZyBhIHNlcnZpY2UgcmVxdWVzdCBvbiBuZXR3b3JrIGxldmVsLCBpLmUuIGJ5IHV0aWxpemluZyBodHRwIHJlcXVlc3RzIG9yIHdlYnNvY2tldHMuXG4gKiBAdHlwZWRlZiBSUENJbXBsXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxNZXNzYWdlPHt9PixNZXNzYWdlPHt9Pj59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZCBiZWluZyBjYWxsZWRcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcmVxdWVzdERhdGEgUmVxdWVzdCBkYXRhXG4gKiBAcGFyYW0ge1JQQ0ltcGxDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAZXhhbXBsZVxuICogZnVuY3Rpb24gcnBjSW1wbChtZXRob2QsIHJlcXVlc3REYXRhLCBjYWxsYmFjaykge1xuICogICAgIGlmIChwcm90b2J1Zi51dGlsLmxjRmlyc3QobWV0aG9kLm5hbWUpICE9PSBcIm15TWV0aG9kXCIpIC8vIGNvbXBhdGlibGUgd2l0aCBzdGF0aWMgY29kZVxuICogICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggbWV0aG9kXCIpO1xuICogICAgIGFzeW5jaHJvbm91c2x5T2J0YWluQVJlc3BvbnNlKHJlcXVlc3REYXRhLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlRGF0YSkge1xuICogICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlRGF0YSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKi9cblxuLyoqXG4gKiBOb2RlLXN0eWxlIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIFJQQ0ltcGx9LlxuICogQHR5cGVkZWYgUlBDSW1wbENhbGxiYWNrXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnksIG90aGVyd2lzZSBgbnVsbGBcbiAqIEBwYXJhbSB7VWludDhBcnJheXxudWxsfSBbcmVzcG9uc2VdIFJlc3BvbnNlIGRhdGEgb3IgYG51bGxgIHRvIHNpZ25hbCBlbmQgb2Ygc3RyZWFtLCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5ycGMuU2VydmljZSA9IHJlcXVpcmUoXCIuL3JwYy9zZXJ2aWNlXCIpO1xuIl0sIm5hbWVzIjpbInJwYyIsImV4cG9ydHMiLCJTZXJ2aWNlIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/rpc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Service;\nvar util = __webpack_require__(/*! ../util/minimal */ \"(ssr)/./node_modules/protobufjs/src/util/minimal.js\");\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */ /**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */ /**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */ function Service(rpcImpl, requestDelimited, responseDelimited) {\n    if (typeof rpcImpl !== \"function\") throw TypeError(\"rpcImpl must be a function\");\n    util.EventEmitter.call(this);\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */ this.rpcImpl = rpcImpl;\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */ this.requestDelimited = Boolean(requestDelimited);\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */ this.responseDelimited = Boolean(responseDelimited);\n}\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */ Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n    if (!request) throw TypeError(\"request must be specified\");\n    var self = this;\n    if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n    if (!self.rpcImpl) {\n        setTimeout(function() {\n            callback(Error(\"already ended\"));\n        }, 0);\n        return undefined;\n    }\n    try {\n        return self.rpcImpl(method, requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(), function rpcCallback(err, response) {\n            if (err) {\n                self.emit(\"error\", err, method);\n                return callback(err);\n            }\n            if (response === null) {\n                self.end(/* endedByRPC */ true);\n                return undefined;\n            }\n            if (!(response instanceof responseCtor)) {\n                try {\n                    response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                } catch (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n            }\n            self.emit(\"data\", response, method);\n            return callback(null, response);\n        });\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() {\n            callback(err);\n        }, 0);\n        return undefined;\n    }\n};\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */ Service.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQyw0RUFBaUI7QUFFcEMsdUJBQXVCO0FBQ3RCRixDQUFBQSxRQUFRRyxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0osS0FBS0ssWUFBWSxDQUFDSCxTQUFTLEdBQUdJLFdBQVcsR0FBR1A7QUFFL0U7Ozs7Ozs7Ozs7Q0FVQyxHQUVEOzs7Ozs7Ozs7Q0FTQyxHQUVEOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNBLFFBQVFRLE9BQU8sRUFBRUMsZ0JBQWdCLEVBQUVDLGlCQUFpQjtJQUV6RCxJQUFJLE9BQU9GLFlBQVksWUFDbkIsTUFBTUcsVUFBVTtJQUVwQlYsS0FBS0ssWUFBWSxDQUFDTSxJQUFJLENBQUMsSUFBSTtJQUUzQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNKLE9BQU8sR0FBR0E7SUFFZjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHSSxRQUFRSjtJQUVoQzs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLGlCQUFpQixHQUFHRyxRQUFRSDtBQUNyQztBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRFYsUUFBUUcsU0FBUyxDQUFDVyxPQUFPLEdBQUcsU0FBU0EsUUFBUUMsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRUMsT0FBTyxFQUFFQyxRQUFRO0lBRTdGLElBQUksQ0FBQ0QsU0FDRCxNQUFNUCxVQUFVO0lBRXBCLElBQUlTLE9BQU8sSUFBSTtJQUNmLElBQUksQ0FBQ0QsVUFDRCxPQUFPbEIsS0FBS29CLFNBQVMsQ0FBQ1AsU0FBU00sTUFBTUwsUUFBUUMsYUFBYUMsY0FBY0M7SUFFNUUsSUFBSSxDQUFDRSxLQUFLWixPQUFPLEVBQUU7UUFDZmMsV0FBVztZQUFhSCxTQUFTSSxNQUFNO1FBQW1CLEdBQUc7UUFDN0QsT0FBT0M7SUFDWDtJQUVBLElBQUk7UUFDQSxPQUFPSixLQUFLWixPQUFPLENBQ2ZPLFFBQ0FDLFdBQVcsQ0FBQ0ksS0FBS1gsZ0JBQWdCLEdBQUcsb0JBQW9CLFNBQVMsQ0FBQ1MsU0FBU08sTUFBTSxJQUNqRixTQUFTQyxZQUFZQyxHQUFHLEVBQUVDLFFBQVE7WUFFOUIsSUFBSUQsS0FBSztnQkFDTFAsS0FBS1MsSUFBSSxDQUFDLFNBQVNGLEtBQUtaO2dCQUN4QixPQUFPSSxTQUFTUTtZQUNwQjtZQUVBLElBQUlDLGFBQWEsTUFBTTtnQkFDbkJSLEtBQUtVLEdBQUcsQ0FBQyxjQUFjLEdBQUc7Z0JBQzFCLE9BQU9OO1lBQ1g7WUFFQSxJQUFJLENBQUVJLENBQUFBLG9CQUFvQlgsWUFBVyxHQUFJO2dCQUNyQyxJQUFJO29CQUNBVyxXQUFXWCxZQUFZLENBQUNHLEtBQUtWLGlCQUFpQixHQUFHLG9CQUFvQixTQUFTLENBQUNrQjtnQkFDbkYsRUFBRSxPQUFPRCxLQUFLO29CQUNWUCxLQUFLUyxJQUFJLENBQUMsU0FBU0YsS0FBS1o7b0JBQ3hCLE9BQU9JLFNBQVNRO2dCQUNwQjtZQUNKO1lBRUFQLEtBQUtTLElBQUksQ0FBQyxRQUFRRCxVQUFVYjtZQUM1QixPQUFPSSxTQUFTLE1BQU1TO1FBQzFCO0lBRVIsRUFBRSxPQUFPRCxLQUFLO1FBQ1ZQLEtBQUtTLElBQUksQ0FBQyxTQUFTRixLQUFLWjtRQUN4Qk8sV0FBVztZQUFhSCxTQUFTUTtRQUFNLEdBQUc7UUFDMUMsT0FBT0g7SUFDWDtBQUNKO0FBRUE7Ozs7Q0FJQyxHQUNEeEIsUUFBUUcsU0FBUyxDQUFDMkIsR0FBRyxHQUFHLFNBQVNBLElBQUlDLFVBQVU7SUFDM0MsSUFBSSxJQUFJLENBQUN2QixPQUFPLEVBQUU7UUFDZCxJQUFJLENBQUN1QixZQUNELElBQUksQ0FBQ3ZCLE9BQU8sQ0FBQyxNQUFNLE1BQU07UUFDN0IsSUFBSSxDQUFDQSxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNxQixJQUFJLENBQUMsT0FBT0csR0FBRztJQUN4QjtJQUNBLE9BQU8sSUFBSTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMvc2VydmljZS5qcz9mZmJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8vIEV4dGVuZHMgRXZlbnRFbWl0dGVyXG4oU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHV0aWwuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gU2VydmljZTtcblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHJwYy5TZXJ2aWNlTWV0aG9kfFNlcnZpY2VNZXRob2R9LlxuICpcbiAqIERpZmZlcnMgZnJvbSB7QGxpbmsgUlBDSW1wbENhbGxiYWNrfSBpbiB0aGF0IGl0IGlzIGFuIGFjdHVhbCBjYWxsYmFjayBvZiBhIHNlcnZpY2UgbWV0aG9kIHdoaWNoIG1heSBub3QgcmV0dXJuIGByZXNwb25zZSA9IG51bGxgLlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RDYWxsYmFja1xuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcbiAqIEBwYXJhbSB7VFJlc30gW3Jlc3BvbnNlXSBSZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBwYXJ0IG9mIGEge0BsaW5rIHJwYy5TZXJ2aWNlfSBhcyBjcmVhdGVkIGJ5IHtAbGluayBTZXJ2aWNlLmNyZWF0ZX0uXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZFxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gW2NhbGxiYWNrXSBOb2RlLXN0eWxlIGNhbGxiYWNrIGNhbGxlZCB3aXRoIHRoZSBlcnJvciwgaWYgYW55LCBhbmQgdGhlIHJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2U8VFJlcz4+fSBQcm9taXNlIGlmIGBjYWxsYmFja2AgaGFzIGJlZW4gb21pdHRlZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IFJQQyBzZXJ2aWNlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBBbiBSUEMgc2VydmljZSBhcyByZXR1cm5lZCBieSB7QGxpbmsgU2VydmljZSNjcmVhdGV9LlxuICogQGV4cG9ydHMgcnBjLlNlcnZpY2VcbiAqIEBleHRlbmRzIHV0aWwuRXZlbnRFbWl0dGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UlBDSW1wbH0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3BvbnNlRGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICovXG5mdW5jdGlvbiBTZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKSB7XG5cbiAgICBpZiAodHlwZW9mIHJwY0ltcGwgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG5cbiAgICB1dGlsLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogUlBDIGltcGxlbWVudGF0aW9uLiBCZWNvbWVzIGBudWxsYCBvbmNlIHRoZSBzZXJ2aWNlIGlzIGVuZGVkLlxuICAgICAqIEB0eXBlIHtSUENJbXBsfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5ycGNJbXBsID0gcnBjSW1wbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0RGVsaW1pdGVkID0gQm9vbGVhbihyZXF1ZXN0RGVsaW1pdGVkKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQgPSBCb29sZWFuKHJlc3BvbnNlRGVsaW1pdGVkKTtcbn1cblxuLyoqXG4gKiBDYWxscyBhIHNlcnZpY2UgbWV0aG9kIHRocm91Z2gge0BsaW5rIHJwYy5TZXJ2aWNlI3JwY0ltcGx8cnBjSW1wbH0uXG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxUUmVxLFRSZXM+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2RcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcT59IHJlcXVlc3RDdG9yIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcz59IHJlc3BvbnNlQ3RvciBSZXNwb25zZSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBjYWxsYmFjayBTZXJ2aWNlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqL1xuU2VydmljZS5wcm90b3R5cGUucnBjQ2FsbCA9IGZ1bmN0aW9uIHJwY0NhbGwobWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0LCBjYWxsYmFjaykge1xuXG4gICAgaWYgKCFyZXF1ZXN0KVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShycGNDYWxsLCBzZWxmLCBtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QpO1xuXG4gICAgaWYgKCFzZWxmLnJwY0ltcGwpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soRXJyb3IoXCJhbHJlYWR5IGVuZGVkXCIpKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNlbGYucnBjSW1wbChcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RDdG9yW3NlbGYucmVxdWVzdERlbGltaXRlZCA/IFwiZW5jb2RlRGVsaW1pdGVkXCIgOiBcImVuY29kZVwiXShyZXF1ZXN0KS5maW5pc2goKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJwY0NhbGxiYWNrKGVyciwgcmVzcG9uc2UpIHtcblxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmQoLyogZW5kZWRCeVJQQyAqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIHJlc3BvbnNlQ3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2VDdG9yW3NlbGYucmVzcG9uc2VEZWxpbWl0ZWQgPyBcImRlY29kZURlbGltaXRlZFwiIDogXCJkZWNvZGVcIl0ocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZGF0YVwiLCByZXNwb25zZSwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGVycik7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5kcyB0aGlzIHNlcnZpY2UgYW5kIGVtaXRzIHRoZSBgZW5kYCBldmVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuZGVkQnlSUEM9ZmFsc2VdIFdoZXRoZXIgdGhlIHNlcnZpY2UgaGFzIGJlZW4gZW5kZWQgYnkgdGhlIFJQQyBpbXBsZW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIHtycGMuU2VydmljZX0gYHRoaXNgXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChlbmRlZEJ5UlBDKSB7XG4gICAgaWYgKHRoaXMucnBjSW1wbCkge1xuICAgICAgICBpZiAoIWVuZGVkQnlSUEMpIC8vIHNpZ25hbCBlbmQgdG8gcnBjSW1wbFxuICAgICAgICAgICAgdGhpcy5ycGNJbXBsKG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLnJwY0ltcGwgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIikub2ZmKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiU2VydmljZSIsInV0aWwiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJycGNJbXBsIiwicmVxdWVzdERlbGltaXRlZCIsInJlc3BvbnNlRGVsaW1pdGVkIiwiVHlwZUVycm9yIiwiY2FsbCIsIkJvb2xlYW4iLCJycGNDYWxsIiwibWV0aG9kIiwicmVxdWVzdEN0b3IiLCJyZXNwb25zZUN0b3IiLCJyZXF1ZXN0IiwiY2FsbGJhY2siLCJzZWxmIiwiYXNQcm9taXNlIiwic2V0VGltZW91dCIsIkVycm9yIiwidW5kZWZpbmVkIiwiZmluaXNoIiwicnBjQ2FsbGJhY2siLCJlcnIiLCJyZXNwb25zZSIsImVtaXQiLCJlbmQiLCJlbmRlZEJ5UlBDIiwib2ZmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/rpc/service.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/service.js":
/*!************************************************!*\
  !*** ./node_modules/protobufjs/src/service.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Service;\n// extends Namespace\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/protobufjs/src/namespace.js\");\n((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = \"Service\";\nvar Method = __webpack_require__(/*! ./method */ \"(ssr)/./node_modules/protobufjs/src/method.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\"), rpc = __webpack_require__(/*! ./rpc */ \"(ssr)/./node_modules/protobufjs/src/rpc.js\");\n/**\n * Constructs a new service instance.\n * @classdesc Reflected service.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Service name\n * @param {Object.<string,*>} [options] Service options\n * @throws {TypeError} If arguments are invalid\n */ function Service(name, options) {\n    Namespace.call(this, name, options);\n    /**\n     * Service methods.\n     * @type {Object.<string,Method>}\n     */ this.methods = {}; // toJSON, marker\n    /**\n     * Cached methods as an array.\n     * @type {Method[]|null}\n     * @private\n     */ this._methodsArray = null;\n}\n/**\n * Service descriptor.\n * @interface IService\n * @extends INamespace\n * @property {Object.<string,IMethod>} methods Method descriptors\n */ /**\n * Constructs a service from a service descriptor.\n * @param {string} name Service name\n * @param {IService} json Service descriptor\n * @returns {Service} Created service\n * @throws {TypeError} If arguments are invalid\n */ Service.fromJSON = function fromJSON(name, json) {\n    var service = new Service(name, json.options);\n    /* istanbul ignore else */ if (json.methods) for(var names = Object.keys(json.methods), i = 0; i < names.length; ++i)service.add(Method.fromJSON(names[i], json.methods[names[i]]));\n    if (json.nested) service.addJSON(json.nested);\n    service.comment = json.comment;\n    return service;\n};\n/**\n * Converts this service to a service descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IService} Service descriptor\n */ Service.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\",\n        inherited && inherited.options || undefined,\n        \"methods\",\n        Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},\n        \"nested\",\n        inherited && inherited.nested || undefined,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * Methods of this service as an array for iteration.\n * @name Service#methodsArray\n * @type {Method[]}\n * @readonly\n */ Object.defineProperty(Service.prototype, \"methodsArray\", {\n    get: function() {\n        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));\n    }\n});\nfunction clearCache(service) {\n    service._methodsArray = null;\n    return service;\n}\n/**\n * @override\n */ Service.prototype.get = function get(name) {\n    return this.methods[name] || Namespace.prototype.get.call(this, name);\n};\n/**\n * @override\n */ Service.prototype.resolveAll = function resolveAll() {\n    var methods = this.methodsArray;\n    for(var i = 0; i < methods.length; ++i)methods[i].resolve();\n    return Namespace.prototype.resolve.call(this);\n};\n/**\n * @override\n */ Service.prototype.add = function add(object) {\n    /* istanbul ignore if */ if (this.get(object.name)) throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n    if (object instanceof Method) {\n        this.methods[object.name] = object;\n        object.parent = this;\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n/**\n * @override\n */ Service.prototype.remove = function remove(object) {\n    if (object instanceof Method) {\n        /* istanbul ignore if */ if (this.methods[object.name] !== object) throw Error(object + \" is not a member of \" + this);\n        delete this.methods[object.name];\n        object.parent = null;\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n/**\n * Creates a runtime service using the specified rpc implementation.\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.\n */ Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);\n    for(var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i){\n        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\\w_]/g, \"\");\n        rpcService[methodName] = util.codegen([\n            \"r\",\n            \"c\"\n        ], util.isReserved(methodName) ? methodName + \"_\" : methodName)(\"return this.rpcCall(m,q,s,r,c)\")({\n            m: method,\n            q: method.resolvedRequestType.ctor,\n            s: method.resolvedResponseType.ctor\n        });\n    }\n    return rpcService;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvc2VydmljZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLG9CQUFvQjtBQUNwQixJQUFJQyxZQUFZQyxtQkFBT0EsQ0FBQyxxRUFBYTtBQUNwQyxFQUFDRixRQUFRRyxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0osVUFBVUUsU0FBUyxHQUFHRyxXQUFXLEdBQUdOLE9BQU0sRUFBR08sU0FBUyxHQUFHO0FBRTdGLElBQUlDLFNBQVNOLG1CQUFPQSxDQUFDLCtEQUFVLEdBQzNCTyxPQUFTUCxtQkFBT0EsQ0FBQywyREFBUSxHQUN6QlEsTUFBU1IsbUJBQU9BLENBQUMseURBQU87QUFFNUI7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTRixRQUFRVyxJQUFJLEVBQUVDLE9BQU87SUFDMUJYLFVBQVVZLElBQUksQ0FBQyxJQUFJLEVBQUVGLE1BQU1DO0lBRTNCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0UsT0FBTyxHQUFHLENBQUMsR0FBRyxpQkFBaUI7SUFFcEM7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ0MsYUFBYSxHQUFHO0FBQ3pCO0FBRUE7Ozs7O0NBS0MsR0FFRDs7Ozs7O0NBTUMsR0FDRGYsUUFBUWdCLFFBQVEsR0FBRyxTQUFTQSxTQUFTTCxJQUFJLEVBQUVNLElBQUk7SUFDM0MsSUFBSUMsVUFBVSxJQUFJbEIsUUFBUVcsTUFBTU0sS0FBS0wsT0FBTztJQUM1Qyx3QkFBd0IsR0FDeEIsSUFBSUssS0FBS0gsT0FBTyxFQUNaLElBQUssSUFBSUssUUFBUWYsT0FBT2dCLElBQUksQ0FBQ0gsS0FBS0gsT0FBTyxHQUFHTyxJQUFJLEdBQUdBLElBQUlGLE1BQU1HLE1BQU0sRUFBRSxFQUFFRCxFQUNuRUgsUUFBUUssR0FBRyxDQUFDZixPQUFPUSxRQUFRLENBQUNHLEtBQUssQ0FBQ0UsRUFBRSxFQUFFSixLQUFLSCxPQUFPLENBQUNLLEtBQUssQ0FBQ0UsRUFBRSxD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K0IsT0FBT0UsTUFBTSxHQUFHO1FBQ2hCLE9BQU9MLFdBQVcsSUFBSTtJQUMxQjtJQUNBLE9BQU90QyxVQUFVRSxTQUFTLENBQUMwQyxNQUFNLENBQUNoQyxJQUFJLENBQUMsSUFBSSxFQUFFNkI7QUFDakQ7QUFFQTs7Ozs7O0NBTUMsR0FDRDFDLFFBQVFHLFNBQVMsQ0FBQ0UsTUFBTSxHQUFHLFNBQVNBLE9BQU95QyxPQUFPLEVBQUVDLGdCQUFnQixFQUFFQyxpQkFBaUI7SUFDbkYsSUFBSUMsYUFBYSxJQUFJdkMsSUFBSVYsT0FBTyxDQUFDOEMsU0FBU0Msa0JBQWtCQztJQUM1RCxJQUFLLElBQUkzQixJQUFJLEdBQUc2QixRQUFRN0IsSUFBSSxlQUFlLEdBQUcsSUFBSSxDQUFDYyxZQUFZLENBQUNiLE1BQU0sRUFBRSxFQUFFRCxFQUFHO1FBQ3pFLElBQUk4QixhQUFhMUMsS0FBSzJDLE9BQU8sQ0FBQyxDQUFDRixTQUFTLElBQUksQ0FBQ25DLGFBQWEsQ0FBQ00sRUFBRSxFQUFFb0IsT0FBTyxHQUFHOUIsSUFBSSxFQUFFMEMsT0FBTyxDQUFDLFlBQVk7UUFDbkdKLFVBQVUsQ0FBQ0UsV0FBVyxHQUFHMUMsS0FBSzZDLE9BQU8sQ0FBQztZQUFDO1lBQUk7U0FBSSxFQUFFN0MsS0FBSzhDLFVBQVUsQ0FBQ0osY0FBY0EsYUFBYSxNQUFNQSxZQUFZLGtDQUFrQztZQUM1SUssR0FBR047WUFDSE8sR0FBR1AsT0FBT1EsbUJBQW1CLENBQUNDLElBQUk7WUFDbENDLEdBQUdWLE9BQU9XLG9CQUFvQixDQUFDRixJQUFJO1FBQ3ZDO0lBQ0o7SUFDQSxPQUFPVjtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9zZXJ2aWNlLmpzPzQ3OGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2U7XG5cbi8vIGV4dGVuZHMgTmFtZXNwYWNlXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xuKChTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gU2VydmljZSkuY2xhc3NOYW1lID0gXCJTZXJ2aWNlXCI7XG5cbnZhciBNZXRob2QgPSByZXF1aXJlKFwiLi9tZXRob2RcIiksXG4gICAgdXRpbCAgID0gcmVxdWlyZShcIi4vdXRpbFwiKSxcbiAgICBycGMgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBzZXJ2aWNlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgc2VydmljZS5cbiAqIEBleHRlbmRzIE5hbWVzcGFjZUJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU2VydmljZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gU2VydmljZSBvcHRpb25zXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5mdW5jdGlvbiBTZXJ2aWNlKG5hbWUsIG9wdGlvbnMpIHtcbiAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFNlcnZpY2UgbWV0aG9kcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsTWV0aG9kPn1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGhvZHMgPSB7fTsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBtZXRob2RzIGFzIGFuIGFycmF5LlxuICAgICAqIEB0eXBlIHtNZXRob2RbXXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbWV0aG9kc0FycmF5ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTZXJ2aWNlIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElTZXJ2aWNlXG4gKiBAZXh0ZW5kcyBJTmFtZXNwYWNlXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLElNZXRob2Q+fSBtZXRob2RzIE1ldGhvZCBkZXNjcmlwdG9yc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHNlcnZpY2UgZnJvbSBhIHNlcnZpY2UgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFNlcnZpY2UgbmFtZVxuICogQHBhcmFtIHtJU2VydmljZX0ganNvbiBTZXJ2aWNlIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtTZXJ2aWNlfSBDcmVhdGVkIHNlcnZpY2VcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cblNlcnZpY2UuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgdmFyIHNlcnZpY2UgPSBuZXcgU2VydmljZShuYW1lLCBqc29uLm9wdGlvbnMpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGpzb24ubWV0aG9kcylcbiAgICAgICAgZm9yICh2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhqc29uLm1ldGhvZHMpLCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgc2VydmljZS5hZGQoTWV0aG9kLmZyb21KU09OKG5hbWVzW2ldLCBqc29uLm1ldGhvZHNbbmFtZXNbaV1dKSk7XG4gICAgaWYgKGpzb24ubmVzdGVkKVxuICAgICAgICBzZXJ2aWNlLmFkZEpTT04oanNvbi5uZXN0ZWQpO1xuICAgIHNlcnZpY2UuY29tbWVudCA9IGpzb24uY29tbWVudDtcbiAgICByZXR1cm4gc2VydmljZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBzZXJ2aWNlIHRvIGEgc2VydmljZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SVNlcnZpY2V9IFNlcnZpY2UgZGVzY3JpcHRvclxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBpbmhlcml0ZWQgPSBOYW1lc3BhY2UucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMsIHRvSlNPTk9wdGlvbnMpO1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwib3B0aW9uc1wiICwgaW5oZXJpdGVkICYmIGluaGVyaXRlZC5vcHRpb25zIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJtZXRob2RzXCIgLCBOYW1lc3BhY2UuYXJyYXlUb0pTT04odGhpcy5tZXRob2RzQXJyYXksIHRvSlNPTk9wdGlvbnMpIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9LFxuICAgICAgICBcIm5lc3RlZFwiICAsIGluaGVyaXRlZCAmJiBpbmhlcml0ZWQubmVzdGVkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJjb21tZW50XCIgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogTWV0aG9kcyBvZiB0aGlzIHNlcnZpY2UgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAqIEBuYW1lIFNlcnZpY2UjbWV0aG9kc0FycmF5XG4gKiBAdHlwZSB7TWV0aG9kW119XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2UucHJvdG90eXBlLCBcIm1ldGhvZHNBcnJheVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZHNBcnJheSB8fCAodGhpcy5fbWV0aG9kc0FycmF5ID0gdXRpbC50b0FycmF5KHRoaXMubWV0aG9kcykpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBjbGVhckNhY2hlKHNlcnZpY2UpIHtcbiAgICBzZXJ2aWNlLl9tZXRob2RzQXJyYXkgPSBudWxsO1xuICAgIHJldHVybiBzZXJ2aWNlO1xufVxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZHNbbmFtZV1cbiAgICAgICAgfHwgTmFtZXNwYWNlLnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBuYW1lKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbiByZXNvbHZlQWxsKCkge1xuICAgIHZhciBtZXRob2RzID0gdGhpcy5tZXRob2RzQXJyYXk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgKytpKVxuICAgICAgICBtZXRob2RzW2ldLnJlc29sdmUoKTtcbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQob2JqZWN0KSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5nZXQob2JqZWN0Lm5hbWUpKVxuICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBuYW1lICdcIiArIG9iamVjdC5uYW1lICsgXCInIGluIFwiICsgdGhpcyk7XG5cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWV0aG9kKSB7XG4gICAgICAgIHRoaXMubWV0aG9kc1tvYmplY3QubmFtZV0gPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgb2JqZWN0KTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWV0aG9kKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0aGlzLm1ldGhvZHNbb2JqZWN0Lm5hbWVdICE9PSBvYmplY3QpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihvYmplY3QgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcblxuICAgICAgICBkZWxldGUgdGhpcy5tZXRob2RzW29iamVjdC5uYW1lXTtcbiAgICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBvYmplY3QpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcnVudGltZSBzZXJ2aWNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcnBjIGltcGxlbWVudGF0aW9uLlxuICogQHBhcmFtIHtSUENJbXBsfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKiBAcmV0dXJucyB7cnBjLlNlcnZpY2V9IFJQQyBzZXJ2aWNlLiBVc2VmdWwgd2hlcmUgcmVxdWVzdHMgYW5kL29yIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWQuXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCkge1xuICAgIHZhciBycGNTZXJ2aWNlID0gbmV3IHJwYy5TZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbWV0aG9kOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gdGhpcy5tZXRob2RzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSB1dGlsLmxjRmlyc3QoKG1ldGhvZCA9IHRoaXMuX21ldGhvZHNBcnJheVtpXSkucmVzb2x2ZSgpLm5hbWUpLnJlcGxhY2UoL1teJFxcd19dL2csIFwiXCIpO1xuICAgICAgICBycGNTZXJ2aWNlW21ldGhvZE5hbWVdID0gdXRpbC5jb2RlZ2VuKFtcInJcIixcImNcIl0sIHV0aWwuaXNSZXNlcnZlZChtZXRob2ROYW1lKSA/IG1ldGhvZE5hbWUgKyBcIl9cIiA6IG1ldGhvZE5hbWUpKFwicmV0dXJuIHRoaXMucnBjQ2FsbChtLHEscyxyLGMpXCIpKHtcbiAgICAgICAgICAgIG06IG1ldGhvZCxcbiAgICAgICAgICAgIHE6IG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlLmN0b3IsXG4gICAgICAgICAgICBzOiBtZXRob2QucmVzb2x2ZWRSZXNwb25zZVR5cGUuY3RvclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJwY1NlcnZpY2U7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJTZXJ2aWNlIiwiTmFtZXNwYWNlIiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiY2xhc3NOYW1lIiwiTWV0aG9kIiwidXRpbCIsInJwYyIsIm5hbWUiLCJvcHRpb25zIiwiY2FsbCIsIm1ldGhvZHMiLCJfbWV0aG9kc0FycmF5IiwiZnJvbUpTT04iLCJqc29uIiwic2VydmljZSIsIm5hbWVzIiwia2V5cyIsImkiLCJsZW5ndGgiLCJhZGQiLCJuZXN0ZWQiLCJhZGRKU09OIiwiY29tbWVudCIsInRvSlNPTiIsInRvSlNPTk9wdGlvbnMiLCJpbmhlcml0ZWQiLCJrZWVwQ29tbWVudHMiLCJCb29sZWFuIiwidG9PYmplY3QiLCJ1bmRlZmluZWQiLCJhcnJheVRvSlNPTiIsIm1ldGhvZHNBcnJheSIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwidG9BcnJheSIsImNsZWFyQ2FjaGUiLCJyZXNvbHZlQWxsIiwicmVzb2x2ZSIsIm9iamVjdCIsIkVycm9yIiwicGFyZW50IiwicmVtb3ZlIiwicnBjSW1wbCIsInJlcXVlc3REZWxpbWl0ZWQiLCJyZXNwb25zZURlbGltaXRlZCIsInJwY1NlcnZpY2UiLCJtZXRob2QiLCJtZXRob2ROYW1lIiwibGNGaXJzdCIsInJlcGxhY2UiLCJjb2RlZ2VuIiwiaXNSZXNlcnZlZCIsIm0iLCJxIiwicmVzb2x2ZWRSZXF1ZXN0VHlwZSIsImN0b3IiLCJzIiwicmVzb2x2ZWRSZXNwb25zZVR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/service.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/tokenize.js":
/*!*************************************************!*\
  !*** ./node_modules/protobufjs/src/tokenize.js ***!
  \*************************************************/
/***/ ((module) => {

eval("\nmodule.exports = tokenize;\nvar delimRe = /[\\s{}=;:[\\],'\"()<>]/g, stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g, stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\nvar setCommentRe = /^ *[*/]+ */, setCommentAltRe = /^\\s*\\*?\\/*/, setCommentSplitRe = /\\n/g, whitespaceRe = /\\s/, unescapeRe = /\\\\(.?)/g;\nvar unescapeMap = {\n    \"0\": \"\\x00\",\n    \"r\": \"\\r\",\n    \"n\": \"\\n\",\n    \"t\": \"\t\"\n};\n/**\n * Unescapes a string.\n * @param {string} str String to unescape\n * @returns {string} Unescaped string\n * @property {Object.<string,string>} map Special characters map\n * @memberof tokenize\n */ function unescape(str) {\n    return str.replace(unescapeRe, function($0, $1) {\n        switch($1){\n            case \"\\\\\":\n            case \"\":\n                return $1;\n            default:\n                return unescapeMap[$1] || \"\";\n        }\n    });\n}\ntokenize.unescape = unescape;\n/**\n * Gets the next token and advances.\n * @typedef TokenizerHandleNext\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */ /**\n * Peeks for the next token.\n * @typedef TokenizerHandlePeek\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */ /**\n * Pushes a token back to the stack.\n * @typedef TokenizerHandlePush\n * @type {function}\n * @param {string} token Token\n * @returns {undefined}\n */ /**\n * Skips the next token.\n * @typedef TokenizerHandleSkip\n * @type {function}\n * @param {string} expected Expected token\n * @param {boolean} [optional=false] If optional\n * @returns {boolean} Whether the token matched\n * @throws {Error} If the token didn't match and is not optional\n */ /**\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\n * @typedef TokenizerHandleCmnt\n * @type {function}\n * @param {number} [line] Line number\n * @returns {string|null} Comment text or `null` if none\n */ /**\n * Handle object returned from {@link tokenize}.\n * @interface ITokenizerHandle\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\n * @property {number} line Current line number\n */ /**\n * Tokenizes the given .proto source and returns an object with useful utility functions.\n * @param {string} source Source contents\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\n * @returns {ITokenizerHandle} Tokenizer handle\n */ function tokenize(source, alternateCommentMode) {\n    /* eslint-disable callback-return */ source = source.toString();\n    var offset = 0, length = source.length, line = 1, lastCommentLine = 0, comments = {};\n    var stack = [];\n    var stringDelim = null;\n    /* istanbul ignore next */ /**\n     * Creates an error for illegal syntax.\n     * @param {string} subject Subject\n     * @returns {Error} Error created\n     * @inner\n     */ function illegal(subject) {\n        return Error(\"illegal \" + subject + \" (line \" + line + \")\");\n    }\n    /**\n     * Reads a string till its end.\n     * @returns {string} String read\n     * @inner\n     */ function readString() {\n        var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\n        re.lastIndex = offset - 1;\n        var match = re.exec(source);\n        if (!match) throw illegal(\"string\");\n        offset = re.lastIndex;\n        push(stringDelim);\n        stringDelim = null;\n        return unescape(match[1]);\n    }\n    /**\n     * Gets the character at `pos` within the source.\n     * @param {number} pos Position\n     * @returns {string} Character\n     * @inner\n     */ function charAt(pos) {\n        return source.charAt(pos);\n    }\n    /**\n     * Sets the current comment text.\n     * @param {number} start Start offset\n     * @param {number} end End offset\n     * @param {boolean} isLeading set if a leading comment\n     * @returns {undefined}\n     * @inner\n     */ function setComment(start, end, isLeading) {\n        var comment = {\n            type: source.charAt(start++),\n            lineEmpty: false,\n            leading: isLeading\n        };\n        var lookback;\n        if (alternateCommentMode) {\n            lookback = 2; // alternate comment parsing: \"//\" or \"/*\"\n        } else {\n            lookback = 3; // \"///\" or \"/**\"\n        }\n        var commentOffset = start - lookback, c;\n        do {\n            if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === \"\\n\") {\n                comment.lineEmpty = true;\n                break;\n            }\n        }while (c === \" \" || c === \"\t\");\n        var lines = source.substring(start, end).split(setCommentSplitRe);\n        for(var i = 0; i < lines.length; ++i)lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\").trim();\n        comment.text = lines.join(\"\\n\").trim();\n        comments[line] = comment;\n        lastCommentLine = line;\n    }\n    function isDoubleSlashCommentLine(startOffset) {\n        var endOffset = findEndOfLine(startOffset);\n        // see if remaining line matches comment pattern\n        var lineText = source.substring(startOffset, endOffset);\n        var isComment = /^\\s*\\/\\//.test(lineText);\n        return isComment;\n    }\n    function findEndOfLine(cursor) {\n        // find end of cursor's line\n        var endOffset = cursor;\n        while(endOffset < length && charAt(endOffset) !== \"\\n\"){\n            endOffset++;\n        }\n        return endOffset;\n    }\n    /**\n     * Obtains the next token.\n     * @returns {string|null} Next token or `null` on eof\n     * @inner\n     */ function next() {\n        if (stack.length > 0) return stack.shift();\n        if (stringDelim) return readString();\n        var repeat, prev, curr, start, isDoc, isLeadingComment = offset === 0;\n        do {\n            if (offset === length) return null;\n            repeat = false;\n            while(whitespaceRe.test(curr = charAt(offset))){\n                if (curr === \"\\n\") {\n                    isLeadingComment = true;\n                    ++line;\n                }\n                if (++offset === length) return null;\n            }\n            if (charAt(offset) === \"/\") {\n                if (++offset === length) {\n                    throw illegal(\"comment\");\n                }\n                if (charAt(offset) === \"/\") {\n                    if (!alternateCommentMode) {\n                        // check for triple-slash comment\n                        isDoc = charAt(start = offset + 1) === \"/\";\n                        while(charAt(++offset) !== \"\\n\"){\n                            if (offset === length) {\n                                return null;\n                            }\n                        }\n                        ++offset;\n                        if (isDoc) {\n                            setComment(start, offset - 1, isLeadingComment);\n                            // Trailing comment cannot not be multi-line,\n                            // so leading comment state should be reset to handle potential next comments\n                            isLeadingComment = true;\n                        }\n                        ++line;\n                        repeat = true;\n                    } else {\n                        // check for double-slash comments, consolidating consecutive lines\n                        start = offset;\n                        isDoc = false;\n                        if (isDoubleSlashCommentLine(offset - 1)) {\n                            isDoc = true;\n                            do {\n                                offset = findEndOfLine(offset);\n                                if (offset === length) {\n                                    break;\n                                }\n                                offset++;\n                                if (!isLeadingComment) {\n                                    break;\n                                }\n                            }while (isDoubleSlashCommentLine(offset));\n                        } else {\n                            offset = Math.min(length, findEndOfLine(offset) + 1);\n                        }\n                        if (isDoc) {\n                            setComment(start, offset, isLeadingComment);\n                            isLeadingComment = true;\n                        }\n                        line++;\n                        repeat = true;\n                    }\n                } else if ((curr = charAt(offset)) === \"*\") {\n                    // check for /** (regular comment mode) or /* (alternate comment mode)\n                    start = offset + 1;\n                    isDoc = alternateCommentMode || charAt(start) === \"*\";\n                    do {\n                        if (curr === \"\\n\") {\n                            ++line;\n                        }\n                        if (++offset === length) {\n                            throw illegal(\"comment\");\n                        }\n                        prev = curr;\n                        curr = charAt(offset);\n                    }while (prev !== \"*\" || curr !== \"/\");\n                    ++offset;\n                    if (isDoc) {\n                        setComment(start, offset - 2, isLeadingComment);\n                        isLeadingComment = true;\n                    }\n                    repeat = true;\n                } else {\n                    return \"/\";\n                }\n            }\n        }while (repeat);\n        // offset !== length if we got here\n        var end = offset;\n        delimRe.lastIndex = 0;\n        var delim = delimRe.test(charAt(end++));\n        if (!delim) while(end < length && !delimRe.test(charAt(end)))++end;\n        var token = source.substring(offset, offset = end);\n        if (token === '\"' || token === \"'\") stringDelim = token;\n        return token;\n    }\n    /**\n     * Pushes a token back to the stack.\n     * @param {string} token Token\n     * @returns {undefined}\n     * @inner\n     */ function push(token) {\n        stack.push(token);\n    }\n    /**\n     * Peeks for the next token.\n     * @returns {string|null} Token or `null` on eof\n     * @inner\n     */ function peek() {\n        if (!stack.length) {\n            var token = next();\n            if (token === null) return null;\n            push(token);\n        }\n        return stack[0];\n    }\n    /**\n     * Skips a token.\n     * @param {string} expected Expected token\n     * @param {boolean} [optional=false] Whether the token is optional\n     * @returns {boolean} `true` when skipped, `false` if not\n     * @throws {Error} When a required token is not present\n     * @inner\n     */ function skip(expected, optional) {\n        var actual = peek(), equals = actual === expected;\n        if (equals) {\n            next();\n            return true;\n        }\n        if (!optional) throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\n        return false;\n    }\n    /**\n     * Gets a comment.\n     * @param {number} [trailingLine] Line number if looking for a trailing comment\n     * @returns {string|null} Comment text\n     * @inner\n     */ function cmnt(trailingLine) {\n        var ret = null;\n        var comment;\n        if (trailingLine === undefined) {\n            comment = comments[line - 1];\n            delete comments[line - 1];\n            if (comment && (alternateCommentMode || comment.type === \"*\" || comment.lineEmpty)) {\n                ret = comment.leading ? comment.text : null;\n            }\n        } else {\n            /* istanbul ignore else */ if (lastCommentLine < trailingLine) {\n                peek();\n            }\n            comment = comments[trailingLine];\n            delete comments[trailingLine];\n            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === \"/\")) {\n                ret = comment.leading ? null : comment.text;\n            }\n        }\n        return ret;\n    }\n    return Object.defineProperty({\n        next: next,\n        peek: peek,\n        push: push,\n        skip: skip,\n        cmnt: cmnt\n    }, \"line\", {\n        get: function() {\n            return line;\n        }\n    });\n/* eslint-enable callback-return */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdG9rZW5pemUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxVQUFpQix3QkFDakJDLGlCQUFpQixtQ0FDakJDLGlCQUFpQjtBQUVyQixJQUFJQyxlQUFlLGNBQ2ZDLGtCQUFrQixjQUNsQkMsb0JBQW9CLE9BQ3BCQyxlQUFlLE1BQ2ZDLGFBQWE7QUFFakIsSUFBSUMsY0FBYztJQUNkLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7QUFDVDtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLFNBQVNDLEdBQUc7SUFDakIsT0FBT0EsSUFBSUMsT0FBTyxDQUFDSixZQUFZLFNBQVNLLEVBQUUsRUFBRUMsRUFBRTtRQUMxQyxPQUFRQTtZQUNKLEtBQUs7WUFDTCxLQUFLO2dCQUNELE9BQU9BO1lBQ1g7Z0JBQ0ksT0FBT0wsV0FBVyxDQUFDSyxHQUFHLElBQUk7UUFDbEM7SUFDSjtBQUNKO0FBRUFkLFNBQVNVLFFBQVEsR0FBR0E7QUFFcEI7Ozs7O0NBS0MsR0FFRDs7Ozs7Q0FLQyxHQUVEOzs7Ozs7Q0FNQyxHQUVEOzs7Ozs7OztDQVFDLEdBRUQ7Ozs7OztDQU1DLEdBRUQ7Ozs7Ozs7OztDQVNDLEdBRUQ7Ozs7O0NBS0MsR0FDRCxTQUFTVixTQUFTZSxNQUFNLEVBQUVDLG9CQUFvQjtJQUMxQyxrQ0FBa0MsR0FDbENELFNBQVNBLE9BQU9FLFFBQVE7SUFFeEIsSUFBSUMsU0FBUyxHQUNUQyxTQUFTSixPQUFPSSxNQUFNLEVBQ3RCQyxPQUFPLEdBQ1BDLGtCQUFrQixHQUNsQkMsV0FBVyxDQUFDO0lBRWhCLElBQUlDLFFBQVEsRUFBRTtJQUVkLElBQUlDLGNBQWM7SUFFbEIsd0JBQXdCLEdBQ3hCOzs7OztLQUtDLEdBQ0QsU0FBU0MsUUFBUUMsT0FBTztRQUNwQixPQUFPQyxNQUFNLGFBQWFELFVBQVUsWUFBWU4sT0FBTztJQUMzRDtJQUVB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QUksQ0FBQ2MsVUFDRCxNQUFNbkQsUUFBUSxZQUFZb0QsU0FBUyxTQUFTRixXQUFXO1FBQzNELE9BQU87SUFDWDtJQUVBOzs7OztLQUtDLEdBQ0QsU0FBU0ksS0FBS0MsWUFBWTtRQUN0QixJQUFJQyxNQUFNO1FBQ1YsSUFBSXpDO1FBQ0osSUFBSXdDLGlCQUFpQkUsV0FBVztZQUM1QjFDLFVBQVVsQixRQUFRLENBQUNGLE9BQU8sRUFBRTtZQUM1QixPQUFPRSxRQUFRLENBQUNGLE9BQU8sRUFBRTtZQUN6QixJQUFJb0IsV0FBWXhCLENBQUFBLHdCQUF3QndCLFFBQVFDLElBQUksS0FBSyxPQUFPRCxRQUFRRSxTQUFTLEdBQUc7Z0JBQ2hGdUMsTUFBTXpDLFFBQVFHLE9BQU8sR0FBR0gsUUFBUVksSUFBSSxHQUFHO1lBQzNDO1FBQ0osT0FBTztZQUNILHdCQUF3QixHQUN4QixJQUFJL0Isa0JBQWtCMkQsY0FBYztnQkFDaENQO1lBQ0o7WUFDQWpDLFVBQVVsQixRQUFRLENBQUMwRCxhQUFhO1lBQ2hDLE9BQU8xRCxRQUFRLENBQUMwRCxhQUFhO1lBQzdCLElBQUl4QyxXQUFXLENBQUNBLFFBQVFFLFNBQVMsSUFBSzFCLENBQUFBLHdCQUF3QndCLFFBQVFDLElBQUksS0FBSyxHQUFFLEdBQUk7Z0JBQ2pGd0MsTUFBTXpDLFFBQVFHLE9BQU8sR0FBRyxPQUFPSCxRQUFRWSxJQUFJO1lBQy9DO1FBQ0o7UUFDQSxPQUFPNkI7SUFDWDtJQUVBLE9BQU9FLE9BQU9DLGNBQWMsQ0FBQztRQUN6QnRCLE1BQU1BO1FBQ05XLE1BQU1BO1FBQ054QyxNQUFNQTtRQUNOeUMsTUFBTUE7UUFDTkssTUFBTUE7SUFDVixHQUFHLFFBQVE7UUFDUE0sS0FBSztZQUFhLE9BQU9qRTtRQUFNO0lBQ25DO0FBQ0EsaUNBQWlDLEdBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy90b2tlbml6ZS5qcz9jMjllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB0b2tlbml6ZTtcblxudmFyIGRlbGltUmUgICAgICAgID0gL1tcXHN7fT07OltcXF0sJ1wiKCk8Pl0vZyxcbiAgICBzdHJpbmdEb3VibGVSZSA9IC8oPzpcIihbXlwiXFxcXF0qKD86XFxcXC5bXlwiXFxcXF0qKSopXCIpL2csXG4gICAgc3RyaW5nU2luZ2xlUmUgPSAvKD86JyhbXidcXFxcXSooPzpcXFxcLlteJ1xcXFxdKikqKScpL2c7XG5cbnZhciBzZXRDb21tZW50UmUgPSAvXiAqWyovXSsgKi8sXG4gICAgc2V0Q29tbWVudEFsdFJlID0gL15cXHMqXFwqP1xcLyovLFxuICAgIHNldENvbW1lbnRTcGxpdFJlID0gL1xcbi9nLFxuICAgIHdoaXRlc3BhY2VSZSA9IC9cXHMvLFxuICAgIHVuZXNjYXBlUmUgPSAvXFxcXCguPykvZztcblxudmFyIHVuZXNjYXBlTWFwID0ge1xuICAgIFwiMFwiOiBcIlxcMFwiLFxuICAgIFwiclwiOiBcIlxcclwiLFxuICAgIFwiblwiOiBcIlxcblwiLFxuICAgIFwidFwiOiBcIlxcdFwiXG59O1xuXG4vKipcbiAqIFVuZXNjYXBlcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHVuZXNjYXBlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBVbmVzY2FwZWQgc3RyaW5nXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLHN0cmluZz59IG1hcCBTcGVjaWFsIGNoYXJhY3RlcnMgbWFwXG4gKiBAbWVtYmVyb2YgdG9rZW5pemVcbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKHVuZXNjYXBlUmUsIGZ1bmN0aW9uKCQwLCAkMSkge1xuICAgICAgICBzd2l0Y2ggKCQxKSB7XG4gICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAkMTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZXNjYXBlTWFwWyQxXSB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbnRva2VuaXplLnVuZXNjYXBlID0gdW5lc2NhcGU7XG5cbi8qKlxuICogR2V0cyB0aGUgbmV4dCB0b2tlbiBhbmQgYWR2YW5jZXMuXG4gKiBAdHlwZWRlZiBUb2tlbml6ZXJIYW5kbGVOZXh0XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IE5leHQgdG9rZW4gb3IgYG51bGxgIG9uIGVvZlxuICovXG5cbi8qKlxuICogUGVla3MgZm9yIHRoZSBuZXh0IHRva2VuLlxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlUGVla1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBOZXh0IHRva2VuIG9yIGBudWxsYCBvbiBlb2ZcbiAqL1xuXG4vKipcbiAqIFB1c2hlcyBhIHRva2VuIGJhY2sgdG8gdGhlIHN0YWNrLlxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlUHVzaFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRva2VuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogU2tpcHMgdGhlIG5leHQgdG9rZW4uXG4gKiBAdHlwZWRlZiBUb2tlbml6ZXJIYW5kbGVTa2lwXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgRXhwZWN0ZWQgdG9rZW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbmFsPWZhbHNlXSBJZiBvcHRpb25hbFxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHRva2VuIG1hdGNoZWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdG9rZW4gZGlkbid0IG1hdGNoIGFuZCBpcyBub3Qgb3B0aW9uYWxcbiAqL1xuXG4vKipcbiAqIEdldHMgdGhlIGNvbW1lbnQgb24gdGhlIHByZXZpb3VzIGxpbmUgb3IsIGFsdGVybmF0aXZlbHksIHRoZSBsaW5lIGNvbW1lbnQgb24gdGhlIHNwZWNpZmllZCBsaW5lLlxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlQ21udFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtudW1iZXJ9IFtsaW5lXSBMaW5lIG51bWJlclxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBDb21tZW50IHRleHQgb3IgYG51bGxgIGlmIG5vbmVcbiAqL1xuXG4vKipcbiAqIEhhbmRsZSBvYmplY3QgcmV0dXJuZWQgZnJvbSB7QGxpbmsgdG9rZW5pemV9LlxuICogQGludGVyZmFjZSBJVG9rZW5pemVySGFuZGxlXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZU5leHR9IG5leHQgR2V0cyB0aGUgbmV4dCB0b2tlbiBhbmQgYWR2YW5jZXMgKGBudWxsYCBvbiBlb2YpXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZVBlZWt9IHBlZWsgUGVla3MgZm9yIHRoZSBuZXh0IHRva2VuIChgbnVsbGAgb24gZW9mKVxuICogQHByb3BlcnR5IHtUb2tlbml6ZXJIYW5kbGVQdXNofSBwdXNoIFB1c2hlcyBhIHRva2VuIGJhY2sgdG8gdGhlIHN0YWNrXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZVNraXB9IHNraXAgU2tpcHMgYSB0b2tlbiwgcmV0dXJucyBpdHMgcHJlc2VuY2UgYW5kIGFkdmFuY2VzIG9yLCBpZiBub24tb3B0aW9uYWwgYW5kIG5vdCBwcmVzZW50LCB0aHJvd3NcbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVySGFuZGxlQ21udH0gY21udCBHZXRzIHRoZSBjb21tZW50IG9uIHRoZSBwcmV2aW91cyBsaW5lIG9yIHRoZSBsaW5lIGNvbW1lbnQgb24gdGhlIHNwZWNpZmllZCBsaW5lLCBpZiBhbnlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lIEN1cnJlbnQgbGluZSBudW1iZXJcbiAqL1xuXG4vKipcbiAqIFRva2VuaXplcyB0aGUgZ2l2ZW4gLnByb3RvIHNvdXJjZSBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB1c2VmdWwgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFNvdXJjZSBjb250ZW50c1xuICogQHBhcmFtIHtib29sZWFufSBhbHRlcm5hdGVDb21tZW50TW9kZSBXaGV0aGVyIHdlIHNob3VsZCBhY3RpdmF0ZSBhbHRlcm5hdGUgY29tbWVudCBwYXJzaW5nIG1vZGUuXG4gKiBAcmV0dXJucyB7SVRva2VuaXplckhhbmRsZX0gVG9rZW5pemVyIGhhbmRsZVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZShzb3VyY2UsIGFsdGVybmF0ZUNvbW1lbnRNb2RlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgY2FsbGJhY2stcmV0dXJuICovXG4gICAgc291cmNlID0gc291cmNlLnRvU3RyaW5nKCk7XG5cbiAgICB2YXIgb2Zmc2V0ID0gMCxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aCxcbiAgICAgICAgbGluZSA9IDEsXG4gICAgICAgIGxhc3RDb21tZW50TGluZSA9IDAsXG4gICAgICAgIGNvbW1lbnRzID0ge307XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcblxuICAgIHZhciBzdHJpbmdEZWxpbSA9IG51bGw7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgZm9yIGlsbGVnYWwgc3ludGF4LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJqZWN0IFN1YmplY3RcbiAgICAgKiBAcmV0dXJucyB7RXJyb3J9IEVycm9yIGNyZWF0ZWRcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbGxlZ2FsKHN1YmplY3QpIHtcbiAgICAgICAgcmV0dXJuIEVycm9yKFwiaWxsZWdhbCBcIiArIHN1YmplY3QgKyBcIiAobGluZSBcIiArIGxpbmUgKyBcIilcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBzdHJpbmcgdGlsbCBpdHMgZW5kLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZWFkXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVhZFN0cmluZygpIHtcbiAgICAgICAgdmFyIHJlID0gc3RyaW5nRGVsaW0gPT09IFwiJ1wiID8gc3RyaW5nU2luZ2xlUmUgOiBzdHJpbmdEb3VibGVSZTtcbiAgICAgICAgcmUubGFzdEluZGV4ID0gb2Zmc2V0IC0gMTtcbiAgICAgICAgdmFyIG1hdGNoID0gcmUuZXhlYyhzb3VyY2UpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChcInN0cmluZ1wiKTtcbiAgICAgICAgb2Zmc2V0ID0gcmUubGFzdEluZGV4O1xuICAgICAgICBwdXNoKHN0cmluZ0RlbGltKTtcbiAgICAgICAgc3RyaW5nRGVsaW0gPSBudWxsO1xuICAgICAgICByZXR1cm4gdW5lc2NhcGUobWF0Y2hbMV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNoYXJhY3RlciBhdCBgcG9zYCB3aXRoaW4gdGhlIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zIFBvc2l0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQ2hhcmFjdGVyXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhckF0KHBvcykge1xuICAgICAgICByZXR1cm4gc291cmNlLmNoYXJBdChwb3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgY29tbWVudCB0ZXh0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTGVhZGluZyBzZXQgaWYgYSBsZWFkaW5nIGNvbW1lbnRcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENvbW1lbnQoc3RhcnQsIGVuZCwgaXNMZWFkaW5nKSB7XG4gICAgICAgIHZhciBjb21tZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogc291cmNlLmNoYXJBdChzdGFydCsrKSxcbiAgICAgICAgICAgIGxpbmVFbXB0eTogZmFsc2UsXG4gICAgICAgICAgICBsZWFkaW5nOiBpc0xlYWRpbmcsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBsb29rYmFjaztcbiAgICAgICAgaWYgKGFsdGVybmF0ZUNvbW1lbnRNb2RlKSB7XG4gICAgICAgICAgICBsb29rYmFjayA9IDI7ICAvLyBhbHRlcm5hdGUgY29tbWVudCBwYXJzaW5nOiBcIi8vXCIgb3IgXCIvKlwiXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb29rYmFjayA9IDM7ICAvLyBcIi8vL1wiIG9yIFwiLyoqXCJcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tbWVudE9mZnNldCA9IHN0YXJ0IC0gbG9va2JhY2ssXG4gICAgICAgICAgICBjO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoLS1jb21tZW50T2Zmc2V0IDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICAoYyA9IHNvdXJjZS5jaGFyQXQoY29tbWVudE9mZnNldCkpID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgY29tbWVudC5saW5lRW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChjID09PSBcIiBcIiB8fCBjID09PSBcIlxcdFwiKTtcbiAgICAgICAgdmFyIGxpbmVzID0gc291cmNlXG4gICAgICAgICAgICAuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpXG4gICAgICAgICAgICAuc3BsaXQoc2V0Q29tbWVudFNwbGl0UmUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgbGluZXNbaV0gPSBsaW5lc1tpXVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGFsdGVybmF0ZUNvbW1lbnRNb2RlID8gc2V0Q29tbWVudEFsdFJlIDogc2V0Q29tbWVudFJlLCBcIlwiKVxuICAgICAgICAgICAgICAgIC50cmltKCk7XG4gICAgICAgIGNvbW1lbnQudGV4dCA9IGxpbmVzXG4gICAgICAgICAgICAuam9pbihcIlxcblwiKVxuICAgICAgICAgICAgLnRyaW0oKTtcblxuICAgICAgICBjb21tZW50c1tsaW5lXSA9IGNvbW1lbnQ7XG4gICAgICAgIGxhc3RDb21tZW50TGluZSA9IGxpbmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEb3VibGVTbGFzaENvbW1lbnRMaW5lKHN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgIHZhciBlbmRPZmZzZXQgPSBmaW5kRW5kT2ZMaW5lKHN0YXJ0T2Zmc2V0KTtcblxuICAgICAgICAvLyBzZWUgaWYgcmVtYWluaW5nIGxpbmUgbWF0Y2hlcyBjb21tZW50IHBhdHRlcm5cbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gc291cmNlLnN1YnN0cmluZyhzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgdmFyIGlzQ29tbWVudCA9IC9eXFxzKlxcL1xcLy8udGVzdChsaW5lVGV4dCk7XG4gICAgICAgIHJldHVybiBpc0NvbW1lbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZEVuZE9mTGluZShjdXJzb3IpIHtcbiAgICAgICAgLy8gZmluZCBlbmQgb2YgY3Vyc29yJ3MgbGluZVxuICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gY3Vyc29yO1xuICAgICAgICB3aGlsZSAoZW5kT2Zmc2V0IDwgbGVuZ3RoICYmIGNoYXJBdChlbmRPZmZzZXQpICE9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBlbmRPZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5kT2Zmc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9idGFpbnMgdGhlIG5leHQgdG9rZW4uXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBOZXh0IHRva2VuIG9yIGBudWxsYCBvbiBlb2ZcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5zaGlmdCgpO1xuICAgICAgICBpZiAoc3RyaW5nRGVsaW0pXG4gICAgICAgICAgICByZXR1cm4gcmVhZFN0cmluZygpO1xuICAgICAgICB2YXIgcmVwZWF0LFxuICAgICAgICAgICAgcHJldixcbiAgICAgICAgICAgIGN1cnIsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGlzRG9jLFxuICAgICAgICAgICAgaXNMZWFkaW5nQ29tbWVudCA9IG9mZnNldCA9PT0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmVwZWF0ID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAod2hpdGVzcGFjZVJlLnRlc3QoY3VyciA9IGNoYXJBdChvZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzTGVhZGluZ0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICArK2xpbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgrK29mZnNldCA9PT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYXJBdChvZmZzZXQpID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIGlmICgrK29mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwoXCJjb21tZW50XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hhckF0KG9mZnNldCkgPT09IFwiL1wiKSB7IC8vIExpbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHRlcm5hdGVDb21tZW50TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHRyaXBsZS1zbGFzaCBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RvYyA9IGNoYXJBdChzdGFydCA9IG9mZnNldCArIDEpID09PSBcIi9cIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJBdCgrK29mZnNldCkgIT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKytvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDb21tZW50KHN0YXJ0LCBvZmZzZXQgLSAxLCBpc0xlYWRpbmdDb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFpbGluZyBjb21tZW50IGNhbm5vdCBub3QgYmUgbXVsdGktbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBsZWFkaW5nIGNvbW1lbnQgc3RhdGUgc2hvdWxkIGJlIHJlc2V0IHRvIGhhbmRsZSBwb3RlbnRpYWwgbmV4dCBjb21tZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTGVhZGluZ0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKytsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBkb3VibGUtc2xhc2ggY29tbWVudHMsIGNvbnNvbGlkYXRpbmcgY29uc2VjdXRpdmUgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNEb2MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RvdWJsZVNsYXNoQ29tbWVudExpbmUob2Zmc2V0IC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0RvYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBmaW5kRW5kT2ZMaW5lKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNMZWFkaW5nQ29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhaWxpbmcgY29tbWVudCBjYW5ub3Qgbm90IGJlIG11bHRpLWxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoaXNEb3VibGVTbGFzaENvbW1lbnRMaW5lKG9mZnNldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1pbihsZW5ndGgsIGZpbmRFbmRPZkxpbmUob2Zmc2V0KSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29tbWVudChzdGFydCwgb2Zmc2V0LCBpc0xlYWRpbmdDb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xlYWRpbmdDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChjdXJyID0gY2hhckF0KG9mZnNldCkpID09PSBcIipcIikgeyAvKiBCbG9jayAqL1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgLyoqIChyZWd1bGFyIGNvbW1lbnQgbW9kZSkgb3IgLyogKGFsdGVybmF0ZSBjb21tZW50IG1vZGUpXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaXNEb2MgPSBhbHRlcm5hdGVDb21tZW50TW9kZSB8fCBjaGFyQXQoc3RhcnQpID09PSBcIipcIjtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnIgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2xpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytvZmZzZXQgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwoXCJjb21tZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IGN1cnI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY2hhckF0KG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHByZXYgIT09IFwiKlwiIHx8IGN1cnIgIT09IFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgKytvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29tbWVudChzdGFydCwgb2Zmc2V0IC0gMiwgaXNMZWFkaW5nQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0xlYWRpbmdDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHJlcGVhdCk7XG5cbiAgICAgICAgLy8gb2Zmc2V0ICE9PSBsZW5ndGggaWYgd2UgZ290IGhlcmVcblxuICAgICAgICB2YXIgZW5kID0gb2Zmc2V0O1xuICAgICAgICBkZWxpbVJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHZhciBkZWxpbSA9IGRlbGltUmUudGVzdChjaGFyQXQoZW5kKyspKTtcbiAgICAgICAgaWYgKCFkZWxpbSlcbiAgICAgICAgICAgIHdoaWxlIChlbmQgPCBsZW5ndGggJiYgIWRlbGltUmUudGVzdChjaGFyQXQoZW5kKSkpXG4gICAgICAgICAgICAgICAgKytlbmQ7XG4gICAgICAgIHZhciB0b2tlbiA9IHNvdXJjZS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgPSBlbmQpO1xuICAgICAgICBpZiAodG9rZW4gPT09IFwiXFxcIlwiIHx8IHRva2VuID09PSBcIidcIilcbiAgICAgICAgICAgIHN0cmluZ0RlbGltID0gdG9rZW47XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSB0b2tlbiBiYWNrIHRvIHRoZSBzdGFjay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVG9rZW5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1c2godG9rZW4pIHtcbiAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVla3MgZm9yIHRoZSBuZXh0IHRva2VuLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gVG9rZW4gb3IgYG51bGxgIG9uIGVvZlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBlZWsoKSB7XG4gICAgICAgIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBuZXh0KCk7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhY2tbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2tpcHMgYSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgRXhwZWN0ZWQgdG9rZW5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25hbD1mYWxzZV0gV2hldGhlciB0aGUgdG9rZW4gaXMgb3B0aW9uYWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIHdoZW4gc2tpcHBlZCwgYGZhbHNlYCBpZiBub3RcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gV2hlbiBhIHJlcXVpcmVkIHRva2VuIGlzIG5vdCBwcmVzZW50XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2tpcChleHBlY3RlZCwgb3B0aW9uYWwpIHtcbiAgICAgICAgdmFyIGFjdHVhbCA9IHBlZWsoKSxcbiAgICAgICAgICAgIGVxdWFscyA9IGFjdHVhbCA9PT0gZXhwZWN0ZWQ7XG4gICAgICAgIGlmIChlcXVhbHMpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9uYWwpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwidG9rZW4gJ1wiICsgYWN0dWFsICsgXCInLCAnXCIgKyBleHBlY3RlZCArIFwiJyBleHBlY3RlZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBjb21tZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdHJhaWxpbmdMaW5lXSBMaW5lIG51bWJlciBpZiBsb29raW5nIGZvciBhIHRyYWlsaW5nIGNvbW1lbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IENvbW1lbnQgdGV4dFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNtbnQodHJhaWxpbmdMaW5lKSB7XG4gICAgICAgIHZhciByZXQgPSBudWxsO1xuICAgICAgICB2YXIgY29tbWVudDtcbiAgICAgICAgaWYgKHRyYWlsaW5nTGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21tZW50ID0gY29tbWVudHNbbGluZSAtIDFdO1xuICAgICAgICAgICAgZGVsZXRlIGNvbW1lbnRzW2xpbmUgLSAxXTtcbiAgICAgICAgICAgIGlmIChjb21tZW50ICYmIChhbHRlcm5hdGVDb21tZW50TW9kZSB8fCBjb21tZW50LnR5cGUgPT09IFwiKlwiIHx8IGNvbW1lbnQubGluZUVtcHR5KSkge1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbW1lbnQubGVhZGluZyA/IGNvbW1lbnQudGV4dCA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGxhc3RDb21tZW50TGluZSA8IHRyYWlsaW5nTGluZSkge1xuICAgICAgICAgICAgICAgIHBlZWsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50c1t0cmFpbGluZ0xpbmVdO1xuICAgICAgICAgICAgZGVsZXRlIGNvbW1lbnRzW3RyYWlsaW5nTGluZV07XG4gICAgICAgICAgICBpZiAoY29tbWVudCAmJiAhY29tbWVudC5saW5lRW1wdHkgJiYgKGFsdGVybmF0ZUNvbW1lbnRNb2RlIHx8IGNvbW1lbnQudHlwZSA9PT0gXCIvXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gY29tbWVudC5sZWFkaW5nID8gbnVsbCA6IGNvbW1lbnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICBuZXh0OiBuZXh0LFxuICAgICAgICBwZWVrOiBwZWVrLFxuICAgICAgICBwdXNoOiBwdXNoLFxuICAgICAgICBza2lwOiBza2lwLFxuICAgICAgICBjbW50OiBjbW50XG4gICAgfSwgXCJsaW5lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGxpbmU7IH1cbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbGxiYWNrLXJldHVybiAqL1xufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJ0b2tlbml6ZSIsImRlbGltUmUiLCJzdHJpbmdEb3VibGVSZSIsInN0cmluZ1NpbmdsZVJlIiwic2V0Q29tbWVudFJlIiwic2V0Q29tbWVudEFsdFJlIiwic2V0Q29tbWVudFNwbGl0UmUiLCJ3aGl0ZXNwYWNlUmUiLCJ1bmVzY2FwZVJlIiwidW5lc2NhcGVNYXAiLCJ1bmVzY2FwZSIsInN0ciIsInJlcGxhY2UiLCIkMCIsIiQxIiwic291cmNlIiwiYWx0ZXJuYXRlQ29tbWVudE1vZGUiLCJ0b1N0cmluZyIsIm9mZnNldCIsImxlbmd0aCIsImxpbmUiLCJsYXN0Q29tbWVudExpbmUiLCJjb21tZW50cyIsInN0YWNrIiwic3RyaW5nRGVsaW0iLCJpbGxlZ2FsIiwic3ViamVjdCIsIkVycm9yIiwicmVhZFN0cmluZyIsInJlIiwibGFzdEluZGV4IiwibWF0Y2giLCJleGVjIiwicHVzaCIsImNoYXJBdCIsInBvcyIsInNldENvbW1lbnQiLCJzdGFydCIsImVuZCIsImlzTGVhZGluZyIsImNvbW1lbnQiLCJ0eXBlIiwibGluZUVtcHR5IiwibGVhZGluZyIsImxvb2tiYWNrIiwiY29tbWVudE9mZnNldCIsImMiLCJsaW5lcyIsInN1YnN0cmluZyIsInNwbGl0IiwiaSIsInRyaW0iLCJ0ZXh0Iiwiam9pbiIsImlzRG91YmxlU2xhc2hDb21tZW50TGluZSIsInN0YXJ0T2Zmc2V0IiwiZW5kT2Zmc2V0IiwiZmluZEVuZE9mTGluZSIsImxpbmVUZXh0IiwiaXNDb21tZW50IiwidGVzdCIsImN1cnNvciIsIm5leHQiLCJzaGlmdCIsInJlcGVhdCIsInByZXYiLCJjdXJyIiwiaXNEb2MiLCJpc0xlYWRpbmdDb21tZW50IiwiTWF0aCIsIm1pbiIsImRlbGltIiwidG9rZW4iLCJwZWVrIiwic2tpcCIsImV4cGVjdGVkIiwib3B0aW9uYWwiLCJhY3R1YWwiLCJlcXVhbHMiLCJjbW50IiwidHJhaWxpbmdMaW5lIiwicmV0IiwidW5kZWZpbmVkIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/tokenize.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/type.js":
/*!*********************************************!*\
  !*** ./node_modules/protobufjs/src/type.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Type;\n// extends Namespace\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/protobufjs/src/namespace.js\");\n((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/protobufjs/src/enum.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/protobufjs/src/oneof.js\"), Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/protobufjs/src/field.js\"), MapField = __webpack_require__(/*! ./mapfield */ \"(ssr)/./node_modules/protobufjs/src/mapfield.js\"), Service = __webpack_require__(/*! ./service */ \"(ssr)/./node_modules/protobufjs/src/service.js\"), Message = __webpack_require__(/*! ./message */ \"(ssr)/./node_modules/protobufjs/src/message.js\"), Reader = __webpack_require__(/*! ./reader */ \"(ssr)/./node_modules/protobufjs/src/reader.js\"), Writer = __webpack_require__(/*! ./writer */ \"(ssr)/./node_modules/protobufjs/src/writer.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\"), encoder = __webpack_require__(/*! ./encoder */ \"(ssr)/./node_modules/protobufjs/src/encoder.js\"), decoder = __webpack_require__(/*! ./decoder */ \"(ssr)/./node_modules/protobufjs/src/decoder.js\"), verifier = __webpack_require__(/*! ./verifier */ \"(ssr)/./node_modules/protobufjs/src/verifier.js\"), converter = __webpack_require__(/*! ./converter */ \"(ssr)/./node_modules/protobufjs/src/converter.js\"), wrappers = __webpack_require__(/*! ./wrappers */ \"(ssr)/./node_modules/protobufjs/src/wrappers.js\");\n/**\n * Constructs a new reflected message type instance.\n * @classdesc Reflected message type.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Message name\n * @param {Object.<string,*>} [options] Declared options\n */ function Type(name, options) {\n    Namespace.call(this, name, options);\n    /**\n     * Message fields.\n     * @type {Object.<string,Field>}\n     */ this.fields = {}; // toJSON, marker\n    /**\n     * Oneofs declared within this namespace, if any.\n     * @type {Object.<string,OneOf>}\n     */ this.oneofs = undefined; // toJSON\n    /**\n     * Extension ranges, if any.\n     * @type {number[][]}\n     */ this.extensions = undefined; // toJSON\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */ this.reserved = undefined; // toJSON\n    /*?\n     * Whether this type is a legacy group.\n     * @type {boolean|undefined}\n     */ this.group = undefined; // toJSON\n    /**\n     * Cached fields by id.\n     * @type {Object.<number,Field>|null}\n     * @private\n     */ this._fieldsById = null;\n    /**\n     * Cached fields as an array.\n     * @type {Field[]|null}\n     * @private\n     */ this._fieldsArray = null;\n    /**\n     * Cached oneofs as an array.\n     * @type {OneOf[]|null}\n     * @private\n     */ this._oneofsArray = null;\n    /**\n     * Cached constructor.\n     * @type {Constructor<{}>}\n     * @private\n     */ this._ctor = null;\n}\nObject.defineProperties(Type.prototype, {\n    /**\n     * Message fields by id.\n     * @name Type#fieldsById\n     * @type {Object.<number,Field>}\n     * @readonly\n     */ fieldsById: {\n        get: function() {\n            /* istanbul ignore if */ if (this._fieldsById) return this._fieldsById;\n            this._fieldsById = {};\n            for(var names = Object.keys(this.fields), i = 0; i < names.length; ++i){\n                var field = this.fields[names[i]], id = field.id;\n                /* istanbul ignore if */ if (this._fieldsById[id]) throw Error(\"duplicate id \" + id + \" in \" + this);\n                this._fieldsById[id] = field;\n            }\n            return this._fieldsById;\n        }\n    },\n    /**\n     * Fields of this message as an array for iteration.\n     * @name Type#fieldsArray\n     * @type {Field[]}\n     * @readonly\n     */ fieldsArray: {\n        get: function() {\n            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\n        }\n    },\n    /**\n     * Oneofs of this message as an array for iteration.\n     * @name Type#oneofsArray\n     * @type {OneOf[]}\n     * @readonly\n     */ oneofsArray: {\n        get: function() {\n            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\n        }\n    },\n    /**\n     * The registered constructor, if any registered, otherwise a generic constructor.\n     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\n     * @name Type#ctor\n     * @type {Constructor<{}>}\n     */ ctor: {\n        get: function() {\n            return this._ctor || (this.ctor = Type.generateConstructor(this)());\n        },\n        set: function(ctor) {\n            // Ensure proper prototype\n            var prototype = ctor.prototype;\n            if (!(prototype instanceof Message)) {\n                (ctor.prototype = new Message()).constructor = ctor;\n                util.merge(ctor.prototype, prototype);\n            }\n            // Classes and messages reference their reflected type\n            ctor.$type = ctor.prototype.$type = this;\n            // Mix in static methods\n            util.merge(ctor, Message, true);\n            this._ctor = ctor;\n            // Messages have non-enumerable default values on their prototype\n            var i = 0;\n            for(; i < /* initializes */ this.fieldsArray.length; ++i)this._fieldsArray[i].resolve(); // ensures a proper value\n            // Messages have non-enumerable getters and setters for each virtual oneof field\n            var ctorProperties = {};\n            for(i = 0; i < /* initializes */ this.oneofsArray.length; ++i)ctorProperties[this._oneofsArray[i].resolve().name] = {\n                get: util.oneOfGetter(this._oneofsArray[i].oneof),\n                set: util.oneOfSetter(this._oneofsArray[i].oneof)\n            };\n            if (i) Object.defineProperties(ctor.prototype, ctorProperties);\n        }\n    }\n});\n/**\n * Generates a constructor function for the specified type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ Type.generateConstructor = function generateConstructor(mtype) {\n    /* eslint-disable no-unexpected-multiline */ var gen = util.codegen([\n        \"p\"\n    ], mtype.name);\n    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype\n    for(var i = 0, field; i < mtype.fieldsArray.length; ++i)if ((field = mtype._fieldsArray[i]).map) gen(\"this%s={}\", util.safeProp(field.name));\n    else if (field.repeated) gen(\"this%s=[]\", util.safeProp(field.name));\n    return gen(\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\") // omit undefined or null\n    (\"this[ks[i]]=p[ks[i]]\");\n/* eslint-enable no-unexpected-multiline */ };\nfunction clearCache(type) {\n    type._fieldsById = type._fieldsArray = type._oneofsArray = null;\n    delete type.encode;\n    delete type.decode;\n    delete type.verify;\n    return type;\n}\n/**\n * Message type descriptor.\n * @interface IType\n * @extends INamespace\n * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors\n * @property {Object.<string,IField>} fields Field descriptors\n * @property {number[][]} [extensions] Extension ranges\n * @property {number[][]} [reserved] Reserved ranges\n * @property {boolean} [group=false] Whether a legacy group or not\n */ /**\n * Creates a message type from a message type descriptor.\n * @param {string} name Message name\n * @param {IType} json Message type descriptor\n * @returns {Type} Created message type\n */ Type.fromJSON = function fromJSON(name, json) {\n    var type = new Type(name, json.options);\n    type.extensions = json.extensions;\n    type.reserved = json.reserved;\n    var names = Object.keys(json.fields), i = 0;\n    for(; i < names.length; ++i)type.add((typeof json.fields[names[i]].keyType !== \"undefined\" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]]));\n    if (json.oneofs) for(names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\n    if (json.nested) for(names = Object.keys(json.nested), i = 0; i < names.length; ++i){\n        var nested = json.nested[names[i]];\n        type.add((nested.id !== undefined ? Field.fromJSON : nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : Namespace.fromJSON)(names[i], nested));\n    }\n    if (json.extensions && json.extensions.length) type.extensions = json.extensions;\n    if (json.reserved && json.reserved.length) type.reserved = json.reserved;\n    if (json.group) type.group = true;\n    if (json.comment) type.comment = json.comment;\n    return type;\n};\n/**\n * Converts this message type to a message type descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IType} Message type descriptor\n */ Type.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\",\n        inherited && inherited.options || undefined,\n        \"oneofs\",\n        Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),\n        \"fields\",\n        Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {\n            return !obj.declaringField;\n        }), toJSONOptions) || {},\n        \"extensions\",\n        this.extensions && this.extensions.length ? this.extensions : undefined,\n        \"reserved\",\n        this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"group\",\n        this.group || undefined,\n        \"nested\",\n        inherited && inherited.nested || undefined,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * @override\n */ Type.prototype.resolveAll = function resolveAll() {\n    var fields = this.fieldsArray, i = 0;\n    while(i < fields.length)fields[i++].resolve();\n    var oneofs = this.oneofsArray;\n    i = 0;\n    while(i < oneofs.length)oneofs[i++].resolve();\n    return Namespace.prototype.resolveAll.call(this);\n};\n/**\n * @override\n */ Type.prototype.get = function get(name) {\n    return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;\n};\n/**\n * Adds a nested object to this type.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id\n */ Type.prototype.add = function add(object) {\n    if (this.get(object.name)) throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n    if (object instanceof Field && object.extend === undefined) {\n        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.\n        // The root object takes care of adding distinct sister-fields to the respective extended\n        // type instead.\n        // avoids calling the getter if not absolutely necessary because it's called quite frequently\n        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id]) throw Error(\"duplicate id \" + object.id + \" in \" + this);\n        if (this.isReservedId(object.id)) throw Error(\"id \" + object.id + \" is reserved in \" + this);\n        if (this.isReservedName(object.name)) throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\n        if (object.parent) object.parent.remove(object);\n        this.fields[object.name] = object;\n        object.message = this;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        if (!this.oneofs) this.oneofs = {};\n        this.oneofs[object.name] = object;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n/**\n * Removes a nested object from this type.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this type\n */ Type.prototype.remove = function remove(object) {\n    if (object instanceof Field && object.extend === undefined) {\n        // See Type#add for the reason why extension fields are excluded here.\n        /* istanbul ignore if */ if (!this.fields || this.fields[object.name] !== object) throw Error(object + \" is not a member of \" + this);\n        delete this.fields[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        /* istanbul ignore if */ if (!this.oneofs || this.oneofs[object.name] !== object) throw Error(object + \" is not a member of \" + this);\n        delete this.oneofs[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Type.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Type.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<{}>} Message instance\n */ Type.prototype.create = function create(properties) {\n    return new this.ctor(properties);\n};\n/**\n * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.\n * @returns {Type} `this`\n */ Type.prototype.setup = function setup() {\n    // Sets up everything at once so that the prototype chain does not have to be re-evaluated\n    // multiple times (V8, soft-deopt prototype-check).\n    var fullName = this.fullName, types = [];\n    for(var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)types.push(this._fieldsArray[i].resolve().resolvedType);\n    // Replace setup methods with type-specific generated functions\n    this.encode = encoder(this)({\n        Writer: Writer,\n        types: types,\n        util: util\n    });\n    this.decode = decoder(this)({\n        Reader: Reader,\n        types: types,\n        util: util\n    });\n    this.verify = verifier(this)({\n        types: types,\n        util: util\n    });\n    this.fromObject = converter.fromObject(this)({\n        types: types,\n        util: util\n    });\n    this.toObject = converter.toObject(this)({\n        types: types,\n        util: util\n    });\n    // Inject custom wrappers for common types\n    var wrapper = wrappers[fullName];\n    if (wrapper) {\n        var originalThis = Object.create(this);\n        // if (wrapper.fromObject) {\n        originalThis.fromObject = this.fromObject;\n        this.fromObject = wrapper.fromObject.bind(originalThis);\n        // }\n        // if (wrapper.toObject) {\n        originalThis.toObject = this.toObject;\n        this.toObject = wrapper.toObject.bind(originalThis);\n    // }\n    }\n    return this;\n};\n/**\n * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */ Type.prototype.encode = function encode_setup(message, writer) {\n    return this.setup().encode(message, writer); // overrides this method\n};\n/**\n * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */ Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\n};\n/**\n * Decodes a message of this type.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @param {number} [length] Length of the message, if known beforehand\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError<{}>} If required fields are missing\n */ Type.prototype.decode = function decode_setup(reader, length) {\n    return this.setup().decode(reader, length); // overrides this method\n};\n/**\n * Decodes a message of this type preceeded by its byte length as a varint.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError} If required fields are missing\n */ Type.prototype.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof Reader)) reader = Reader.create(reader);\n    return this.decode(reader, reader.uint32());\n};\n/**\n * Verifies that field values are valid and that required fields are present.\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {null|string} `null` if valid, otherwise the reason why it is not\n */ Type.prototype.verify = function verify_setup(message) {\n    return this.setup().verify(message); // overrides this method\n};\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object to convert\n * @returns {Message<{}>} Message instance\n */ Type.prototype.fromObject = function fromObject(object) {\n    return this.setup().fromObject(object);\n};\n/**\n * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\n * @interface IConversionOptions\n * @property {Function} [longs] Long conversion type.\n * Valid values are `String` and `Number` (the global types).\n * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\n * @property {Function} [enums] Enum value conversion type.\n * Only valid value is `String` (the global type).\n * Defaults to copy the present value, which is the numeric id.\n * @property {Function} [bytes] Bytes value conversion type.\n * Valid values are `Array` and (a base64 encoded) `String` (the global types).\n * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\n * @property {boolean} [defaults=false] Also sets default values on the resulting object\n * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\n * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\n * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\n * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\n */ /**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n */ Type.prototype.toObject = function toObject(message, options) {\n    return this.setup().toObject(message, options);\n};\n/**\n * Decorator function as returned by {@link Type.d} (TypeScript).\n * @typedef TypeDecorator\n * @type {function}\n * @param {Constructor<T>} target Target constructor\n * @returns {undefined}\n * @template T extends Message<T>\n */ /**\n * Type decorator (TypeScript).\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {TypeDecorator<T>} Decorator function\n * @template T extends Message<T>\n */ Type.d = function decorateType(typeName) {\n    return function typeDecorator(target) {\n        util.decorateType(target, typeName);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLG9CQUFvQjtBQUNwQixJQUFJQyxZQUFZQyxtQkFBT0EsQ0FBQyxxRUFBYTtBQUNwQyxFQUFDRixLQUFLRyxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0osVUFBVUUsU0FBUyxHQUFHRyxXQUFXLEdBQUdOLElBQUcsRUFBR08sU0FBUyxHQUFHO0FBRXZGLElBQUlDLE9BQVlOLG1CQUFPQSxDQUFDLDJEQUFRLEdBQzVCTyxRQUFZUCxtQkFBT0EsQ0FBQyw2REFBUyxHQUM3QlEsUUFBWVIsbUJBQU9BLENBQUMsNkRBQVMsR0FDN0JTLFdBQVlULG1CQUFPQSxDQUFDLG1FQUFZLEdBQ2hDVSxVQUFZVixtQkFBT0EsQ0FBQyxpRUFBVyxHQUMvQlcsVUFBWVgsbUJBQU9BLENBQUMsaUVBQVcsR0FDL0JZLFNBQVlaLG1CQUFPQSxDQUFDLCtEQUFVLEdBQzlCYSxTQUFZYixtQkFBT0EsQ0FBQywrREFBVSxHQUM5QmMsT0FBWWQsbUJBQU9BLENBQUMsMkRBQVEsR0FDNUJlLFVBQVlmLG1CQUFPQSxDQUFDLGlFQUFXLEdBQy9CZ0IsVUFBWWhCLG1CQUFPQSxDQUFDLGlFQUFXLEdBQy9CaUIsV0FBWWpCLG1CQUFPQSxDQUFDLG1FQUFZLEdBQ2hDa0IsWUFBWWxCLG1CQUFPQSxDQUFDLHFFQUFhLEdBQ2pDbUIsV0FBWW5CLG1CQUFPQSxDQUFDLG1FQUFZO0FBRXBDOzs7Ozs7O0NBT0MsR0FDRCxTQUFTRixLQUFLc0IsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZCdEIsVUFBVXVCLElBQUksQ0FBQyxJQUFJLEVBQUVGLE1BQU1DO0lBRTNCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0UsTUFBTSxHQUFHLENBQUMsR0FBSSxpQkFBaUI7SUFFcEM7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxNQUFNLEdBQUdDLFdBQVcsU0FBUztJQUVs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R0FDRHhGLEtBQUtHLFNBQVMsQ0FBQytFLFFBQVEsR0FBRyxTQUFTQSxTQUFTWSxPQUFPLEVBQUV2RSxPQUFPO0lBQ3hELE9BQU8sSUFBSSxDQUFDMkUsS0FBSyxHQUFHaEIsUUFBUSxDQUFDWSxTQUFTdkU7QUFDMUM7QUFFQTs7Ozs7OztDQU9DLEdBRUQ7Ozs7O0NBS0MsR0FDRHZCLEtBQUtzSCxDQUFDLEdBQUcsU0FBU0MsYUFBYUMsUUFBUTtJQUNuQyxPQUFPLFNBQVNDLGNBQWNDLE1BQU07UUFDaEMxRyxLQUFLdUcsWUFBWSxDQUFDRyxRQUFRRjtJQUM5QjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy90eXBlLmpzP2M3MDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFR5cGU7XG5cbi8vIGV4dGVuZHMgTmFtZXNwYWNlXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xuKChUeXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gVHlwZSkuY2xhc3NOYW1lID0gXCJUeXBlXCI7XG5cbnZhciBFbnVtICAgICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIE9uZU9mICAgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpLFxuICAgIEZpZWxkICAgICA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxuICAgIE1hcEZpZWxkICA9IHJlcXVpcmUoXCIuL21hcGZpZWxkXCIpLFxuICAgIFNlcnZpY2UgICA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIiksXG4gICAgTWVzc2FnZSAgID0gcmVxdWlyZShcIi4vbWVzc2FnZVwiKSxcbiAgICBSZWFkZXIgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIiksXG4gICAgV3JpdGVyICAgID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpLFxuICAgIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIiksXG4gICAgZW5jb2RlciAgID0gcmVxdWlyZShcIi4vZW5jb2RlclwiKSxcbiAgICBkZWNvZGVyICAgPSByZXF1aXJlKFwiLi9kZWNvZGVyXCIpLFxuICAgIHZlcmlmaWVyICA9IHJlcXVpcmUoXCIuL3ZlcmlmaWVyXCIpLFxuICAgIGNvbnZlcnRlciA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlclwiKSxcbiAgICB3cmFwcGVycyAgPSByZXF1aXJlKFwiLi93cmFwcGVyc1wiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlZmxlY3RlZCBtZXNzYWdlIHR5cGUgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBtZXNzYWdlIHR5cGUuXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1lc3NhZ2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gVHlwZShuYW1lLCBvcHRpb25zKSB7XG4gICAgTmFtZXNwYWNlLmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBNZXNzYWdlIGZpZWxkcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsRmllbGQ+fVxuICAgICAqL1xuICAgIHRoaXMuZmllbGRzID0ge307ICAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogT25lb2ZzIGRlY2xhcmVkIHdpdGhpbiB0aGlzIG5hbWVzcGFjZSwgaWYgYW55LlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxPbmVPZj59XG4gICAgICovXG4gICAgdGhpcy5vbmVvZnMgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5zaW9uIHJhbmdlcywgaWYgYW55LlxuICAgICAqIEB0eXBlIHtudW1iZXJbXVtdfVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBSZXNlcnZlZCByYW5nZXMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcltdfHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5yZXNlcnZlZCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKj9cbiAgICAgKiBXaGV0aGVyIHRoaXMgdHlwZSBpcyBhIGxlZ2FjeSBncm91cC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5ncm91cCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgZmllbGRzIGJ5IGlkLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPG51bWJlcixGaWVsZD58bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZpZWxkc0J5SWQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIGZpZWxkcyBhcyBhbiBhcnJheS5cbiAgICAgKiBAdHlwZSB7RmllbGRbXXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmllbGRzQXJyYXkgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIG9uZW9mcyBhcyBhbiBhcnJheS5cbiAgICAgKiBAdHlwZSB7T25lT2ZbXXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fb25lb2ZzQXJyYXkgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIGNvbnN0cnVjdG9yLlxuICAgICAqIEB0eXBlIHtDb25zdHJ1Y3Rvcjx7fT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jdG9yID0gbnVsbDtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHlwZS5wcm90b3R5cGUsIHtcblxuICAgIC8qKlxuICAgICAqIE1lc3NhZ2UgZmllbGRzIGJ5IGlkLlxuICAgICAqIEBuYW1lIFR5cGUjZmllbGRzQnlJZFxuICAgICAqIEB0eXBlIHtPYmplY3QuPG51bWJlcixGaWVsZD59XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZmllbGRzQnlJZDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLl9maWVsZHNCeUlkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWVsZHNCeUlkO1xuXG4gICAgICAgICAgICB0aGlzLl9maWVsZHNCeUlkID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuZmllbGRzKSwgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzW25hbWVzW2ldXSxcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBmaWVsZC5pZDtcblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9maWVsZHNCeUlkW2lkXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgaWQgXCIgKyBpZCArIFwiIGluIFwiICsgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9maWVsZHNCeUlkW2lkXSA9IGZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkc0J5SWQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmllbGRzIG9mIHRoaXMgbWVzc2FnZSBhcyBhbiBhcnJheSBmb3IgaXRlcmF0aW9uLlxuICAgICAqIEBuYW1lIFR5cGUjZmllbGRzQXJyYXlcbiAgICAgKiBAdHlwZSB7RmllbGRbXX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBmaWVsZHNBcnJheToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkc0FycmF5IHx8ICh0aGlzLl9maWVsZHNBcnJheSA9IHV0aWwudG9BcnJheSh0aGlzLmZpZWxkcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uZW9mcyBvZiB0aGlzIG1lc3NhZ2UgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAgICAgKiBAbmFtZSBUeXBlI29uZW9mc0FycmF5XG4gICAgICogQHR5cGUge09uZU9mW119XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgb25lb2ZzQXJyYXk6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmVvZnNBcnJheSB8fCAodGhpcy5fb25lb2ZzQXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5vbmVvZnMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVnaXN0ZXJlZCBjb25zdHJ1Y3RvciwgaWYgYW55IHJlZ2lzdGVyZWQsIG90aGVyd2lzZSBhIGdlbmVyaWMgY29uc3RydWN0b3IuXG4gICAgICogQXNzaWduaW5nIGEgZnVuY3Rpb24gcmVwbGFjZXMgdGhlIGludGVybmFsIGNvbnN0cnVjdG9yLiBJZiB0aGUgZnVuY3Rpb24gZG9lcyBub3QgZXh0ZW5kIHtAbGluayBNZXNzYWdlfSB5ZXQsIGl0cyBwcm90b3R5cGUgd2lsbCBiZSBzZXR1cCBhY2NvcmRpbmdseSBhbmQgc3RhdGljIG1ldGhvZHMgd2lsbCBiZSBwb3B1bGF0ZWQuIElmIGl0IGFscmVhZHkgZXh0ZW5kcyB7QGxpbmsgTWVzc2FnZX0sIGl0IHdpbGwganVzdCByZXBsYWNlIHRoZSBpbnRlcm5hbCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAbmFtZSBUeXBlI2N0b3JcbiAgICAgKiBAdHlwZSB7Q29uc3RydWN0b3I8e30+fVxuICAgICAqL1xuICAgIGN0b3I6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdG9yIHx8ICh0aGlzLmN0b3IgPSBUeXBlLmdlbmVyYXRlQ29uc3RydWN0b3IodGhpcykoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oY3Rvcikge1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgcHJvcGVyIHByb3RvdHlwZVxuICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IGN0b3IucHJvdG90eXBlO1xuICAgICAgICAgICAgaWYgKCEocHJvdG90eXBlIGluc3RhbmNlb2YgTWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAoY3Rvci5wcm90b3R5cGUgPSBuZXcgTWVzc2FnZSgpKS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gICAgICAgICAgICAgICAgdXRpbC5tZXJnZShjdG9yLnByb3RvdHlwZSwgcHJvdG90eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xhc3NlcyBhbmQgbWVzc2FnZXMgcmVmZXJlbmNlIHRoZWlyIHJlZmxlY3RlZCB0eXBlXG4gICAgICAgICAgICBjdG9yLiR0eXBlID0gY3Rvci5wcm90b3R5cGUuJHR5cGUgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBNaXggaW4gc3RhdGljIG1ldGhvZHNcbiAgICAgICAgICAgIHV0aWwubWVyZ2UoY3RvciwgTWVzc2FnZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2N0b3IgPSBjdG9yO1xuXG4gICAgICAgICAgICAvLyBNZXNzYWdlcyBoYXZlIG5vbi1lbnVtZXJhYmxlIGRlZmF1bHQgdmFsdWVzIG9uIHRoZWlyIHByb3RvdHlwZVxuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCAvKiBpbml0aWFsaXplcyAqLyB0aGlzLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmUoKTsgLy8gZW5zdXJlcyBhIHByb3BlciB2YWx1ZVxuXG4gICAgICAgICAgICAvLyBNZXNzYWdlcyBoYXZlIG5vbi1lbnVtZXJhYmxlIGdldHRlcnMgYW5kIHNldHRlcnMgZm9yIGVhY2ggdmlydHVhbCBvbmVvZiBmaWVsZFxuICAgICAgICAgICAgdmFyIGN0b3JQcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gdGhpcy5vbmVvZnNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjdG9yUHJvcGVydGllc1t0aGlzLl9vbmVvZnNBcnJheVtpXS5yZXNvbHZlKCkubmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogdXRpbC5vbmVPZkdldHRlcih0aGlzLl9vbmVvZnNBcnJheVtpXS5vbmVvZiksXG4gICAgICAgICAgICAgICAgICAgIHNldDogdXRpbC5vbmVPZlNldHRlcih0aGlzLl9vbmVvZnNBcnJheVtpXS5vbmVvZilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY3Rvci5wcm90b3R5cGUsIGN0b3JQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuVHlwZS5nZW5lcmF0ZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gZ2VuZXJhdGVDb25zdHJ1Y3RvcihtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJwXCJdLCBtdHlwZS5uYW1lKTtcbiAgICAvLyBleHBsaWNpdGx5IGluaXRpYWxpemUgbXV0YWJsZSBvYmplY3QvYXJyYXkgZmllbGRzIHNvIHRoYXQgdGhlc2UgYXJlbid0IGp1c3QgaW5oZXJpdGVkIGZyb20gdGhlIHByb3RvdHlwZVxuICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZDsgaSA8IG10eXBlLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoKGZpZWxkID0gbXR5cGUuX2ZpZWxkc0FycmF5W2ldKS5tYXApIGdlblxuICAgICAgICAgICAgKFwidGhpcyVzPXt9XCIsIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSkpO1xuICAgICAgICBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgZ2VuXG4gICAgICAgICAgICAoXCJ0aGlzJXM9W11cIiwgdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKSk7XG4gICAgcmV0dXJuIGdlblxuICAgIChcImlmKHApZm9yKHZhciBrcz1PYmplY3Qua2V5cyhwKSxpPTA7aTxrcy5sZW5ndGg7KytpKWlmKHBba3NbaV1dIT1udWxsKVwiKSAvLyBvbWl0IHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgIChcInRoaXNba3NbaV1dPXBba3NbaV1dXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn07XG5cbmZ1bmN0aW9uIGNsZWFyQ2FjaGUodHlwZSkge1xuICAgIHR5cGUuX2ZpZWxkc0J5SWQgPSB0eXBlLl9maWVsZHNBcnJheSA9IHR5cGUuX29uZW9mc0FycmF5ID0gbnVsbDtcbiAgICBkZWxldGUgdHlwZS5lbmNvZGU7XG4gICAgZGVsZXRlIHR5cGUuZGVjb2RlO1xuICAgIGRlbGV0ZSB0eXBlLnZlcmlmeTtcbiAgICByZXR1cm4gdHlwZTtcbn1cblxuLyoqXG4gKiBNZXNzYWdlIHR5cGUgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSVR5cGVcbiAqIEBleHRlbmRzIElOYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsSU9uZU9mPn0gW29uZW9mc10gT25lb2YgZGVzY3JpcHRvcnNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsSUZpZWxkPn0gZmllbGRzIEZpZWxkIGRlc2NyaXB0b3JzXG4gKiBAcHJvcGVydHkge251bWJlcltdW119IFtleHRlbnNpb25zXSBFeHRlbnNpb24gcmFuZ2VzXG4gKiBAcHJvcGVydHkge251bWJlcltdW119IFtyZXNlcnZlZF0gUmVzZXJ2ZWQgcmFuZ2VzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtncm91cD1mYWxzZV0gV2hldGhlciBhIGxlZ2FjeSBncm91cCBvciBub3RcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtZXNzYWdlIHR5cGUgZnJvbSBhIG1lc3NhZ2UgdHlwZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWVzc2FnZSBuYW1lXG4gKiBAcGFyYW0ge0lUeXBlfSBqc29uIE1lc3NhZ2UgdHlwZSBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7VHlwZX0gQ3JlYXRlZCBtZXNzYWdlIHR5cGVcbiAqL1xuVHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICB2YXIgdHlwZSA9IG5ldyBUeXBlKG5hbWUsIGpzb24ub3B0aW9ucyk7XG4gICAgdHlwZS5leHRlbnNpb25zID0ganNvbi5leHRlbnNpb25zO1xuICAgIHR5cGUucmVzZXJ2ZWQgPSBqc29uLnJlc2VydmVkO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGpzb24uZmllbGRzKSxcbiAgICAgICAgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgdHlwZS5hZGQoXG4gICAgICAgICAgICAoIHR5cGVvZiBqc29uLmZpZWxkc1tuYW1lc1tpXV0ua2V5VHlwZSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgPyBNYXBGaWVsZC5mcm9tSlNPTlxuICAgICAgICAgICAgOiBGaWVsZC5mcm9tSlNPTiApKG5hbWVzW2ldLCBqc29uLmZpZWxkc1tuYW1lc1tpXV0pXG4gICAgICAgICk7XG4gICAgaWYgKGpzb24ub25lb2ZzKVxuICAgICAgICBmb3IgKG5hbWVzID0gT2JqZWN0LmtleXMoanNvbi5vbmVvZnMpLCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdHlwZS5hZGQoT25lT2YuZnJvbUpTT04obmFtZXNbaV0sIGpzb24ub25lb2ZzW25hbWVzW2ldXSkpO1xuICAgIGlmIChqc29uLm5lc3RlZClcbiAgICAgICAgZm9yIChuYW1lcyA9IE9iamVjdC5rZXlzKGpzb24ubmVzdGVkKSwgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5lc3RlZCA9IGpzb24ubmVzdGVkW25hbWVzW2ldXTtcbiAgICAgICAgICAgIHR5cGUuYWRkKCAvLyBtb3N0IHRvIGxlYXN0IGxpa2VseVxuICAgICAgICAgICAgICAgICggbmVzdGVkLmlkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IEZpZWxkLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQuZmllbGRzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFR5cGUuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IG5lc3RlZC52YWx1ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gRW51bS5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLm1ldGhvZHMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gU2VydmljZS5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogTmFtZXNwYWNlLmZyb21KU09OICkobmFtZXNbaV0sIG5lc3RlZClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICBpZiAoanNvbi5leHRlbnNpb25zICYmIGpzb24uZXh0ZW5zaW9ucy5sZW5ndGgpXG4gICAgICAgIHR5cGUuZXh0ZW5zaW9ucyA9IGpzb24uZXh0ZW5zaW9ucztcbiAgICBpZiAoanNvbi5yZXNlcnZlZCAmJiBqc29uLnJlc2VydmVkLmxlbmd0aClcbiAgICAgICAgdHlwZS5yZXNlcnZlZCA9IGpzb24ucmVzZXJ2ZWQ7XG4gICAgaWYgKGpzb24uZ3JvdXApXG4gICAgICAgIHR5cGUuZ3JvdXAgPSB0cnVlO1xuICAgIGlmIChqc29uLmNvbW1lbnQpXG4gICAgICAgIHR5cGUuY29tbWVudCA9IGpzb24uY29tbWVudDtcbiAgICByZXR1cm4gdHlwZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBtZXNzYWdlIHR5cGUgdG8gYSBtZXNzYWdlIHR5cGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lUeXBlfSBNZXNzYWdlIHR5cGUgZGVzY3JpcHRvclxuICovXG5UeXBlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBpbmhlcml0ZWQgPSBOYW1lc3BhY2UucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMsIHRvSlNPTk9wdGlvbnMpO1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwib3B0aW9uc1wiICAgICwgaW5oZXJpdGVkICYmIGluaGVyaXRlZC5vcHRpb25zIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJvbmVvZnNcIiAgICAgLCBOYW1lc3BhY2UuYXJyYXlUb0pTT04odGhpcy5vbmVvZnNBcnJheSwgdG9KU09OT3B0aW9ucyksXG4gICAgICAgIFwiZmllbGRzXCIgICAgICwgTmFtZXNwYWNlLmFycmF5VG9KU09OKHRoaXMuZmllbGRzQXJyYXkuZmlsdGVyKGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gIW9iai5kZWNsYXJpbmdGaWVsZDsgfSksIHRvSlNPTk9wdGlvbnMpIHx8IHt9LFxuICAgICAgICBcImV4dGVuc2lvbnNcIiAsIHRoaXMuZXh0ZW5zaW9ucyAmJiB0aGlzLmV4dGVuc2lvbnMubGVuZ3RoID8gdGhpcy5leHRlbnNpb25zIDogdW5kZWZpbmVkLFxuICAgICAgICBcInJlc2VydmVkXCIgICAsIHRoaXMucmVzZXJ2ZWQgJiYgdGhpcy5yZXNlcnZlZC5sZW5ndGggPyB0aGlzLnJlc2VydmVkIDogdW5kZWZpbmVkLFxuICAgICAgICBcImdyb3VwXCIgICAgICAsIHRoaXMuZ3JvdXAgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcIm5lc3RlZFwiICAgICAsIGluaGVyaXRlZCAmJiBpbmhlcml0ZWQubmVzdGVkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJjb21tZW50XCIgICAgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblR5cGUucHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbiByZXNvbHZlQWxsKCkge1xuICAgIHZhciBmaWVsZHMgPSB0aGlzLmZpZWxkc0FycmF5LCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGZpZWxkcy5sZW5ndGgpXG4gICAgICAgIGZpZWxkc1tpKytdLnJlc29sdmUoKTtcbiAgICB2YXIgb25lb2ZzID0gdGhpcy5vbmVvZnNBcnJheTsgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBvbmVvZnMubGVuZ3RoKVxuICAgICAgICBvbmVvZnNbaSsrXS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVzb2x2ZUFsbC5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHlwZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5maWVsZHNbbmFtZV1cbiAgICAgICAgfHwgdGhpcy5vbmVvZnMgJiYgdGhpcy5vbmVvZnNbbmFtZV1cbiAgICAgICAgfHwgdGhpcy5uZXN0ZWQgJiYgdGhpcy5uZXN0ZWRbbmFtZV1cbiAgICAgICAgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQWRkcyBhIG5lc3RlZCBvYmplY3QgdG8gdGhpcyB0eXBlLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgTmVzdGVkIG9iamVjdCB0byBhZGRcbiAqIEByZXR1cm5zIHtUeXBlfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIG5lc3RlZCBvYmplY3Qgd2l0aCB0aGlzIG5hbWUgb3IsIGlmIGEgZmllbGQsIHdoZW4gdGhlcmUgaXMgYWxyZWFkeSBhIGZpZWxkIHdpdGggdGhpcyBpZFxuICovXG5UeXBlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQob2JqZWN0KSB7XG5cbiAgICBpZiAodGhpcy5nZXQob2JqZWN0Lm5hbWUpKVxuICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBuYW1lICdcIiArIG9iamVjdC5uYW1lICsgXCInIGluIFwiICsgdGhpcyk7XG5cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRmllbGQgJiYgb2JqZWN0LmV4dGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE5PVEU6IEV4dGVuc2lvbiBmaWVsZHMgYXJlbid0IGFjdHVhbCBmaWVsZHMgb24gdGhlIGRlY2xhcmluZyB0eXBlLCBidXQgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgIC8vIFRoZSByb290IG9iamVjdCB0YWtlcyBjYXJlIG9mIGFkZGluZyBkaXN0aW5jdCBzaXN0ZXItZmllbGRzIHRvIHRoZSByZXNwZWN0aXZlIGV4dGVuZGVkXG4gICAgICAgIC8vIHR5cGUgaW5zdGVhZC5cblxuICAgICAgICAvLyBhdm9pZHMgY2FsbGluZyB0aGUgZ2V0dGVyIGlmIG5vdCBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSBiZWNhdXNlIGl0J3MgY2FsbGVkIHF1aXRlIGZyZXF1ZW50bHlcbiAgICAgICAgaWYgKHRoaXMuX2ZpZWxkc0J5SWQgPyAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB0aGlzLl9maWVsZHNCeUlkW29iamVjdC5pZF0gOiB0aGlzLmZpZWxkc0J5SWRbb2JqZWN0LmlkXSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGlkIFwiICsgb2JqZWN0LmlkICsgXCIgaW4gXCIgKyB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXNlcnZlZElkKG9iamVjdC5pZCkpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImlkIFwiICsgb2JqZWN0LmlkICsgXCIgaXMgcmVzZXJ2ZWQgaW4gXCIgKyB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXNlcnZlZE5hbWUob2JqZWN0Lm5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJuYW1lICdcIiArIG9iamVjdC5uYW1lICsgXCInIGlzIHJlc2VydmVkIGluIFwiICsgdGhpcyk7XG5cbiAgICAgICAgaWYgKG9iamVjdC5wYXJlbnQpXG4gICAgICAgICAgICBvYmplY3QucGFyZW50LnJlbW92ZShvYmplY3QpO1xuICAgICAgICB0aGlzLmZpZWxkc1tvYmplY3QubmFtZV0gPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdC5tZXNzYWdlID0gdGhpcztcbiAgICAgICAgb2JqZWN0Lm9uQWRkKHRoaXMpO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE9uZU9mKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmVvZnMpXG4gICAgICAgICAgICB0aGlzLm9uZW9mcyA9IHt9O1xuICAgICAgICB0aGlzLm9uZW9mc1tvYmplY3QubmFtZV0gPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdC5vbkFkZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIG9iamVjdCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBuZXN0ZWQgb2JqZWN0IGZyb20gdGhpcyB0eXBlLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgTmVzdGVkIG9iamVjdCB0byByZW1vdmVcbiAqIEByZXR1cm5zIHtUeXBlfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYG9iamVjdGAgaXMgbm90IGEgbWVtYmVyIG9mIHRoaXMgdHlwZVxuICovXG5UeXBlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkICYmIG9iamVjdC5leHRlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBTZWUgVHlwZSNhZGQgZm9yIHRoZSByZWFzb24gd2h5IGV4dGVuc2lvbiBmaWVsZHMgYXJlIGV4Y2x1ZGVkIGhlcmUuXG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdGhpcy5maWVsZHMgfHwgdGhpcy5maWVsZHNbb2JqZWN0Lm5hbWVdICE9PSBvYmplY3QpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihvYmplY3QgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcblxuICAgICAgICBkZWxldGUgdGhpcy5maWVsZHNbb2JqZWN0Lm5hbWVdO1xuICAgICAgICBvYmplY3QucGFyZW50ID0gbnVsbDtcbiAgICAgICAgb2JqZWN0Lm9uUmVtb3ZlKHRoaXMpO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE9uZU9mKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdGhpcy5vbmVvZnMgfHwgdGhpcy5vbmVvZnNbb2JqZWN0Lm5hbWVdICE9PSBvYmplY3QpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihvYmplY3QgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcblxuICAgICAgICBkZWxldGUgdGhpcy5vbmVvZnNbb2JqZWN0Lm5hbWVdO1xuICAgICAgICBvYmplY3QucGFyZW50ID0gbnVsbDtcbiAgICAgICAgb2JqZWN0Lm9uUmVtb3ZlKHRoaXMpO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcywgb2JqZWN0KTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBpZCBpcyByZXNlcnZlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBJZCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG5UeXBlLnByb3RvdHlwZS5pc1Jlc2VydmVkSWQgPSBmdW5jdGlvbiBpc1Jlc2VydmVkSWQoaWQpIHtcbiAgICByZXR1cm4gTmFtZXNwYWNlLmlzUmVzZXJ2ZWRJZCh0aGlzLnJlc2VydmVkLCBpZCk7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgbmFtZSBpcyByZXNlcnZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuVHlwZS5wcm90b3R5cGUuaXNSZXNlcnZlZE5hbWUgPSBmdW5jdGlvbiBpc1Jlc2VydmVkTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5pc1Jlc2VydmVkTmFtZSh0aGlzLnJlc2VydmVkLCBuYW1lKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtZXNzYWdlIG9mIHRoaXMgdHlwZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAqIEByZXR1cm5zIHtNZXNzYWdlPHt9Pn0gTWVzc2FnZSBpbnN0YW5jZVxuICovXG5UeXBlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgIHJldHVybiBuZXcgdGhpcy5jdG9yKHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBTZXRzIHVwIHtAbGluayBUeXBlI2VuY29kZXxlbmNvZGV9LCB7QGxpbmsgVHlwZSNkZWNvZGV8ZGVjb2RlfSBhbmQge0BsaW5rIFR5cGUjdmVyaWZ5fHZlcmlmeX0uXG4gKiBAcmV0dXJucyB7VHlwZX0gYHRoaXNgXG4gKi9cblR5cGUucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgLy8gU2V0cyB1cCBldmVyeXRoaW5nIGF0IG9uY2Ugc28gdGhhdCB0aGUgcHJvdG90eXBlIGNoYWluIGRvZXMgbm90IGhhdmUgdG8gYmUgcmUtZXZhbHVhdGVkXG4gICAgLy8gbXVsdGlwbGUgdGltZXMgKFY4LCBzb2Z0LWRlb3B0IHByb3RvdHlwZS1jaGVjaykuXG5cbiAgICB2YXIgZnVsbE5hbWUgPSB0aGlzLmZ1bGxOYW1lLFxuICAgICAgICB0eXBlcyAgICA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gdGhpcy5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgdHlwZXMucHVzaCh0aGlzLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlKCkucmVzb2x2ZWRUeXBlKTtcblxuICAgIC8vIFJlcGxhY2Ugc2V0dXAgbWV0aG9kcyB3aXRoIHR5cGUtc3BlY2lmaWMgZ2VuZXJhdGVkIGZ1bmN0aW9uc1xuICAgIHRoaXMuZW5jb2RlID0gZW5jb2Rlcih0aGlzKSh7XG4gICAgICAgIFdyaXRlciA6IFdyaXRlcixcbiAgICAgICAgdHlwZXMgIDogdHlwZXMsXG4gICAgICAgIHV0aWwgICA6IHV0aWxcbiAgICB9KTtcbiAgICB0aGlzLmRlY29kZSA9IGRlY29kZXIodGhpcykoe1xuICAgICAgICBSZWFkZXIgOiBSZWFkZXIsXG4gICAgICAgIHR5cGVzICA6IHR5cGVzLFxuICAgICAgICB1dGlsICAgOiB1dGlsXG4gICAgfSk7XG4gICAgdGhpcy52ZXJpZnkgPSB2ZXJpZmllcih0aGlzKSh7XG4gICAgICAgIHR5cGVzIDogdHlwZXMsXG4gICAgICAgIHV0aWwgIDogdXRpbFxuICAgIH0pO1xuICAgIHRoaXMuZnJvbU9iamVjdCA9IGNvbnZlcnRlci5mcm9tT2JqZWN0KHRoaXMpKHtcbiAgICAgICAgdHlwZXMgOiB0eXBlcyxcbiAgICAgICAgdXRpbCAgOiB1dGlsXG4gICAgfSk7XG4gICAgdGhpcy50b09iamVjdCA9IGNvbnZlcnRlci50b09iamVjdCh0aGlzKSh7XG4gICAgICAgIHR5cGVzIDogdHlwZXMsXG4gICAgICAgIHV0aWwgIDogdXRpbFxuICAgIH0pO1xuXG4gICAgLy8gSW5qZWN0IGN1c3RvbSB3cmFwcGVycyBmb3IgY29tbW9uIHR5cGVzXG4gICAgdmFyIHdyYXBwZXIgPSB3cmFwcGVyc1tmdWxsTmFtZV07XG4gICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsVGhpcyA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgICAgIC8vIGlmICh3cmFwcGVyLmZyb21PYmplY3QpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsVGhpcy5mcm9tT2JqZWN0ID0gdGhpcy5mcm9tT2JqZWN0O1xuICAgICAgICAgICAgdGhpcy5mcm9tT2JqZWN0ID0gd3JhcHBlci5mcm9tT2JqZWN0LmJpbmQob3JpZ2luYWxUaGlzKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZiAod3JhcHBlci50b09iamVjdCkge1xuICAgICAgICAgICAgb3JpZ2luYWxUaGlzLnRvT2JqZWN0ID0gdGhpcy50b09iamVjdDtcbiAgICAgICAgICAgIHRoaXMudG9PYmplY3QgPSB3cmFwcGVyLnRvT2JqZWN0LmJpbmQob3JpZ2luYWxUaGlzKTtcbiAgICAgICAgLy8gfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIFR5cGUjdmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gKiBAcGFyYW0ge01lc3NhZ2U8e30+fE9iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIE1lc3NhZ2UgaW5zdGFuY2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge1dyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICogQHJldHVybnMge1dyaXRlcn0gd3JpdGVyXG4gKi9cblR5cGUucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZV9zZXR1cChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpOyAvLyBvdmVycmlkZXMgdGhpcyBtZXRob2Rcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIFR5cGUjdmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gKiBAcGFyYW0ge01lc3NhZ2U8e30+fE9iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIE1lc3NhZ2UgaW5zdGFuY2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge1dyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICogQHJldHVybnMge1dyaXRlcn0gd3JpdGVyXG4gKi9cblR5cGUucHJvdG90eXBlLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyICYmIHdyaXRlci5sZW4gPyB3cml0ZXIuZm9yaygpIDogd3JpdGVyKS5sZGVsaW0oKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLlxuICogQHBhcmFtIHtSZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggb2YgdGhlIG1lc3NhZ2UsIGlmIGtub3duIGJlZm9yZWhhbmRcbiAqIEByZXR1cm5zIHtNZXNzYWdlPHt9Pn0gRGVjb2RlZCBtZXNzYWdlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICogQHRocm93cyB7dXRpbC5Qcm90b2NvbEVycm9yPHt9Pn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKi9cblR5cGUucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZV9zZXR1cChyZWFkZXIsIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnNldHVwKCkuZGVjb2RlKHJlYWRlciwgbGVuZ3RoKTsgLy8gb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZSBwcmVjZWVkZWQgYnkgaXRzIGJ5dGUgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtSZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAqIEByZXR1cm5zIHtNZXNzYWdlPHt9Pn0gRGVjb2RlZCBtZXNzYWdlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICogQHRocm93cyB7dXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAqL1xuVHlwZS5wcm90b3R5cGUuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mIFJlYWRlcikpXG4gICAgICAgIHJlYWRlciA9IFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IGZpZWxkIHZhbHVlcyBhcmUgdmFsaWQgYW5kIHRoYXQgcmVxdWlyZWQgZmllbGRzIGFyZSBwcmVzZW50LlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gKiBAcmV0dXJucyB7bnVsbHxzdHJpbmd9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICovXG5UeXBlLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnlfc2V0dXAobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldHVwKCkudmVyaWZ5KG1lc3NhZ2UpOyAvLyBvdmVycmlkZXMgdGhpcyBtZXRob2Rcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtZXNzYWdlIG9mIHRoaXMgdHlwZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdCB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IE1lc3NhZ2UgaW5zdGFuY2VcbiAqL1xuVHlwZS5wcm90b3R5cGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dXAoKS5mcm9tT2JqZWN0KG9iamVjdCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnNpb24gb3B0aW9ucyBhcyB1c2VkIGJ5IHtAbGluayBUeXBlI3RvT2JqZWN0fSBhbmQge0BsaW5rIE1lc3NhZ2UudG9PYmplY3R9LlxuICogQGludGVyZmFjZSBJQ29udmVyc2lvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtsb25nc10gTG9uZyBjb252ZXJzaW9uIHR5cGUuXG4gKiBWYWxpZCB2YWx1ZXMgYXJlIGBTdHJpbmdgIGFuZCBgTnVtYmVyYCAodGhlIGdsb2JhbCB0eXBlcykuXG4gKiBEZWZhdWx0cyB0byBjb3B5IHRoZSBwcmVzZW50IHZhbHVlLCB3aGljaCBpcyBhIHBvc3NpYmx5IHVuc2FmZSBudW1iZXIgd2l0aG91dCBhbmQgYSB7QGxpbmsgTG9uZ30gd2l0aCBhIGxvbmcgbGlicmFyeS5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtlbnVtc10gRW51bSB2YWx1ZSBjb252ZXJzaW9uIHR5cGUuXG4gKiBPbmx5IHZhbGlkIHZhbHVlIGlzIGBTdHJpbmdgICh0aGUgZ2xvYmFsIHR5cGUpLlxuICogRGVmYXVsdHMgdG8gY29weSB0aGUgcHJlc2VudCB2YWx1ZSwgd2hpY2ggaXMgdGhlIG51bWVyaWMgaWQuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbYnl0ZXNdIEJ5dGVzIHZhbHVlIGNvbnZlcnNpb24gdHlwZS5cbiAqIFZhbGlkIHZhbHVlcyBhcmUgYEFycmF5YCBhbmQgKGEgYmFzZTY0IGVuY29kZWQpIGBTdHJpbmdgICh0aGUgZ2xvYmFsIHR5cGVzKS5cbiAqIERlZmF1bHRzIHRvIGNvcHkgdGhlIHByZXNlbnQgdmFsdWUsIHdoaWNoIHVzdWFsbHkgaXMgYSBCdWZmZXIgdW5kZXIgbm9kZSBhbmQgYW4gVWludDhBcnJheSBpbiB0aGUgYnJvd3Nlci5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlZmF1bHRzPWZhbHNlXSBBbHNvIHNldHMgZGVmYXVsdCB2YWx1ZXMgb24gdGhlIHJlc3VsdGluZyBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FycmF5cz1mYWxzZV0gU2V0cyBlbXB0eSBhcnJheXMgZm9yIG1pc3NpbmcgcmVwZWF0ZWQgZmllbGRzIGV2ZW4gaWYgYGRlZmF1bHRzPWZhbHNlYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbb2JqZWN0cz1mYWxzZV0gU2V0cyBlbXB0eSBvYmplY3RzIGZvciBtaXNzaW5nIG1hcCBmaWVsZHMgZXZlbiBpZiBgZGVmYXVsdHM9ZmFsc2VgXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvbmVvZnM9ZmFsc2VdIEluY2x1ZGVzIHZpcnR1YWwgb25lb2YgcHJvcGVydGllcyBzZXQgdG8gdGhlIHByZXNlbnQgZmllbGQncyBuYW1lLCBpZiBhbnlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2pzb249ZmFsc2VdIFBlcmZvcm1zIGFkZGl0aW9uYWwgSlNPTiBjb21wYXRpYmlsaXR5IGNvbnZlcnNpb25zLCBpLmUuIE5hTiBhbmQgSW5maW5pdHkgdG8gc3RyaW5nc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7TWVzc2FnZTx7fT59IG1lc3NhZ2UgTWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtJQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gKi9cblR5cGUucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldHVwKCkudG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERlY29yYXRvciBmdW5jdGlvbiBhcyByZXR1cm5lZCBieSB7QGxpbmsgVHlwZS5kfSAoVHlwZVNjcmlwdCkuXG4gKiBAdHlwZWRlZiBUeXBlRGVjb3JhdG9yXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFQ+fSB0YXJnZXQgVGFyZ2V0IGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKi9cblxuLyoqXG4gKiBUeXBlIGRlY29yYXRvciAoVHlwZVNjcmlwdCkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVOYW1lXSBUeXBlIG5hbWUsIGRlZmF1bHRzIHRvIHRoZSBjb25zdHJ1Y3RvcidzIG5hbWVcbiAqIEByZXR1cm5zIHtUeXBlRGVjb3JhdG9yPFQ+fSBEZWNvcmF0b3IgZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICovXG5UeXBlLmQgPSBmdW5jdGlvbiBkZWNvcmF0ZVR5cGUodHlwZU5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdHlwZURlY29yYXRvcih0YXJnZXQpIHtcbiAgICAgICAgdXRpbC5kZWNvcmF0ZVR5cGUodGFyZ2V0LCB0eXBlTmFtZSk7XG4gICAgfTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIlR5cGUiLCJOYW1lc3BhY2UiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJjbGFzc05hbWUiLCJFbnVtIiwiT25lT2YiLCJGaWVsZCIsIk1hcEZpZWxkIiwiU2VydmljZSIsIk1lc3NhZ2UiLCJSZWFkZXIiLCJXcml0ZXIiLCJ1dGlsIiwiZW5jb2RlciIsImRlY29kZXIiLCJ2ZXJpZmllciIsImNvbnZlcnRlciIsIndyYXBwZXJzIiwibmFtZSIsIm9wdGlvbnMiLCJjYWxsIiwiZmllbGRzIiwib25lb2ZzIiwidW5kZWZpbmVkIiwiZXh0ZW5zaW9ucyIsInJlc2VydmVkIiwiZ3JvdXAiLCJfZmllbGRzQnlJZCIsIl9maWVsZHNBcnJheSIsIl9vbmVvZnNBcnJheSIsIl9jdG9yIiwiZGVmaW5lUHJvcGVydGllcyIsImZpZWxkc0J5SWQiLCJnZXQiLCJuYW1lcyIsImtleXMiLCJpIiwibGVuZ3RoIiwiZmllbGQiLCJpZCIsIkVycm9yIiwiZmllbGRzQXJyYXkiLCJ0b0FycmF5Iiwib25lb2ZzQXJyYXkiLCJjdG9yIiwiZ2VuZXJhdGVDb25zdHJ1Y3RvciIsInNldCIsIm1lcmdlIiwiJHR5cGUiLCJyZXNvbHZlIiwiY3RvclByb3BlcnRpZXMiLCJvbmVPZkdldHRlciIsIm9uZW9mIiwib25lT2ZTZXR0ZXIiLCJtdHlwZSIsImdlbiIsImNvZGVnZW4iLCJtYXAiLCJzYWZlUHJvcCIsInJlcGVhdGVkIiwiY2xlYXJDYWNoZSIsInR5cGUiLCJlbmNvZGUiLCJkZWNvZGUiLCJ2ZXJpZnkiLCJmcm9tSlNPTiIsImpzb24iLCJhZGQiLCJrZXlUeXBlIiwibmVzdGVkIiwidmFsdWVzIiwibWV0aG9kcyIsImNvbW1lbnQiLCJ0b0pTT04iLCJ0b0pTT05PcHRpb25zIiwiaW5oZXJpdGVkIiwia2VlcENvbW1lbnRzIiwiQm9vbGVhbiIsInRvT2JqZWN0IiwiYXJyYXlUb0pTT04iLCJmaWx0ZXIiLCJvYmoiLCJkZWNsYXJpbmdGaWVsZCIsInJlc29sdmVBbGwiLCJvYmplY3QiLCJleHRlbmQiLCJpc1Jlc2VydmVkSWQiLCJpc1Jlc2VydmVkTmFtZSIsInBhcmVudCIsInJlbW92ZSIsIm1lc3NhZ2UiLCJvbkFkZCIsIm9uUmVtb3ZlIiwicHJvcGVydGllcyIsInNldHVwIiwiZnVsbE5hbWUiLCJ0eXBlcyIsInB1c2giLCJyZXNvbHZlZFR5cGUiLCJmcm9tT2JqZWN0Iiwid3JhcHBlciIsIm9yaWdpbmFsVGhpcyIsImJpbmQiLCJlbmNvZGVfc2V0dXAiLCJ3cml0ZXIiLCJlbmNvZGVEZWxpbWl0ZWQiLCJsZW4iLCJmb3JrIiwibGRlbGltIiwiZGVjb2RlX3NldHVwIiwicmVhZGVyIiwiZGVjb2RlRGVsaW1pdGVkIiwidWludDMyIiwidmVyaWZ5X3NldHVwIiwiZCIsImRlY29yYXRlVHlwZSIsInR5cGVOYW1lIiwidHlwZURlY29yYXRvciIsInRhcmdldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/type.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/types.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/types.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Common type constants.\n * @namespace\n */ var types = exports;\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\");\nvar s = [\n    \"double\",\n    \"float\",\n    \"int32\",\n    \"uint32\",\n    \"sint32\",\n    \"fixed32\",\n    \"sfixed32\",\n    \"int64\",\n    \"uint64\",\n    \"sint64\",\n    \"fixed64\",\n    \"sfixed64\",\n    \"bool\",\n    \"string\",\n    \"bytes\" // 14\n];\nfunction bake(values, offset) {\n    var i = 0, o = {};\n    offset |= 0;\n    while(i < values.length)o[s[i + offset]] = values[i++];\n    return o;\n}\n/**\n * Basic type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n * @property {number} bytes=2 Ldelim wire type\n */ types.basic = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2,\n    /* bytes    */ 2\n]);\n/**\n * Basic type defaults.\n * @type {Object.<string,*>}\n * @const\n * @property {number} double=0 Double default\n * @property {number} float=0 Float default\n * @property {number} int32=0 Int32 default\n * @property {number} uint32=0 Uint32 default\n * @property {number} sint32=0 Sint32 default\n * @property {number} fixed32=0 Fixed32 default\n * @property {number} sfixed32=0 Sfixed32 default\n * @property {number} int64=0 Int64 default\n * @property {number} uint64=0 Uint64 default\n * @property {number} sint64=0 Sint32 default\n * @property {number} fixed64=0 Fixed64 default\n * @property {number} sfixed64=0 Sfixed64 default\n * @property {boolean} bool=false Bool default\n * @property {string} string=\"\" String default\n * @property {Array.<number>} bytes=Array(0) Bytes default\n * @property {null} message=null Message default\n */ types.defaults = bake([\n    /* double   */ 0,\n    /* float    */ 0,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 0,\n    /* sfixed32 */ 0,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 0,\n    /* sfixed64 */ 0,\n    /* bool     */ false,\n    /* string   */ \"\",\n    /* bytes    */ util.emptyArray,\n    /* message  */ null\n]);\n/**\n * Basic long type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n */ types.long = bake([\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1\n], 7);\n/**\n * Allowed types for map keys with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n */ types.mapKey = bake([\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2\n], 2);\n/**\n * Allowed types for packed repeated fields with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n */ types.packed = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYjs7O0NBR0MsR0FDRCxJQUFJQSxRQUFRQztBQUVaLElBQUlDLE9BQU9DLG1CQUFPQSxDQUFDLDJEQUFRO0FBRTNCLElBQUlDLElBQUk7SUFDSjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsUUFBWSxLQUFLO0NBQ3BCO0FBRUQsU0FBU0MsS0FBS0MsTUFBTSxFQUFFQyxNQUFNO0lBQ3hCLElBQUlDLElBQUksR0FBR0MsSUFBSSxDQUFDO0lBQ2hCRixVQUFVO0lBQ1YsTUFBT0MsSUFBSUYsT0FBT0ksTUFBTSxDQUFFRCxDQUFDLENBQUNMLENBQUMsQ0FBQ0ksSUFBSUQsT0FBTyxDQUFDLEdBQUdELE1BQU0sQ0FBQ0UsSUFBSTtJQUN4RCxPQUFPQztBQUNYO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDRFQsTUFBTVcsS0FBSyxHQUFHTixLQUFLO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0NBQ2xCO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBQ0RMLE1BQU1ZLFFBQVEsR0FBR1AsS0FBSztJQUNsQixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUdILEtBQUtXLFVBQVU7SUFDOUIsWUFBWSxHQUFHO0NBQ2xCO0FBRUQ7Ozs7Ozs7OztDQVNDLEdBQ0RiLE1BQU1jLElBQUksR0FBR1QsS0FBSztJQUNkLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztDQUNsQixFQUFFO0FBRUg7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDREwsTUFBTWUsTUFBTSxHQUFHVixLQUFLO0lBQ2hCLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztDQUNsQixFQUFFO0FBRUg7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ0RMLE1BQU1nQixNQUFNLEdBQUdYLEtBQUs7SUFDaEIsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0NBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy90eXBlcy5qcz85NmFhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvbW1vbiB0eXBlIGNvbnN0YW50cy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHR5cGVzID0gZXhwb3J0cztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgcyA9IFtcbiAgICBcImRvdWJsZVwiLCAgIC8vIDBcbiAgICBcImZsb2F0XCIsICAgIC8vIDFcbiAgICBcImludDMyXCIsICAgIC8vIDJcbiAgICBcInVpbnQzMlwiLCAgIC8vIDNcbiAgICBcInNpbnQzMlwiLCAgIC8vIDRcbiAgICBcImZpeGVkMzJcIiwgIC8vIDVcbiAgICBcInNmaXhlZDMyXCIsIC8vIDZcbiAgICBcImludDY0XCIsICAgIC8vIDdcbiAgICBcInVpbnQ2NFwiLCAgIC8vIDhcbiAgICBcInNpbnQ2NFwiLCAgIC8vIDlcbiAgICBcImZpeGVkNjRcIiwgIC8vIDEwXG4gICAgXCJzZml4ZWQ2NFwiLCAvLyAxMVxuICAgIFwiYm9vbFwiLCAgICAgLy8gMTJcbiAgICBcInN0cmluZ1wiLCAgIC8vIDEzXG4gICAgXCJieXRlc1wiICAgICAvLyAxNFxuXTtcblxuZnVuY3Rpb24gYmFrZSh2YWx1ZXMsIG9mZnNldCkge1xuICAgIHZhciBpID0gMCwgbyA9IHt9O1xuICAgIG9mZnNldCB8PSAwO1xuICAgIHdoaWxlIChpIDwgdmFsdWVzLmxlbmd0aCkgb1tzW2kgKyBvZmZzZXRdXSA9IHZhbHVlc1tpKytdO1xuICAgIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEJhc2ljIHR5cGUgd2lyZSB0eXBlcy5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxuICogQGNvbnN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZG91YmxlPTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmbG9hdD01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gYm9vbD0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdHJpbmc9MiBMZGVsaW0gd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnl0ZXM9MiBMZGVsaW0gd2lyZSB0eXBlXG4gKi9cbnR5cGVzLmJhc2ljID0gYmFrZShbXG4gICAgLyogZG91YmxlICAgKi8gMSxcbiAgICAvKiBmbG9hdCAgICAqLyA1LFxuICAgIC8qIGludDMyICAgICovIDAsXG4gICAgLyogdWludDMyICAgKi8gMCxcbiAgICAvKiBzaW50MzIgICAqLyAwLFxuICAgIC8qIGZpeGVkMzIgICovIDUsXG4gICAgLyogc2ZpeGVkMzIgKi8gNSxcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxuICAgIC8qIHVpbnQ2NCAgICovIDAsXG4gICAgLyogc2ludDY0ICAgKi8gMCxcbiAgICAvKiBmaXhlZDY0ICAqLyAxLFxuICAgIC8qIHNmaXhlZDY0ICovIDEsXG4gICAgLyogYm9vbCAgICAgKi8gMCxcbiAgICAvKiBzdHJpbmcgICAqLyAyLFxuICAgIC8qIGJ5dGVzICAgICovIDJcbl0pO1xuXG4vKipcbiAqIEJhc2ljIHR5cGUgZGVmYXVsdHMuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb3VibGU9MCBEb3VibGUgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZsb2F0PTAgRmxvYXQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDMyPTAgSW50MzIgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQzMj0wIFVpbnQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgU2ludDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDMyPTAgRml4ZWQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkMzI9MCBTZml4ZWQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBJbnQ2NCBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVWludDY0IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50NjQ9MCBTaW50MzIgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MCBGaXhlZDY0IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0wIFNmaXhlZDY0IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYm9vbD1mYWxzZSBCb29sIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHJpbmc9XCJcIiBTdHJpbmcgZGVmYXVsdFxuICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPn0gYnl0ZXM9QXJyYXkoMCkgQnl0ZXMgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudWxsfSBtZXNzYWdlPW51bGwgTWVzc2FnZSBkZWZhdWx0XG4gKi9cbnR5cGVzLmRlZmF1bHRzID0gYmFrZShbXG4gICAgLyogZG91YmxlICAgKi8gMCxcbiAgICAvKiBmbG9hdCAgICAqLyAwLFxuICAgIC8qIGludDMyICAgICovIDAsXG4gICAgLyogdWludDMyICAgKi8gMCxcbiAgICAvKiBzaW50MzIgICAqLyAwLFxuICAgIC8qIGZpeGVkMzIgICovIDAsXG4gICAgLyogc2ZpeGVkMzIgKi8gMCxcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxuICAgIC8qIHVpbnQ2NCAgICovIDAsXG4gICAgLyogc2ludDY0ICAgKi8gMCxcbiAgICAvKiBmaXhlZDY0ICAqLyAwLFxuICAgIC8qIHNmaXhlZDY0ICovIDAsXG4gICAgLyogYm9vbCAgICAgKi8gZmFsc2UsXG4gICAgLyogc3RyaW5nICAgKi8gXCJcIixcbiAgICAvKiBieXRlcyAgICAqLyB1dGlsLmVtcHR5QXJyYXksXG4gICAgLyogbWVzc2FnZSAgKi8gbnVsbFxuXSk7XG5cbi8qKlxuICogQmFzaWMgbG9uZyB0eXBlIHdpcmUgdHlwZXMuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cbiAqIEBjb25zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICovXG50eXBlcy5sb25nID0gYmFrZShbXG4gICAgLyogaW50NjQgICAgKi8gMCxcbiAgICAvKiB1aW50NjQgICAqLyAwLFxuICAgIC8qIHNpbnQ2NCAgICovIDAsXG4gICAgLyogZml4ZWQ2NCAgKi8gMSxcbiAgICAvKiBzZml4ZWQ2NCAqLyAxXG5dLCA3KTtcblxuLyoqXG4gKiBBbGxvd2VkIHR5cGVzIGZvciBtYXAga2V5cyB3aXRoIHRoZWlyIGFzc29jaWF0ZWQgd2lyZSB0eXBlLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib29sPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0cmluZz0yIExkZWxpbSB3aXJlIHR5cGVcbiAqL1xudHlwZXMubWFwS2V5ID0gYmFrZShbXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gNSxcbiAgICAvKiBzZml4ZWQzMiAqLyA1LFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDEsXG4gICAgLyogc2ZpeGVkNjQgKi8gMSxcbiAgICAvKiBib29sICAgICAqLyAwLFxuICAgIC8qIHN0cmluZyAgICovIDJcbl0sIDIpO1xuXG4vKipcbiAqIEFsbG93ZWQgdHlwZXMgZm9yIHBhY2tlZCByZXBlYXRlZCBmaWVsZHMgd2l0aCB0aGVpciBhc3NvY2lhdGVkIHdpcmUgdHlwZS5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxuICogQGNvbnN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZG91YmxlPTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmbG9hdD01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gYm9vbD0wIFZhcmludCB3aXJlIHR5cGVcbiAqL1xudHlwZXMucGFja2VkID0gYmFrZShbXG4gICAgLyogZG91YmxlICAgKi8gMSxcbiAgICAvKiBmbG9hdCAgICAqLyA1LFxuICAgIC8qIGludDMyICAgICovIDAsXG4gICAgLyogdWludDMyICAgKi8gMCxcbiAgICAvKiBzaW50MzIgICAqLyAwLFxuICAgIC8qIGZpeGVkMzIgICovIDUsXG4gICAgLyogc2ZpeGVkMzIgKi8gNSxcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxuICAgIC8qIHVpbnQ2NCAgICovIDAsXG4gICAgLyogc2ludDY0ICAgKi8gMCxcbiAgICAvKiBmaXhlZDY0ICAqLyAxLFxuICAgIC8qIHNmaXhlZDY0ICovIDEsXG4gICAgLyogYm9vbCAgICAgKi8gMFxuXSk7XG4iXSwibmFtZXMiOlsidHlwZXMiLCJleHBvcnRzIiwidXRpbCIsInJlcXVpcmUiLCJzIiwiYmFrZSIsInZhbHVlcyIsIm9mZnNldCIsImkiLCJvIiwibGVuZ3RoIiwiYmFzaWMiLCJkZWZhdWx0cyIsImVtcHR5QXJyYXkiLCJsb25nIiwibWFwS2V5IiwicGFja2VkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/util.js":
/*!*********************************************!*\
  !*** ./node_modules/protobufjs/src/util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Various utility functions.\n * @namespace\n */ var util = module.exports = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/protobufjs/src/util/minimal.js\");\nvar roots = __webpack_require__(/*! ./roots */ \"(ssr)/./node_modules/protobufjs/src/roots.js\");\nvar Type, Enum;\nutil.codegen = __webpack_require__(/*! @protobufjs/codegen */ \"(ssr)/./node_modules/@protobufjs/codegen/index.js\");\nutil.fetch = __webpack_require__(/*! @protobufjs/fetch */ \"(ssr)/./node_modules/@protobufjs/fetch/index.js\");\nutil.path = __webpack_require__(/*! @protobufjs/path */ \"(ssr)/./node_modules/@protobufjs/path/index.js\");\n/**\n * Node's fs module if available.\n * @type {Object.<string,*>}\n */ util.fs = util.inquire(\"fs\");\n/**\n * Converts an object's values to an array.\n * @param {Object.<string,*>} object Object to convert\n * @returns {Array.<*>} Converted array\n */ util.toArray = function toArray(object) {\n    if (object) {\n        var keys = Object.keys(object), array = new Array(keys.length), index = 0;\n        while(index < keys.length)array[index] = object[keys[index++]];\n        return array;\n    }\n    return [];\n};\n/**\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n * @param {Array.<*>} array Array to convert\n * @returns {Object.<string,*>} Converted object\n */ util.toObject = function toObject(array) {\n    var object = {}, index = 0;\n    while(index < array.length){\n        var key = array[index++], val = array[index++];\n        if (val !== undefined) object[key] = val;\n    }\n    return object;\n};\nvar safePropBackslashRe = /\\\\/g, safePropQuoteRe = /\"/g;\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ util.isReserved = function isReserved(name) {\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n/**\n * Returns a safe property accessor for the specified property name.\n * @param {string} prop Property name\n * @returns {string} Safe accessor\n */ util.safeProp = function safeProp(prop) {\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop)) return '[\"' + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, '\\\\\"') + '\"]';\n    return \".\" + prop;\n};\n/**\n * Converts the first character of a string to upper case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */ util.ucFirst = function ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\nvar camelCaseRe = /_([a-z])/g;\n/**\n * Converts a string to camel case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */ util.camelCase = function camelCase(str) {\n    return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {\n        return $1.toUpperCase();\n    });\n};\n/**\n * Compares reflected fields by id.\n * @param {Field} a First field\n * @param {Field} b Second field\n * @returns {number} Comparison value\n */ util.compareFieldsById = function compareFieldsById(a, b) {\n    return a.id - b.id;\n};\n/**\n * Decorator helper for types (TypeScript).\n * @param {Constructor<T>} ctor Constructor function\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {Type} Reflected type\n * @template T extends Message<T>\n * @property {Root} root Decorators root\n */ util.decorateType = function decorateType(ctor, typeName) {\n    /* istanbul ignore if */ if (ctor.$type) {\n        if (typeName && ctor.$type.name !== typeName) {\n            util.decorateRoot.remove(ctor.$type);\n            ctor.$type.name = typeName;\n            util.decorateRoot.add(ctor.$type);\n        }\n        return ctor.$type;\n    }\n    /* istanbul ignore next */ if (!Type) Type = __webpack_require__(/*! ./type */ \"(ssr)/./node_modules/protobufjs/src/type.js\");\n    var type = new Type(typeName || ctor.name);\n    util.decorateRoot.add(type);\n    type.ctor = ctor; // sets up .encode, .decode etc.\n    Object.defineProperty(ctor, \"$type\", {\n        value: type,\n        enumerable: false\n    });\n    Object.defineProperty(ctor.prototype, \"$type\", {\n        value: type,\n        enumerable: false\n    });\n    return type;\n};\nvar decorateEnumIndex = 0;\n/**\n * Decorator helper for enums (TypeScript).\n * @param {Object} object Enum object\n * @returns {Enum} Reflected enum\n */ util.decorateEnum = function decorateEnum(object) {\n    /* istanbul ignore if */ if (object.$type) return object.$type;\n    /* istanbul ignore next */ if (!Enum) Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/protobufjs/src/enum.js\");\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n    util.decorateRoot.add(enm);\n    Object.defineProperty(object, \"$type\", {\n        value: enm,\n        enumerable: false\n    });\n    return enm;\n};\n/**\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\n * @param {Object.<string,*>} dst Destination object\n * @param {string} path dot '.' delimited path of the property to set\n * @param {Object} value the value to set\n * @returns {Object.<string,*>} Destination object\n */ util.setProperty = function setProperty(dst, path, value) {\n    function setProp(dst, path, value) {\n        var part = path.shift();\n        if (part === \"__proto__\" || part === \"prototype\") {\n            return dst;\n        }\n        if (path.length > 0) {\n            dst[part] = setProp(dst[part] || {}, path, value);\n        } else {\n            var prevValue = dst[part];\n            if (prevValue) value = [].concat(prevValue).concat(value);\n            dst[part] = value;\n        }\n        return dst;\n    }\n    if (typeof dst !== \"object\") throw TypeError(\"dst must be an object\");\n    if (!path) throw TypeError(\"path must be specified\");\n    path = path.split(\".\");\n    return setProp(dst, path, value);\n};\n/**\n * Decorator root (TypeScript).\n * @name util.decorateRoot\n * @type {Root}\n * @readonly\n */ Object.defineProperty(util, \"decorateRoot\", {\n    get: function() {\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (__webpack_require__(/*! ./root */ \"(ssr)/./node_modules/protobufjs/src/root.js\"))());\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViOzs7Q0FHQyxHQUNELElBQUlBLE9BQU9DLGlIQUEwQztBQUVyRCxJQUFJRyxRQUFRRCxtQkFBT0EsQ0FBQyw2REFBUztBQUU3QixJQUFJRSxNQUNBQztBQUVKTixLQUFLTyxPQUFPLEdBQUdKLG1CQUFPQSxDQUFDLDhFQUFxQjtBQUM1Q0gsS0FBS1EsS0FBSyxHQUFLTCxtQkFBT0EsQ0FBQywwRUFBbUI7QUFDMUNILEtBQUtTLElBQUksR0FBTU4sbUJBQU9BLENBQUMsd0VBQWtCO0FBRXpDOzs7Q0FHQyxHQUNESCxLQUFLVSxFQUFFLEdBQUdWLEtBQUtXLE9BQU8sQ0FBQztBQUV2Qjs7OztDQUlDLEdBQ0RYLEtBQUtZLE9BQU8sR0FBRyxTQUFTQSxRQUFRQyxNQUFNO0lBQ2xDLElBQUlBLFFBQVE7UUFDUixJQUFJQyxPQUFRQyxPQUFPRCxJQUFJLENBQUNELFNBQ3BCRyxRQUFRLElBQUlDLE1BQU1ILEtBQUtJLE1BQU0sR0FDN0JDLFFBQVE7UUFDWixNQUFPQSxRQUFRTCxLQUFLSSxNQUFNLENBQ3RCRixLQUFLLENBQUNHLE1BQU0sR0FBR04sTUFBTSxDQUFDQyxJQUFJLENBQUNLLFFBQVEsQ0FBQztRQUN4QyxPQUFPSDtJQUNYO0lBQ0EsT0FBTyxFQUFFO0FBQ2I7QUFFQTs7OztDQUlDLEdBQ0RoQixLQUFLb0IsUUFBUSxHQUFHLFNBQVNBLFNBQVNKLEtBQUs7SUFDbkMsSUFBSUgsU0FBUyxDQUFDLEdBQ1ZNLFFBQVM7SUFDYixNQUFPQSxRQUFRSCxNQUFNRSxNQUFNLENBQUU7UUFDekIsSUFBSUcsTUFBTUwsS0FBSyxDQUFDRyxRQUFRLEVBQ3BCRyxNQUFNTixLQUFLLENBQUNHLFFBQVE7UUFDeEIsSUFBSUcsUUFBUUMsV0FDUlYsTUFBTSxDQUFDUSxJQUFJLEdBQUdDO0lBQ3RCO0lBQ0EsT0FBT1Q7QUFDWDtBQUVBLElBQUlXLHNCQUFzQixP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S0FBSzRELFdBQVcsR0FBRyxTQUFTQSxZQUFZQyxHQUFHLEVBQUVwRCxJQUFJLEVBQUU2QyxLQUFLO0lBQ3BELFNBQVNRLFFBQVFELEdBQUcsRUFBRXBELElBQUksRUFBRTZDLEtBQUs7UUFDN0IsSUFBSVMsT0FBT3RELEtBQUt1RCxLQUFLO1FBQ3JCLElBQUlELFNBQVMsZUFBZUEsU0FBUyxhQUFhO1lBQ2hELE9BQU9GO1FBQ1Q7UUFDQSxJQUFJcEQsS0FBS1MsTUFBTSxHQUFHLEdBQUc7WUFDakIyQyxHQUFHLENBQUNFLEtBQUssR0FBR0QsUUFBUUQsR0FBRyxDQUFDRSxLQUFLLElBQUksQ0FBQyxHQUFHdEQsTUFBTTZDO1FBQy9DLE9BQU87WUFDSCxJQUFJVyxZQUFZSixHQUFHLENBQUNFLEtBQUs7WUFDekIsSUFBSUUsV0FDQVgsUUFBUSxFQUFFLENBQUNZLE1BQU0sQ0FBQ0QsV0FBV0MsTUFBTSxDQUFDWjtZQUN4Q08sR0FBRyxDQUFDRSxLQUFLLEdBQUdUO1FBQ2hCO1FBQ0EsT0FBT087SUFDWDtJQUVBLElBQUksT0FBT0EsUUFBUSxVQUNmLE1BQU1NLFVBQVU7SUFDcEIsSUFBSSxDQUFDMUQsTUFDRCxNQUFNMEQsVUFBVTtJQUVwQjFELE9BQU9BLEtBQUsyRCxLQUFLLENBQUM7SUFDbEIsT0FBT04sUUFBUUQsS0FBS3BELE1BQU02QztBQUM5QjtBQUVBOzs7OztDQUtDLEdBQ0R2QyxPQUFPc0MsY0FBYyxDQUFDckQsTUFBTSxnQkFBZ0I7SUFDeENxRSxLQUFLO1FBQ0QsT0FBT2pFLEtBQUssQ0FBQyxZQUFZLElBQUtBLENBQUFBLEtBQUssQ0FBQyxZQUFZLEdBQUcsSUFBS0QsQ0FBQUEsbUJBQU9BLENBQUMsMkRBQVEsSUFBRztJQUMvRTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsLmpzP2Q3YWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIHJvb3RzID0gcmVxdWlyZShcIi4vcm9vdHNcIik7XG5cbnZhciBUeXBlLCAvLyBjeWNsaWNcbiAgICBFbnVtO1xuXG51dGlsLmNvZGVnZW4gPSByZXF1aXJlKFwiQHByb3RvYnVmanMvY29kZWdlblwiKTtcbnV0aWwuZmV0Y2ggICA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9mZXRjaFwiKTtcbnV0aWwucGF0aCAgICA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wYXRoXCIpO1xuXG4vKipcbiAqIE5vZGUncyBmcyBtb2R1bGUgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxuICovXG51dGlsLmZzID0gdXRpbC5pbnF1aXJlKFwiZnNcIik7XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0J3MgdmFsdWVzIHRvIGFuIGFycmF5LlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IE9iamVjdCB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7QXJyYXkuPCo+fSBDb252ZXJ0ZWQgYXJyYXlcbiAqL1xudXRpbC50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheShvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIHZhciBrZXlzICA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICAgICAgICBhcnJheSA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGtleXMubGVuZ3RoKVxuICAgICAgICAgICAgYXJyYXlbaW5kZXhdID0gb2JqZWN0W2tleXNbaW5kZXgrK11dO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb2Yga2V5cyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGVpciByZXNwZWN0aXZlIHZhbHVlIHRvIGFuIG9iamVjdCwgb21pdHRpbmcgdW5kZWZpbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXkuPCo+fSBhcnJheSBBcnJheSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IENvbnZlcnRlZCBvYmplY3RcbiAqL1xudXRpbC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KGFycmF5KSB7XG4gICAgdmFyIG9iamVjdCA9IHt9LFxuICAgICAgICBpbmRleCAgPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gYXJyYXlbaW5kZXgrK10sXG4gICAgICAgICAgICB2YWwgPSBhcnJheVtpbmRleCsrXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG52YXIgc2FmZVByb3BCYWNrc2xhc2hSZSA9IC9cXFxcL2csXG4gICAgc2FmZVByb3BRdW90ZVJlICAgICA9IC9cIi9nO1xuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBuYW1lIGlzIGEgcmVzZXJ2ZWQgd29yZCBpbiBKUy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc1Jlc2VydmVkID0gZnVuY3Rpb24gaXNSZXNlcnZlZChuYW1lKSB7XG4gICAgcmV0dXJuIC9eKD86ZG98aWZ8aW58Zm9yfGxldHxuZXd8dHJ5fHZhcnxjYXNlfGVsc2V8ZW51bXxldmFsfGZhbHNlfG51bGx8dGhpc3x0cnVlfHZvaWR8d2l0aHxicmVha3xjYXRjaHxjbGFzc3xjb25zdHxzdXBlcnx0aHJvd3x3aGlsZXx5aWVsZHxkZWxldGV8ZXhwb3J0fGltcG9ydHxwdWJsaWN8cmV0dXJufHN0YXRpY3xzd2l0Y2h8dHlwZW9mfGRlZmF1bHR8ZXh0ZW5kc3xmaW5hbGx5fHBhY2thZ2V8cHJpdmF0ZXxjb250aW51ZXxkZWJ1Z2dlcnxmdW5jdGlvbnxhcmd1bWVudHN8aW50ZXJmYWNlfHByb3RlY3RlZHxpbXBsZW1lbnRzfGluc3RhbmNlb2YpJC8udGVzdChuYW1lKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHNhZmUgcHJvcGVydHkgYWNjZXNzb3IgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFNhZmUgYWNjZXNzb3JcbiAqL1xudXRpbC5zYWZlUHJvcCA9IGZ1bmN0aW9uIHNhZmVQcm9wKHByb3ApIHtcbiAgICBpZiAoIS9eWyRcXHdfXSskLy50ZXN0KHByb3ApIHx8IHV0aWwuaXNSZXNlcnZlZChwcm9wKSlcbiAgICAgICAgcmV0dXJuIFwiW1xcXCJcIiArIHByb3AucmVwbGFjZShzYWZlUHJvcEJhY2tzbGFzaFJlLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2Uoc2FmZVByb3BRdW90ZVJlLCBcIlxcXFxcXFwiXCIpICsgXCJcXFwiXVwiO1xuICAgIHJldHVybiBcIi5cIiArIHByb3A7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdG8gdXBwZXIgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcbiAqL1xudXRpbC51Y0ZpcnN0ID0gZnVuY3Rpb24gdWNGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn07XG5cbnZhciBjYW1lbENhc2VSZSA9IC9fKFthLXpdKS9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGNhbWVsIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwuY2FtZWxDYXNlID0gZnVuY3Rpb24gY2FtZWxDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDEpXG4gICAgICAgICArIHN0ci5zdWJzdHJpbmcoMSlcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKGNhbWVsQ2FzZVJlLCBmdW5jdGlvbigkMCwgJDEpIHsgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7IH0pO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyByZWZsZWN0ZWQgZmllbGRzIGJ5IGlkLlxuICogQHBhcmFtIHtGaWVsZH0gYSBGaXJzdCBmaWVsZFxuICogQHBhcmFtIHtGaWVsZH0gYiBTZWNvbmQgZmllbGRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IENvbXBhcmlzb24gdmFsdWVcbiAqL1xudXRpbC5jb21wYXJlRmllbGRzQnlJZCA9IGZ1bmN0aW9uIGNvbXBhcmVGaWVsZHNCeUlkKGEsIGIpIHtcbiAgICByZXR1cm4gYS5pZCAtIGIuaWQ7XG59O1xuXG4vKipcbiAqIERlY29yYXRvciBoZWxwZXIgZm9yIHR5cGVzIChUeXBlU2NyaXB0KS5cbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VD59IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZU5hbWVdIFR5cGUgbmFtZSwgZGVmYXVsdHMgdG8gdGhlIGNvbnN0cnVjdG9yJ3MgbmFtZVxuICogQHJldHVybnMge1R5cGV9IFJlZmxlY3RlZCB0eXBlXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEBwcm9wZXJ0eSB7Um9vdH0gcm9vdCBEZWNvcmF0b3JzIHJvb3RcbiAqL1xudXRpbC5kZWNvcmF0ZVR5cGUgPSBmdW5jdGlvbiBkZWNvcmF0ZVR5cGUoY3RvciwgdHlwZU5hbWUpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjdG9yLiR0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlTmFtZSAmJiBjdG9yLiR0eXBlLm5hbWUgIT09IHR5cGVOYW1lKSB7XG4gICAgICAgICAgICB1dGlsLmRlY29yYXRlUm9vdC5yZW1vdmUoY3Rvci4kdHlwZSk7XG4gICAgICAgICAgICBjdG9yLiR0eXBlLm5hbWUgPSB0eXBlTmFtZTtcbiAgICAgICAgICAgIHV0aWwuZGVjb3JhdGVSb290LmFkZChjdG9yLiR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3Rvci4kdHlwZTtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghVHlwZSlcbiAgICAgICAgVHlwZSA9IHJlcXVpcmUoXCIuL3R5cGVcIik7XG5cbiAgICB2YXIgdHlwZSA9IG5ldyBUeXBlKHR5cGVOYW1lIHx8IGN0b3IubmFtZSk7XG4gICAgdXRpbC5kZWNvcmF0ZVJvb3QuYWRkKHR5cGUpO1xuICAgIHR5cGUuY3RvciA9IGN0b3I7IC8vIHNldHMgdXAgLmVuY29kZSwgLmRlY29kZSBldGMuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IsIFwiJHR5cGVcIiwgeyB2YWx1ZTogdHlwZSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBcIiR0eXBlXCIsIHsgdmFsdWU6IHR5cGUsIGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgIHJldHVybiB0eXBlO1xufTtcblxudmFyIGRlY29yYXRlRW51bUluZGV4ID0gMDtcblxuLyoqXG4gKiBEZWNvcmF0b3IgaGVscGVyIGZvciBlbnVtcyAoVHlwZVNjcmlwdCkuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IEVudW0gb2JqZWN0XG4gKiBAcmV0dXJucyB7RW51bX0gUmVmbGVjdGVkIGVudW1cbiAqL1xudXRpbC5kZWNvcmF0ZUVudW0gPSBmdW5jdGlvbiBkZWNvcmF0ZUVudW0ob2JqZWN0KSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAob2JqZWN0LiR0eXBlKVxuICAgICAgICByZXR1cm4gb2JqZWN0LiR0eXBlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIUVudW0pXG4gICAgICAgIEVudW0gPSByZXF1aXJlKFwiLi9lbnVtXCIpO1xuXG4gICAgdmFyIGVubSA9IG5ldyBFbnVtKFwiRW51bVwiICsgZGVjb3JhdGVFbnVtSW5kZXgrKywgb2JqZWN0KTtcbiAgICB1dGlsLmRlY29yYXRlUm9vdC5hZGQoZW5tKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBcIiR0eXBlXCIsIHsgdmFsdWU6IGVubSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XG4gICAgcmV0dXJuIGVubTtcbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGJ5IHByb3BlcnR5IHBhdGguIElmIGEgdmFsdWUgYWxyZWFkeSBleGlzdHMsIGl0IGlzIHR1cm5lZCB0byBhbiBhcnJheVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZHN0IERlc3RpbmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZG90ICcuJyBkZWxpbWl0ZWQgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdGhlIHZhbHVlIHRvIHNldFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXN0aW5hdGlvbiBvYmplY3RcbiAqL1xudXRpbC5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHNldFByb3BlcnR5KGRzdCwgcGF0aCwgdmFsdWUpIHtcbiAgICBmdW5jdGlvbiBzZXRQcm9wKGRzdCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXRoLnNoaWZ0KCk7XG4gICAgICAgIGlmIChwYXJ0ID09PSBcIl9fcHJvdG9fX1wiIHx8IHBhcnQgPT09IFwicHJvdG90eXBlXCIpIHtcbiAgICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRzdFtwYXJ0XSA9IHNldFByb3AoZHN0W3BhcnRdIHx8IHt9LCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gZHN0W3BhcnRdO1xuICAgICAgICAgICAgaWYgKHByZXZWYWx1ZSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdLmNvbmNhdChwcmV2VmFsdWUpLmNvbmNhdCh2YWx1ZSk7XG4gICAgICAgICAgICBkc3RbcGFydF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHN0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZHN0ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJkc3QgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgaWYgKCFwYXRoKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJwYXRoIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuXG4gICAgcGF0aCA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICAgIHJldHVybiBzZXRQcm9wKGRzdCwgcGF0aCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3Igcm9vdCAoVHlwZVNjcmlwdCkuXG4gKiBAbmFtZSB1dGlsLmRlY29yYXRlUm9vdFxuICogQHR5cGUge1Jvb3R9XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHV0aWwsIFwiZGVjb3JhdGVSb290XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcm9vdHNbXCJkZWNvcmF0ZWRcIl0gfHwgKHJvb3RzW1wiZGVjb3JhdGVkXCJdID0gbmV3IChyZXF1aXJlKFwiLi9yb290XCIpKSgpKTtcbiAgICB9XG59KTtcbiJdLCJuYW1lcyI6WyJ1dGlsIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJyb290cyIsIlR5cGUiLCJFbnVtIiwiY29kZWdlbiIsImZldGNoIiwicGF0aCIsImZzIiwiaW5xdWlyZSIsInRvQXJyYXkiLCJvYmplY3QiLCJrZXlzIiwiT2JqZWN0IiwiYXJyYXkiLCJBcnJheSIsImxlbmd0aCIsImluZGV4IiwidG9PYmplY3QiLCJrZXkiLCJ2YWwiLCJ1bmRlZmluZWQiLCJzYWZlUHJvcEJhY2tzbGFzaFJlIiwic2FmZVByb3BRdW90ZVJlIiwiaXNSZXNlcnZlZCIsIm5hbWUiLCJ0ZXN0Iiwic2FmZVByb3AiLCJwcm9wIiwicmVwbGFjZSIsInVjRmlyc3QiLCJzdHIiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInN1YnN0cmluZyIsImNhbWVsQ2FzZVJlIiwiY2FtZWxDYXNlIiwiJDAiLCIkMSIsImNvbXBhcmVGaWVsZHNCeUlkIiwiYSIsImIiLCJpZCIsImRlY29yYXRlVHlwZSIsImN0b3IiLCJ0eXBlTmFtZSIsIiR0eXBlIiwiZGVjb3JhdGVSb290IiwicmVtb3ZlIiwiYWRkIiwidHlwZSIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwicHJvdG90eXBlIiwiZGVjb3JhdGVFbnVtSW5kZXgiLCJkZWNvcmF0ZUVudW0iLCJlbm0iLCJzZXRQcm9wZXJ0eSIsImRzdCIsInNldFByb3AiLCJwYXJ0Iiwic2hpZnQiLCJwcmV2VmFsdWUiLCJjb25jYXQiLCJUeXBlRXJyb3IiLCJzcGxpdCIsImdldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = LongBits;\nvar util = __webpack_require__(/*! ../util/minimal */ \"(ssr)/./node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */ function LongBits(lo, hi) {\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n    /**\n     * Low bits.\n     * @type {number}\n     */ this.lo = lo >>> 0;\n    /**\n     * High bits.\n     * @type {number}\n     */ this.hi = hi >>> 0;\n}\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */ var zero = LongBits.zero = new LongBits(0, 0);\nzero.toNumber = function() {\n    return 0;\n};\nzero.zzEncode = zero.zzDecode = function() {\n    return this;\n};\nzero.length = function() {\n    return 1;\n};\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */ var zeroHash = LongBits.zeroHash = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */ LongBits.fromNumber = function fromNumber(value) {\n    if (value === 0) return zero;\n    var sign = value < 0;\n    if (sign) value = -value;\n    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295) hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */ LongBits.from = function from(value) {\n    if (typeof value === \"number\") return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */ if (util.Long) value = util.Long.fromString(value);\n        else return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */ LongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;\n        if (!lo) hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */ LongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {\n        low: this.lo | 0,\n        high: this.hi | 0,\n        unsigned: Boolean(unsigned)\n    };\n};\nvar charCodeAt = String.prototype.charCodeAt;\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */ LongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash) return zero;\n    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);\n};\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */ LongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n};\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */ LongBits.prototype.zzEncode = function zzEncode() {\n    var mask = this.hi >> 31;\n    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo = (this.lo << 1 ^ mask) >>> 0;\n    return this;\n};\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */ LongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n    return this;\n};\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */ LongBits.prototype.length = function length() {\n    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;\n    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLE9BQU9DLG1CQUFPQSxDQUFDLDRFQUFpQjtBQUVwQzs7Ozs7OztDQU9DLEdBQ0QsU0FBU0YsU0FBU0csRUFBRSxFQUFFQyxFQUFFO0lBRXBCLDRGQUE0RjtJQUM1RiwwRkFBMEY7SUFFMUY7OztLQUdDLEdBQ0QsSUFBSSxDQUFDRCxFQUFFLEdBQUdBLE9BQU87SUFFakI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLE9BQU87QUFDckI7QUFFQTs7OztDQUlDLEdBQ0QsSUFBSUMsT0FBT0wsU0FBU0ssSUFBSSxHQUFHLElBQUlMLFNBQVMsR0FBRztBQUUzQ0ssS0FBS0MsUUFBUSxHQUFHO0lBQWEsT0FBTztBQUFHO0FBQ3ZDRCxLQUFLRSxRQUFRLEdBQUdGLEtBQUtHLFFBQVEsR0FBRztJQUFhLE9BQU8sSUFBSTtBQUFFO0FBQzFESCxLQUFLSSxNQUFNLEdBQUc7SUFBYSxPQUFPO0FBQUc7QUFFckM7Ozs7Q0FJQyxHQUNELElBQUlDLFdBQVdWLFNBQVNVLFFBQVEsR0FBRztBQUVuQzs7OztDQUlDLEdBQ0RWLFNBQVNXLFVBQVUsR0FBRyxTQUFTQSxXQUFXQyxLQUFLO0lBQzNDLElBQUlBLFVBQVUsR0FDVixPQUFPUDtJQUNYLElBQUlRLE9BQU9ELFFBQVE7SUFDbkIsSUFBSUMsTUFDQUQsUUFBUSxDQUFDQTtJQUNiLElBQUlULEtBQUtTLFVBQVUsR0FDZlIsS0FBSyxDQUFDUSxRQUFRVCxFQUFDLElBQUssZUFBZTtJQUN2QyxJQUFJVSxNQUFNO1FBQ05ULEtBQUssQ0FBQ0EsT0FBTztRQUNiRCxLQUFLLENBQUNBLE9BQU87UUFDYixJQUFJLEVBQUVBLEtBQUssWUFBWTtZQUNuQkEsS0FBSztZQUNMLElBQUksRUFBRUMsS0FBSyxZQUNQQSxLQUFLO1FBQ2I7SUFD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QzFCQyxRQUFRLE1BQU0sSUFBSTtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXByb2plY3QvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcz9hNTZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBMb25nQml0cztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cy5cbiAqIEBjbGFzc2Rlc2MgSGVscGVyIGNsYXNzIGZvciB3b3JraW5nIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxvIExvdyAzMiBiaXRzLCB1bnNpZ25lZFxuICogQHBhcmFtIHtudW1iZXJ9IGhpIEhpZ2ggMzIgYml0cywgdW5zaWduZWRcbiAqL1xuZnVuY3Rpb24gTG9uZ0JpdHMobG8sIGhpKSB7XG5cbiAgICAvLyBub3RlIHRoYXQgdGhlIGNhc3RzIGJlbG93IGFyZSB0aGVvcmV0aWNhbGx5IHVubmVjZXNzYXJ5IGFzIG9mIHRvZGF5LCBidXQgb2xkZXIgc3RhdGljYWxseVxuICAgIC8vIGdlbmVyYXRlZCBjb252ZXJ0ZXIgY29kZSBtaWdodCBzdGlsbCBjYWxsIHRoZSBjdG9yIHdpdGggc2lnbmVkIDMyYml0cy4ga2VwdCBmb3IgY29tcGF0LlxuXG4gICAgLyoqXG4gICAgICogTG93IGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvID0gbG8gPj4+IDA7XG5cbiAgICAvKipcbiAgICAgKiBIaWdoIGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhpID0gaGkgPj4+IDA7XG59XG5cbi8qKlxuICogWmVybyBiaXRzLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHt1dGlsLkxvbmdCaXRzfVxuICovXG52YXIgemVybyA9IExvbmdCaXRzLnplcm8gPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG5cbnplcm8udG9OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG56ZXJvLnp6RW5jb2RlID0gemVyby56ekRlY29kZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcbnplcm8ubGVuZ3RoID0gZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9O1xuXG4vKipcbiAqIFplcm8gaGFzaC5cbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgemVyb0hhc2ggPSBMb25nQml0cy56ZXJvSGFzaCA9IFwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tTnVtYmVyID0gZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDA7XG4gICAgaWYgKHNpZ24pXG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgIHZhciBsbyA9IHZhbHVlID4+PiAwLFxuICAgICAgICBoaSA9ICh2YWx1ZSAtIGxvKSAvIDQyOTQ5NjcyOTYgPj4+IDA7XG4gICAgaWYgKHNpZ24pIHtcbiAgICAgICAgaGkgPSB+aGkgPj4+IDA7XG4gICAgICAgIGxvID0gfmxvID4+PiAwO1xuICAgICAgICBpZiAoKytsbyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIGxvID0gMDtcbiAgICAgICAgICAgIGlmICgrK2hpID4gNDI5NDk2NzI5NSlcbiAgICAgICAgICAgICAgICBoaSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhsbywgaGkpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSBhIG51bWJlciwgbG9uZyBvciBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgICAgIHZhbHVlID0gdXRpbC5Mb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcihwYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmxvdyB8fCB2YWx1ZS5oaWdoID8gbmV3IExvbmdCaXRzKHZhbHVlLmxvdyA+Pj4gMCwgdmFsdWUuaGlnaCA+Pj4gMCkgOiB6ZXJvO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIHBvc3NpYmx5IHVuc2FmZSBKYXZhU2NyaXB0IG51bWJlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge251bWJlcn0gUG9zc2libHkgdW5zYWZlIG51bWJlclxuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcih1bnNpZ25lZCkge1xuICAgIGlmICghdW5zaWduZWQgJiYgdGhpcy5oaSA+Pj4gMzEpIHtcbiAgICAgICAgdmFyIGxvID0gfnRoaXMubG8gKyAxID4+PiAwLFxuICAgICAgICAgICAgaGkgPSB+dGhpcy5oaSAgICAgPj4+IDA7XG4gICAgICAgIGlmICghbG8pXG4gICAgICAgICAgICBoaSA9IGhpICsgMSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIC0obG8gKyBoaSAqIDQyOTQ5NjcyOTYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sbyArIHRoaXMuaGkgKiA0Mjk0OTY3Mjk2O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIGxvbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfSBMb25nXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0xvbmcgPSBmdW5jdGlvbiB0b0xvbmcodW5zaWduZWQpIHtcbiAgICByZXR1cm4gdXRpbC5Mb25nXG4gICAgICAgID8gbmV3IHV0aWwuTG9uZyh0aGlzLmxvIHwgMCwgdGhpcy5oaSB8IDAsIEJvb2xlYW4odW5zaWduZWQpKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IHsgbG93OiB0aGlzLmxvIHwgMCwgaGlnaDogdGhpcy5oaSB8IDAsIHVuc2lnbmVkOiBCb29sZWFuKHVuc2lnbmVkKSB9O1xufTtcblxudmFyIGNoYXJDb2RlQXQgPSBTdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEJpdHNcbiAqL1xuTG9uZ0JpdHMuZnJvbUhhc2ggPSBmdW5jdGlvbiBmcm9tSGFzaChoYXNoKSB7XG4gICAgaWYgKGhhc2ggPT09IHplcm9IYXNoKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCAwKVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAxKSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDIpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDMpIDw8IDI0KSA+Pj4gMFxuICAgICxcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNClcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNSkgPDwgOFxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA2KSA8PCAxNlxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA3KSA8PCAyNCkgPj4+IDBcbiAgICApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0hhc2ggPSBmdW5jdGlvbiB0b0hhc2goKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIHRoaXMubG8gICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDI0ICAgICAgLFxuICAgICAgICB0aGlzLmhpICAgICAgICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gOCAgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAyNFxuICAgICk7XG59O1xuXG4vKipcbiAqIFppZy16YWcgZW5jb2RlcyB0aGlzIGxvbmcgYml0cy5cbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnp6RW5jb2RlID0gZnVuY3Rpb24genpFbmNvZGUoKSB7XG4gICAgdmFyIG1hc2sgPSAgIHRoaXMuaGkgPj4gMzE7XG4gICAgdGhpcy5oaSAgPSAoKHRoaXMuaGkgPDwgMSB8IHRoaXMubG8gPj4+IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMubG8gID0gKCB0aGlzLmxvIDw8IDEgICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogWmlnLXphZyBkZWNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpEZWNvZGUgPSBmdW5jdGlvbiB6ekRlY29kZSgpIHtcbiAgICB2YXIgbWFzayA9IC0odGhpcy5sbyAmIDEpO1xuICAgIHRoaXMubG8gID0gKCh0aGlzLmxvID4+PiAxIHwgdGhpcy5oaSA8PCAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICB0aGlzLmhpICA9ICggdGhpcy5oaSA+Pj4gMSAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIGxvbmdiaXRzIHdoZW4gZW5jb2RlZCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IExlbmd0aFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHZhciBwYXJ0MCA9ICB0aGlzLmxvLFxuICAgICAgICBwYXJ0MSA9ICh0aGlzLmxvID4+PiAyOCB8IHRoaXMuaGkgPDwgNCkgPj4+IDAsXG4gICAgICAgIHBhcnQyID0gIHRoaXMuaGkgPj4+IDI0O1xuICAgIHJldHVybiBwYXJ0MiA9PT0gMFxuICAgICAgICAgPyBwYXJ0MSA9PT0gMFxuICAgICAgICAgICA/IHBhcnQwIDwgMTYzODRcbiAgICAgICAgICAgICA/IHBhcnQwIDwgMTI4ID8gMSA6IDJcbiAgICAgICAgICAgICA6IHBhcnQwIDwgMjA5NzE1MiA/IDMgOiA0XG4gICAgICAgICAgIDogcGFydDEgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDEgPCAxMjggPyA1IDogNlxuICAgICAgICAgICAgIDogcGFydDEgPCAyMDk3MTUyID8gNyA6IDhcbiAgICAgICAgIDogcGFydDIgPCAxMjggPyA5IDogMTA7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJMb25nQml0cyIsInV0aWwiLCJyZXF1aXJlIiwibG8iLCJoaSIsInplcm8iLCJ0b051bWJlciIsInp6RW5jb2RlIiwienpEZWNvZGUiLCJsZW5ndGgiLCJ6ZXJvSGFzaCIsImZyb21OdW1iZXIiLCJ2YWx1ZSIsInNpZ24iLCJmcm9tIiwiaXNTdHJpbmciLCJMb25nIiwiZnJvbVN0cmluZyIsInBhcnNlSW50IiwibG93IiwiaGlnaCIsInByb3RvdHlwZSIsInVuc2lnbmVkIiwidG9Mb25nIiwiQm9vbGVhbiIsImNoYXJDb2RlQXQiLCJTdHJpbmciLCJmcm9tSGFzaCIsImhhc2giLCJjYWxsIiwidG9IYXNoIiwiZnJvbUNoYXJDb2RlIiwibWFzayIsInBhcnQwIiwicGFydDEiLCJwYXJ0MiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/util/longbits.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar util = exports;\n// used to return a Promise where callback is omitted\nutil.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ \"(ssr)/./node_modules/@protobufjs/aspromise/index.js\");\n// converts to / from base64 encoded strings\nutil.base64 = __webpack_require__(/*! @protobufjs/base64 */ \"(ssr)/./node_modules/@protobufjs/base64/index.js\");\n// base class of rpc.Service\nutil.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ \"(ssr)/./node_modules/@protobufjs/eventemitter/index.js\");\n// float handling accross browsers\nutil.float = __webpack_require__(/*! @protobufjs/float */ \"(ssr)/./node_modules/@protobufjs/float/index.js\");\n// requires modules optionally and hides the call from bundlers\nutil.inquire = __webpack_require__(/*! @protobufjs/inquire */ \"(ssr)/./node_modules/@protobufjs/inquire/index.js\");\n// converts to / from utf8 encoded strings\nutil.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ \"(ssr)/./node_modules/@protobufjs/utf8/index.js\");\n// provides a node-like buffer pool in the browser\nutil.pool = __webpack_require__(/*! @protobufjs/pool */ \"(ssr)/./node_modules/@protobufjs/pool/index.js\");\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = __webpack_require__(/*! ./longbits */ \"(ssr)/./node_modules/protobufjs/src/util/longbits.js\");\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */ util.isNode = Boolean(typeof global !== \"undefined\" && global && global.process && global.process.versions && global.process.versions.node);\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */ util.global = util.isNode && global ||  false && 0 || typeof self !== \"undefined\" && self || this; // eslint-disable-line no-invalid-this\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */ util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */ util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */ util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */ util.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */ util.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */ util.isset = /**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */ util.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */ /**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */ util.Buffer = function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */ return null;\n    }\n}();\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */ util.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */ return typeof sizeOrArray === \"number\" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n};\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */ util.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */  : Array;\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */ /**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */ util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long || /* istanbul ignore next */ util.global.Long || util.inquire(\"long\");\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */ util.key2Re = /^true|false|0|1$/;\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */ util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */ util.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */ util.longToHash = function longToHash(value) {\n    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;\n};\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */ util.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */ function merge(dst, src, ifNotSet) {\n    for(var keys = Object.keys(src), i = 0; i < keys.length; ++i)if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];\n    return dst;\n}\nutil.merge = merge;\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */ util.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */ function newError(name) {\n    function CustomError(message, properties) {\n        if (!(this instanceof CustomError)) return new CustomError(message, properties);\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n        Object.defineProperty(this, \"message\", {\n            get: function() {\n                return message;\n            }\n        });\n        /* istanbul ignore next */ if (Error.captureStackTrace) Error.captureStackTrace(this, CustomError);\n        else Object.defineProperty(this, \"stack\", {\n            value: new Error().stack || \"\"\n        });\n        if (properties) merge(this, properties);\n    }\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true\n        },\n        name: {\n            get: function get() {\n                return name;\n            },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true\n        },\n        toString: {\n            value: function value() {\n                return this.name + \": \" + this.message;\n            },\n            writable: true,\n            enumerable: false,\n            configurable: true\n        }\n    });\n    return CustomError;\n}\nutil.newError = newError;\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */ util.ProtocolError = newError(\"ProtocolError\");\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */ /**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */ /**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */ util.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for(var i = 0; i < fieldNames.length; ++i)fieldMap[fieldNames[i]] = 1;\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */ return function() {\n        for(var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];\n    };\n};\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */ /**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */ util.oneOfSetter = function setOneOf(fieldNames) {\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */ return function(name) {\n        for(var i = 0; i < fieldNames.length; ++i)if (fieldNames[i] !== name) delete this[fieldNames[i]];\n    };\n};\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */ util.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */ if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */ function Buffer_from(value, encoding) {\n        return new Buffer(value, encoding);\n    };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */ function Buffer_allocUnsafe(size) {\n        return new Buffer(size);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsT0FBT0M7QUFFWCxxREFBcUQ7QUFDckRELEtBQUtFLFNBQVMsR0FBR0MsbUJBQU9BLENBQUMsa0ZBQXVCO0FBRWhELDRDQUE0QztBQUM1Q0gsS0FBS0ksTUFBTSxHQUFHRCxtQkFBT0EsQ0FBQyw0RUFBb0I7QUFFMUMsNEJBQTRCO0FBQzVCSCxLQUFLSyxZQUFZLEdBQUdGLG1CQUFPQSxDQUFDLHdGQUEwQjtBQUV0RCxrQ0FBa0M7QUFDbENILEtBQUtNLEtBQUssR0FBR0gsbUJBQU9BLENBQUMsMEVBQW1CO0FBRXhDLCtEQUErRDtBQUMvREgsS0FBS08sT0FBTyxHQUFHSixtQkFBT0EsQ0FBQyw4RUFBcUI7QUFFNUMsMENBQTBDO0FBQzFDSCxLQUFLUSxJQUFJLEdBQUdMLG1CQUFPQSxDQUFDLHdFQUFrQjtBQUV0QyxrREFBa0Q7QUFDbERILEtBQUtTLElBQUksR0FBR04sbUJBQU9BLENBQUMsd0VBQWtCO0FBRXRDLCtEQUErRDtBQUMvREgsS0FBS1UsUUFBUSxHQUFHUCxtQkFBT0EsQ0FBQyx3RUFBWTtBQUVwQzs7OztDQUlDLEdBQ0RILEtBQUtXLE1BQU0sR0FBR0MsUUFBUSxPQUFPQyxXQUFXLGVBQ2xCQSxVQUNBQSxPQUFPQyxPQUFPLElBQ2RELE9BQU9DLE9BQU8sQ0FBQ0MsUUFBUSxJQUN2QkYsT0FBT0MsT0FBTyxDQUFDQyxRQUFRLENBQUNDLElBQUk7QUFFbEQ7Ozs7Q0FJQyxHQUNEaEIsS0FBS2EsTUFBTSxHQUFHYixLQUFLVyxNQUFNLElBQUlFLFVBQ2YsTUFBNkIsSUFBSUksQ0FBTUEsSUFDdkMsT0FBT0MsU0FBVyxlQUFlQSxRQUNqQyxJQUFJLEVBQUUsc0NBQXNDO0FBRTFEOzs7OztDQUtDLEdBQ0RsQixLQUFLbUIsVUFBVSxHQUFHQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQyxFQUFFLElBQUksd0JBQXdCLEdBQUcsRUFBRSxFQUFFLHFCQUFxQjtBQUUxRzs7OztDQUlDLEdBQ0RyQixLQUFLc0IsV0FBVyxHQUFHRixPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEtBQUssd0JBQXdCLEdBQUcsQ0FBQyxHQUFHLHFCQUFxQjtBQUUzRzs7Ozs7Q0FLQyxHQUNEckIsS0FBS3VCLFNBQVMsR0FBR0MsT0FBT0QsU0FBUyxJQUFJLHdCQUF3QixHQUFHLFNBQVNBLFVBQVVFLEtBQUs7SUFDcEYsT0FBTyxPQUFPQSxVQUFVLFlBQVlDLFNBQVNELFVBQVVFLEtBQUtDLEtBQUssQ0FBQ0gsV0FBV0E7QUFDakY7QUFFQTs7OztDQUlDLEdBQ0R6QixLQUFLNkIsUUFBUSxHQUFHLFNBQVNBLFNBQVNKLEtBQUs7SUFDbkMsT0FBTyxPQUFPQSxVQUFVLFlBQVlBLGlCQUFpQks7QUFDekQ7QUFFQTs7OztDQUlDLEdBQ0Q5QixLQUFLK0IsUUFBUSxHQUFHLFNBQVNBLFNBQVNOLEtBQUs7SUFDbkMsT0FBT0EsU0FBUyxPQUFPQSxVQUFVO0FBQ3JDO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNEekIsS0FBS2dDLEtBQUssR0FFVjs7Ozs7Q0FLQyxHQUNEaEMsS0FBS2lDLEtBQUssR0FBRyxTQUFTQSxNQUFNQyxHQUFHLEVBQUVDLElBQUk7SUFDakMsSUFBSVYsUUFBUVMsR0FBRyxDQUFDQyxLQUFLO0lBQ3JCLElBQUlWLFNBQVMsUUFBUVMsSUFBSUUsY0FBYyxDQUFDRCxPQUNwQyxPQUFPLE9BQU9WLFVBQVUsWUFBWSxDQUFDWSxNQUFNQyxPQUFPLENBQUNiLFNBQVNBLE1BQU1jLE1BQU0sR0FBR25CLE9BQU9vQixJQUFJLENBQUNmLE9BQU9jLE1BQU0sSUFBSTtJQUM1RyxPQUFPO0FBQ1g7QUFFQTs7Ozs7Q0FLQyxHQUVEOzs7Q0FHQyxHQUNEdkMsS0FBS3lDLE1BQU0sR0FBRztJQUNWLElBQUk7UUFDQSxJQUFJQSxTQUFTekMsS0FBS08sT0FBTyxDQUFDLFVBQVVrQyxNQUFNO1FBQzFDLDRFQUE0RTtRQUM1RSxPQUFPQSxPQUFPQyxTQUFTLENBQUNDLFNBQVMsR0FBR0YsU0FBUyx3QkFBd0IsR0FBRztJQUM1RSxFQUFFLE9BQU9HLEdBQUc7UUFDUix3QkFBd0IsR0FDeEIsT0FBTztJQUNYO0FBQ0o7QUFFQSxpREFBaUQ7QUFDakQ1QyxLQUFLNkMsWUFBWSxHQUFHO0FBRXBCLHdEQUF3RDtBQUN4RDdDLEtBQUs4QyxtQkFBbUIsR0FBRztBQUUzQjs7OztDQUlDLEdBQ0Q5QyxLQUFLK0MsU0FBUyxHQUFHLFNBQVNBLFVBQVVDLFdBQVc7SUFDM0Msd0JBQXdCLEdBQ3hCLE9BQU8sT0FBT0EsZ0JBQWdCLFdBQ3hCaEQsS0FBS3lDLE1BQU0sR0FDUHpDLEtBQUs4QyxtQkFBbUIsQ0FBQ0UsZUFDekIsSUFBSWhELEtBQUtxQyxLQUFLLENBQUNXLGVBQ25CaEQsS0FBS3lDLE1BQU0sR0FDUHpDLEtBQUs2QyxZQUFZLENBQUNHLGVBQ2xCLE9BQU9DLGVBQWUsY0FDbEJELGNBQ0EsSUFBSUMsV0FBV0Q7QUFDakM7QUFFQTs7O0NBR0MsR0FDRGhELEtBQUtxQyxLQUFLLEdBQUcsT0FBT1ksZUFBZSxjQUFjQSxXQUFXLHdCQUF3QixNQUFLWjtBQUV6Rjs7Ozs7OztDQU9DLEdBRUQ7OztDQUdDLEdBQ0RyQyxLQUFLa0QsSUFBSSxHQUFHLHdCQUF3QixHQUFHbEQsS0FBS2EsTUFBTSxDQUFDc0MsT0FBTyxJQUFJLHdCQUF3QixHQUFHbkQsS0FBS2EsTUFBTSxDQUFDc0MsT0FBTyxDQUFDRCxJQUFJLElBQ3JHLHdCQUF3QixHQUFHbEQsS0FBS2EsTUFBTSxDQUFDcUMsSUFBSSxJQUMzQ2xELEtBQUtPLE9BQU8sQ0FBQztBQUV6Qjs7OztDQUlDLEdBQ0RQLEtBQUtvRCxNQUFNLEdBQUc7QUFFZDs7OztDQUlDLEdBQ0RwRCxLQUFLcUQsT0FBTyxHQUFHO0FBRWY7Ozs7Q0FJQyxHQUNEckQsS0FBS3NELE9BQU8sR0FBRztBQUVmOzs7O0NBSUMsR0FDRHRELEtBQUt1RCxVQUFVLEdBQUcsU0FBU0EsV0FBVzlCLEtBQUs7SUFDdkMsT0FBT0EsUUFDRHpCLEtBQUtVLFFBQVEsQ0FBQzhDLElBQUksQ0FBQy9CLE9BQU9nQyxNQUFNLEtBQ2hDekQsS0FBS1UsUUFBUSxDQUFDZ0QsUUFBUTtBQUNoQztBQUVBOzs7OztDQUtDLEdBQ0QxRCxLQUFLMkQsWUFBWSxHQUFHLFNBQVNBLGFBQWFDLElBQUksRUFBRUMsUUFBUTtJQUNwRCxJQUFJQyxPQUFPOUQsS0FBS1UsUUFBUSxDQUFDcUQsUUFBUSxDQUFDSDtJQUNsQyxJQUFJNUQsS0FBS2tELElBQUksRUFDVCxPQUFPbEQsS0FBS2tELElBQUksQ0FBQ2MsUUFBUSxDQUFDRixLQUFLRyxFQUFFLEVBQUVILEtBQUtJLEVBQUUsRUFBRUw7SUFDaEQsT0FBT0MsS0FBS0ssUUFBUSxDQUFDdkQsUUFBUWlEO0FBQ2pDO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNPLE1BQU1DLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxRQUFRO0lBQzdCLElBQUssSUFBSS9CLE9BQU9wQixPQUFPb0IsSUFBSSxDQUFDOEIsTUFBTUUsSUFBSSxHQUFHQSxJQUFJaEMsS0FBS0QsTUFBTSxFQUFFLEVBQUVpQyxFQUN4RCxJQUFJSCxHQUFHLENBQUM3QixJQUFJLENBQUNnQyxFQUFFLENBQUMsS0FBS0MsYUFBYSxDQUFDRixVQUMvQkYsR0FBRyxDQUFDN0IsSUFBSSxDQUFDZ0MsRUFBRSxDQUFDLEdBQUdGLEdBQUcsQ0FBQzlCLElBQUksQ0FBQ2dDLEVBQUUsQ0FBQztJQUNuQyxPQUFPSDtBQUNYO0FBRUFyRSxLQUFLb0UsS0FBSyxHQUFHQTtBQUViOzs7O0NBSUMsR0FDRHBFLEtBQUswRSxPQUFPLEdBQUcsU0FBU0EsUUFBUUMsR0FBRztJQUMvQixPQUFPQSxJQUFJQyxNQUFNLENBQUMsR0FBR0MsV0FBVyxLQUFLRixJQUFJRyxTQUFTLENBQUM7QUFDdkQ7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNDLFNBQVNDLElBQUk7SUFFbEIsU0FBU0MsWUFBWUMsT0FBTyxFQUFFQyxVQUFVO1FBRXBDLElBQUksQ0FBRSxLQUFJLFlBQVlGLFdBQVUsR0FDNUIsT0FBTyxJQUFJQSxZQUFZQyxTQUFTQztRQUVwQyw2QkFBNkI7UUFDN0IsbUZBQW1GO1FBRW5GL0QsT0FBT2dFLGNBQWMsQ0FBQyxJQUFJLEVBQUUsV0FBVztZQUFFQyxLQUFLO2dCQUFhLE9BQU9IO1lBQVM7UUFBRTtRQUU3RSx3QkFBd0IsR0FDeEIsSUFBSUksTUFBTUMsaUJBQWlCLEVBQ3ZCRCxNQUFNQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUVOO2FBRTlCN0QsT0FBT2dFLGNBQWMsQ0FBQyxJQUFJLEVBQUUsU0FBUztZQUFFM0QsT0FBTyxJQUFJNkQsUUFBUUUsS0FBSyxJQUFJO1FBQUc7UUFFMUUsSUFBSUwsWUFDQWYsTUFBTSxJQUFJLEVBQUVlO0lBQ3BCO0lBRUFGLFlBQVl2QyxTQUFTLEdBQUd0QixPQUFPcUUsTUFBTSxDQUFDSCxNQUFNNUMsU0FBUyxFQUFFO1FBQ25EZ0QsYUFBYTtZQUNUakUsT0FBT3dEO1lBQ1BVLFVBQVU7WUFDVkMsWUFBWTtZQUNaQyxjQUFjO1FBQ2xCO1FBQ0FiLE1BQU07WUFDRkssS0FBSyxTQUFTQTtnQkFBUSxPQUFPTDtZQUFNO1lBQ25DYyxLQUFLckI7WUFDTG1CLFlBQVk7WUFDWixnRUFBZ0U7WUFDaEUsMkRBQTJEO1lBQzNELG9EQUFvRDtZQUNwRCxtQkFBbUI7WUFDbkJDLGNBQWM7UUFDbEI7UUFDQUUsVUFBVTtZQUNOdEUsT0FBTyxTQUFTQTtnQkFBVSxPQUFPLElBQUksQ0FBQ3VELElBQUksR0FBRyxPQUFPLElBQUksQ0FBQ0UsT0FBTztZQUFFO1lBQ2xFUyxVQUFVO1lBQ1ZDLFlBQVk7WUFDWkMsY0FBYztRQUNsQjtJQUNKO0lBRUEsT0FBT1o7QUFDWDtBQUVBakYsS0FBSytFLFFBQVEsR0FBR0E7QUFFaEI7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDRC9FLEtBQUtnRyxhQUFhLEdBQUdqQixTQUFTO0FBRTlCOzs7O0NBSUMsR0FFRDs7Ozs7Q0FLQyxHQUVEOzs7O0NBSUMsR0FDRC9FLEtBQUtpRyxXQUFXLEdBQUcsU0FBU0MsU0FBU0MsVUFBVTtJQUMzQyxJQUFJQyxXQUFXLENBQUM7SUFDaEIsSUFBSyxJQUFJNUIsSUFBSSxHQUFHQSxJQUFJMkIsV0FBVzVELE1BQU0sRUFBRSxFQUFFaUMsRUFDckM0QixRQUFRLENBQUNELFVBQVUsQ0FBQzNCLEVBQUUsQ0FBQyxHQUFHO0lBRTlCOzs7O0tBSUMsR0FDRCxPQUFPO1FBQ0gsSUFBSyxJQUFJaEMsT0FBT3BCLE9BQU9vQixJQUFJLENBQUMsSUFBSSxHQUFHZ0MsSUFBSWhDLEtBQUtELE1BQU0sR0FBRyxHQUFHaUMsSUFBSSxDQUFDLEdBQUcsRUFBRUEsRUFDOUQsSUFBSTRCLFFBQVEsQ0FBQzVELElBQUksQ0FBQ2dDLEVBQUUsQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDaEMsSUFBSSxDQUFDZ0MsRUFBRSxDQUFDLEtBQUtDLGFBQWEsSUFBSSxDQUFDakMsSUFBSSxDQUFDZ0MsRUFBRSxDQUFDLEtBQUssTUFDNUUsT0FBT2hDLElBQUksQ0FBQ2dDLEVBQUU7SUFDMUI7QUFDSjtBQUVBOzs7Ozs7Q0FNQyxHQUVEOzs7O0NBSUMsR0FDRHhFLEtBQUtxRyxXQUFXLEdBQUcsU0FBU0MsU0FBU0gsVUFBVTtJQUUzQzs7Ozs7S0FLQyxHQUNELE9BQU8sU0FBU25CLElBQUk7UUFDaEIsSUFBSyxJQUFJUixJQUFJLEdBQUdBLElBQUkyQixXQUFXNUQsTUFBTSxFQUFFLEVBQUVpQyxFQUNyQyxJQUFJMkIsVUFBVSxDQUFDM0IsRUFBRSxLQUFLUSxNQUNsQixPQUFPLElBQUksQ0FBQ21CLFVBQVUsQ0FBQzNCLEVBQUUsQ0FBQztJQUN0QztBQUNKO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0R4RSxLQUFLdUcsYUFBYSxHQUFHO0lBQ2pCQyxPQUFPMUU7SUFDUDJFLE9BQU8zRTtJQUNQNEUsT0FBTzVFO0lBQ1A2RSxNQUFNO0FBQ1Y7QUFFQSxnRkFBZ0Y7QUFDaEYzRyxLQUFLNEcsVUFBVSxHQUFHO0lBQ2QsSUFBSW5FLFNBQVN6QyxLQUFLeUMsTUFBTTtJQUN4QixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDQSxRQUFRO1FBQ1R6QyxLQUFLNkMsWUFBWSxHQUFHN0MsS0FBSzhDLG1CQUFtQixHQUFHO1FBQy9DO0lBQ0o7SUFDQSx3REFBd0Q7SUFDeEQsdURBQXVEO0lBQ3ZEOUMsS0FBSzZDLFlBQVksR0FBR0osT0FBT2UsSUFBSSxLQUFLUCxXQUFXTyxJQUFJLElBQUlmLE9BQU9lLElBQUksSUFDOUQsd0JBQXdCLEdBQ3hCLFNBQVNxRCxZQUFZcEYsS0FBSyxFQUFFcUYsUUFBUTtRQUNoQyxPQUFPLElBQUlyRSxPQUFPaEIsT0FBT3FGO0lBQzdCO0lBQ0o5RyxLQUFLOEMsbUJBQW1CLEdBQUdMLE9BQU9zRSxXQUFXLElBQ3pDLHdCQUF3QixHQUN4QixTQUFTQyxtQkFBbUJDLElBQUk7UUFDNUIsT0FBTyxJQUFJeEUsT0FBT3dFO0lBQ3RCO0FBQ1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbWluaW1hbC5qcz9mZTFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSBleHBvcnRzO1xuXG4vLyB1c2VkIHRvIHJldHVybiBhIFByb21pc2Ugd2hlcmUgY2FsbGJhY2sgaXMgb21pdHRlZFxudXRpbC5hc1Byb21pc2UgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYXNwcm9taXNlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xudXRpbC5iYXNlNjQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYmFzZTY0XCIpO1xuXG4vLyBiYXNlIGNsYXNzIG9mIHJwYy5TZXJ2aWNlXG51dGlsLkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9ldmVudGVtaXR0ZXJcIik7XG5cbi8vIGZsb2F0IGhhbmRsaW5nIGFjY3Jvc3MgYnJvd3NlcnNcbnV0aWwuZmxvYXQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmxvYXRcIik7XG5cbi8vIHJlcXVpcmVzIG1vZHVsZXMgb3B0aW9uYWxseSBhbmQgaGlkZXMgdGhlIGNhbGwgZnJvbSBidW5kbGVyc1xudXRpbC5pbnF1aXJlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2lucXVpcmVcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSB1dGY4IGVuY29kZWQgc3RyaW5nc1xudXRpbC51dGY4ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3V0ZjhcIik7XG5cbi8vIHByb3ZpZGVzIGEgbm9kZS1saWtlIGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyXG51dGlsLnBvb2wgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvcG9vbFwiKTtcblxuLy8gdXRpbGl0eSB0byB3b3JrIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlXG51dGlsLkxvbmdCaXRzID0gcmVxdWlyZShcIi4vbG9uZ2JpdHNcIik7XG5cbi8qKlxuICogV2hldGhlciBydW5uaW5nIHdpdGhpbiBub2RlIG9yIG5vdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudXRpbC5pc05vZGUgPSBCb29sZWFuKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWxcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG5cbi8qKlxuICogR2xvYmFsIG9iamVjdCByZWZlcmVuY2UuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge09iamVjdH1cbiAqL1xudXRpbC5nbG9iYWwgPSB1dGlsLmlzTm9kZSAmJiBnbG9iYWxcbiAgICAgICAgICAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dcbiAgICAgICAgICAgfHwgdHlwZW9mIHNlbGYgICAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXG4gICAgICAgICAgIHx8IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXG5cbi8qKlxuICogQW4gaW1tdWFibGUgZW1wdHkgYXJyYXkuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge0FycmF5LjwqPn1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZShbXSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIGVtcHR5IG9iamVjdC5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKHt9KSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9OyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlclxuICovXG51dGlsLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZ1xuICovXG51dGlsLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdFxuICovXG51dGlsLmlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgdXRpbC5pc1NldH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzc2V0ID1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNTZXQgPSBmdW5jdGlvbiBpc1NldChvYmosIHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcSwgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkgPiAwO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgQnVmZmVyIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIEJ1ZmZlciBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbm9kZSdzIHR5cGluZ3MuXG4gKiBAaW50ZXJmYWNlIEJ1ZmZlclxuICogQGV4dGVuZHMgVWludDhBcnJheVxuICovXG5cbi8qKlxuICogTm9kZSdzIEJ1ZmZlciBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8QnVmZmVyPn1cbiAqL1xudXRpbC5CdWZmZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIEJ1ZmZlciA9IHV0aWwuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgICAgIC8vIHJlZnVzZSB0byB1c2Ugbm9uLW5vZGUgYnVmZmVycyBpZiBub3QgZXhwbGljaXRseSBhc3NpZ25lZCAocGVyZiByZWFzb25zKTpcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID8gQnVmZmVyIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn0pKCk7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmdWxsIGZvciBCdWZmZXIuZnJvbS5cbnV0aWwuX0J1ZmZlcl9mcm9tID0gbnVsbDtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZpbGwgZm9yIEJ1ZmZlci5hbGxvY1Vuc2FmZS5cbnV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBidWZmZXIgb2Ygd2hhdGV2ZXIgdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IFtzaXplT3JBcnJheT0wXSBCdWZmZXIgc2l6ZSBvciBudW1iZXIgYXJyYXlcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fEJ1ZmZlcn0gQnVmZmVyXG4gKi9cbnV0aWwubmV3QnVmZmVyID0gZnVuY3Rpb24gbmV3QnVmZmVyKHNpemVPckFycmF5KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdHlwZW9mIHNpemVPckFycmF5ID09PSBcIm51bWJlclwiXG4gICAgICAgID8gdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiBuZXcgdXRpbC5BcnJheShzaXplT3JBcnJheSlcbiAgICAgICAgOiB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfZnJvbShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICA/IHNpemVPckFycmF5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheShzaXplT3JBcnJheSk7XG59O1xuXG4vKipcbiAqIEFycmF5IGltcGxlbWVudGF0aW9uIHVzZWQgaW4gdGhlIGJyb3dzZXIuIGBVaW50OEFycmF5YCBpZiBzdXBwb3J0ZWQsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPFVpbnQ4QXJyYXk+fVxuICovXG51dGlsLkFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDogQXJyYXk7XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgTG9uZyBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBMb25nIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBsb25nLmpzLlxuICogQGludGVyZmFjZSBMb25nXG4gKiBAcHJvcGVydHkge251bWJlcn0gbG93IExvdyBiaXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGlnaCBIaWdoIGJpdHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqL1xuXG4vKipcbiAqIExvbmcuanMncyBMb25nIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxMb25nPn1cbiAqL1xudXRpbC5Mb25nID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTyAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPLkxvbmdcbiAgICAgICAgIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLkxvbmdcbiAgICAgICAgIHx8IHV0aWwuaW5xdWlyZShcImxvbmdcIik7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDIgYml0IChgYm9vbGApIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTJSZSA9IC9edHJ1ZXxmYWxzZXwwfDEkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMzIgYml0IChgaW50MzJgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTMyUmUgPSAvXi0/KD86MHxbMS05XVswLTldKikkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgNjQgYml0IChgaW50NjRgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTY0UmUgPSAvXig/OltcXFxceDAwLVxcXFx4ZmZdezh9fC0/KD86MHxbMS05XVswLTldKikpJC87XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgb3IgbG9uZyB0byBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xudXRpbC5sb25nVG9IYXNoID0gZnVuY3Rpb24gbG9uZ1RvSGFzaCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IHV0aWwuTG9uZ0JpdHMuZnJvbSh2YWx1ZSkudG9IYXNoKClcbiAgICAgICAgOiB1dGlsLkxvbmdCaXRzLnplcm9IYXNoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZyB0byBhIGxvbmcgb3IgbnVtYmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ3xudW1iZXJ9IE9yaWdpbmFsIHZhbHVlXG4gKi9cbnV0aWwubG9uZ0Zyb21IYXNoID0gZnVuY3Rpb24gbG9uZ0Zyb21IYXNoKGhhc2gsIHVuc2lnbmVkKSB7XG4gICAgdmFyIGJpdHMgPSB1dGlsLkxvbmdCaXRzLmZyb21IYXNoKGhhc2gpO1xuICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgIHJldHVybiB1dGlsLkxvbmcuZnJvbUJpdHMoYml0cy5sbywgYml0cy5oaSwgdW5zaWduZWQpO1xuICAgIHJldHVybiBiaXRzLnRvTnVtYmVyKEJvb2xlYW4odW5zaWduZWQpKTtcbn07XG5cbi8qKlxuICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBzcmMgU291cmNlIG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXQ9ZmFsc2VdIE1lcmdlcyBvbmx5IGlmIHRoZSBrZXkgaXMgbm90IGFscmVhZHkgc2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc3RpbmF0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBtZXJnZShkc3QsIHNyYywgaWZOb3RTZXQpIHsgLy8gdXNlZCBieSBjb252ZXJ0ZXJzXG4gICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGRzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkIHx8ICFpZk5vdFNldClcbiAgICAgICAgICAgIGRzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICByZXR1cm4gZHN0O1xufVxuXG51dGlsLm1lcmdlID0gbWVyZ2U7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHN0cmluZyB0byBsb3dlciBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLmxjRmlyc3QgPSBmdW5jdGlvbiBsY0ZpcnN0KHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVycm9yIG5hbWVcbiAqIEByZXR1cm5zIHtDb25zdHJ1Y3RvcjxFcnJvcj59IEN1c3RvbSBlcnJvciBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBuZXdFcnJvcihuYW1lKSB7XG5cbiAgICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKSB7XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbUVycm9yKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcyk7XG5cbiAgICAgICAgLy8gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgLy8gXiBqdXN0IHJldHVybnMgYSBuZXcgZXJyb3IgaW5zdGFuY2UgYmVjYXVzZSB0aGUgY3RvciBjYW4gYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb25cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1lc3NhZ2U7IH0gfSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSAvLyBub2RlXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDdXN0b21FcnJvcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHsgdmFsdWU6IG5ldyBFcnJvcigpLnN0YWNrIHx8IFwiXCIgfSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICBtZXJnZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICBDdXN0b21FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IEN1c3RvbUVycm9yLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7IHJldHVybiBuYW1lOyB9LFxuICAgICAgICAgICAgc2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyYWJsZTogZmFsc2Ugd291bGQgYWNjdXJhdGVseSBwcmVzZXJ2ZSB0aGUgYmVoYXZpb3Igb2ZcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCwgYnV0IEknbSBndWVzc2luZyB0aGF0IHdhcyBub3QgaW50ZW50aW9uYWwuXG4gICAgICAgICAgICAvLyBGb3IgYW4gYWN0dWFsIGVycm9yIHN1YmNsYXNzLCB0aGlzIHByb3BlcnR5IHdvdWxkXG4gICAgICAgICAgICAvLyBiZSBjb25maWd1cmFibGUuXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRvU3RyaW5nOiB7XG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7IHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7IH0sXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEN1c3RvbUVycm9yO1xufVxuXG51dGlsLm5ld0Vycm9yID0gbmV3RXJyb3I7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBwcm90b2NvbCBlcnJvci5cbiAqIEBjbGFzc2Rlc2MgRXJyb3Igc3ViY2xhc3MgaW5kaWNhdGluZyBhIHByb3RvY29sIHNwZWNpZmMgZXJyb3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGV4dGVuZHMgRXJyb3JcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAZXhhbXBsZVxuICogdHJ5IHtcbiAqICAgICBNeU1lc3NhZ2UuZGVjb2RlKHNvbWVCdWZmZXIpOyAvLyB0aHJvd3MgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKiB9IGNhdGNoIChlKSB7XG4gKiAgICAgaWYgKGUgaW5zdGFuY2VvZiBQcm90b2NvbEVycm9yICYmIGUuaW5zdGFuY2UpXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBzbyBmYXI6IFwiICsgSlNPTi5zdHJpbmdpZnkoZS5pbnN0YW5jZSkpO1xuICogfVxuICovXG51dGlsLlByb3RvY29sRXJyb3IgPSBuZXdFcnJvcihcIlByb3RvY29sRXJyb3JcIik7XG5cbi8qKlxuICogU28gZmFyIGRlY29kZWQgbWVzc2FnZSBpbnN0YW5jZS5cbiAqIEBuYW1lIHV0aWwuUHJvdG9jb2xFcnJvciNpbnN0YW5jZVxuICogQHR5cGUge01lc3NhZ2U8VD59XG4gKi9cblxuLyoqXG4gKiBBIE9uZU9mIGdldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZkdldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZkdldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIGdldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZkdldHRlcn0gVW5ib3VuZCBnZXR0ZXJcbiAqL1xudXRpbC5vbmVPZkdldHRlciA9IGZ1bmN0aW9uIGdldE9uZU9mKGZpZWxkTmFtZXMpIHtcbiAgICB2YXIgZmllbGRNYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGZpZWxkTWFwW2ZpZWxkTmFtZXNbaV1dID0gMTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbigpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcyksIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPiAtMTsgLS1pKVxuICAgICAgICAgICAgaWYgKGZpZWxkTWFwW2tleXNbaV1dID09PSAxICYmIHRoaXNba2V5c1tpXV0gIT09IHVuZGVmaW5lZCAmJiB0aGlzW2tleXNbaV1dICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzW2ldO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEEgT25lT2Ygc2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mU2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mU2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHZhbHVlIEZpZWxkIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBzZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZTZXR0ZXJ9IFVuYm91bmQgc2V0dGVyXG4gKi9cbnV0aWwub25lT2ZTZXR0ZXIgPSBmdW5jdGlvbiBzZXRPbmVPZihmaWVsZE5hbWVzKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0gIT09IG5hbWUpXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbZmllbGROYW1lc1tpXV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBjb252ZXJzaW9uIG9wdGlvbnMgdXNlZCBmb3Ige0BsaW5rIE1lc3NhZ2UjdG9KU09OfSBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgY2xvc2UgdG8gcHJvdG8zJ3MgSlNPTiBtYXBwaW5nIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IGludGVybmFsIHR5cGVzIGxpa2UgQW55IGFyZSBoYW5kbGVkIGp1c3QgbGlrZSBtZXNzYWdlcy4gTW9yZSBwcmVjaXNlbHk6XG4gKlxuICogLSBMb25ncyBiZWNvbWUgc3RyaW5nc1xuICogLSBFbnVtcyBiZWNvbWUgc3RyaW5nIGtleXNcbiAqIC0gQnl0ZXMgYmVjb21lIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqIC0gKFN1Yi0pTWVzc2FnZXMgYmVjb21lIHBsYWluIG9iamVjdHNcbiAqIC0gTWFwcyBiZWNvbWUgcGxhaW4gb2JqZWN0cyB3aXRoIGFsbCBzdHJpbmcga2V5c1xuICogLSBSZXBlYXRlZCBmaWVsZHMgYmVjb21lIGFycmF5c1xuICogLSBOYU4gYW5kIEluZmluaXR5IGZvciBmbG9hdCBhbmQgZG91YmxlIGZpZWxkcyBiZWNvbWUgc3RyaW5nc1xuICpcbiAqIEB0eXBlIHtJQ29udmVyc2lvbk9wdGlvbnN9XG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzM/aGw9ZW4janNvblxuICovXG51dGlsLnRvSlNPTk9wdGlvbnMgPSB7XG4gICAgbG9uZ3M6IFN0cmluZyxcbiAgICBlbnVtczogU3RyaW5nLFxuICAgIGJ5dGVzOiBTdHJpbmcsXG4gICAganNvbjogdHJ1ZVxufTtcblxuLy8gU2V0cyB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50IChjYWxsZWQgaW4gaW5kZXgtbWluaW1hbClcbnV0aWwuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBCdWZmZXIgPSB1dGlsLkJ1ZmZlcjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUJ1ZmZlcikge1xuICAgICAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYmVjYXVzZSBub2RlIDQueCBidWZmZXJzIGFyZSBpbmNvbXBhdGlibGUgJiBpbW11dGFibGVcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL3Byb3RvYnVmLmpzL3B1bGwvNjY1XG4gICAgdXRpbC5fQnVmZmVyX2Zyb20gPSBCdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tICYmIEJ1ZmZlci5mcm9tIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9mcm9tKHZhbHVlLCBlbmNvZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nKTtcbiAgICAgICAgfTtcbiAgICB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2FsbG9jVW5zYWZlKHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xuICAgICAgICB9O1xufTtcbiJdLCJuYW1lcyI6WyJ1dGlsIiwiZXhwb3J0cyIsImFzUHJvbWlzZSIsInJlcXVpcmUiLCJiYXNlNjQiLCJFdmVudEVtaXR0ZXIiLCJmbG9hdCIsImlucXVpcmUiLCJ1dGY4IiwicG9vbCIsIkxvbmdCaXRzIiwiaXNOb2RlIiwiQm9vbGVhbiIsImdsb2JhbCIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJ3aW5kb3ciLCJzZWxmIiwiZW1wdHlBcnJheSIsIk9iamVjdCIsImZyZWV6ZSIsImVtcHR5T2JqZWN0IiwiaXNJbnRlZ2VyIiwiTnVtYmVyIiwidmFsdWUiLCJpc0Zpbml0ZSIsIk1hdGgiLCJmbG9vciIsImlzU3RyaW5nIiwiU3RyaW5nIiwiaXNPYmplY3QiLCJpc3NldCIsImlzU2V0Iiwib2JqIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwia2V5cyIsIkJ1ZmZlciIsInByb3RvdHlwZSIsInV0ZjhXcml0ZSIsImUiLCJfQnVmZmVyX2Zyb20iLCJfQnVmZmVyX2FsbG9jVW5zYWZlIiwibmV3QnVmZmVyIiwic2l6ZU9yQXJyYXkiLCJVaW50OEFycmF5IiwiTG9uZyIsImRjb2RlSU8iLCJrZXkyUmUiLCJrZXkzMlJlIiwia2V5NjRSZSIsImxvbmdUb0hhc2giLCJmcm9tIiwidG9IYXNoIiwiemVyb0hhc2giLCJsb25nRnJvbUhhc2giLCJoYXNoIiwidW5zaWduZWQiLCJiaXRzIiwiZnJvbUhhc2giLCJmcm9tQml0cyIsImxvIiwiaGkiLCJ0b051bWJlciIsIm1lcmdlIiwiZHN0Iiwic3JjIiwiaWZOb3RTZXQiLCJpIiwidW5kZWZpbmVkIiwibGNGaXJzdCIsInN0ciIsImNoYXJBdCIsInRvTG93ZXJDYXNlIiwic3Vic3RyaW5nIiwibmV3RXJyb3IiLCJuYW1lIiwiQ3VzdG9tRXJyb3IiLCJtZXNzYWdlIiwicHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsInN0YWNrIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJzZXQiLCJ0b1N0cmluZyIsIlByb3RvY29sRXJyb3IiLCJvbmVPZkdldHRlciIsImdldE9uZU9mIiwiZmllbGROYW1lcyIsImZpZWxkTWFwIiwib25lT2ZTZXR0ZXIiLCJzZXRPbmVPZiIsInRvSlNPTk9wdGlvbnMiLCJsb25ncyIsImVudW1zIiwiYnl0ZXMiLCJqc29uIiwiX2NvbmZpZ3VyZSIsIkJ1ZmZlcl9mcm9tIiwiZW5jb2RpbmciLCJhbGxvY1Vuc2FmZSIsIkJ1ZmZlcl9hbGxvY1Vuc2FmZSIsInNpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/util/minimal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/verifier.js":
/*!*************************************************!*\
  !*** ./node_modules/protobufjs/src/verifier.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = verifier;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/protobufjs/src/enum.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/protobufjs/src/util.js\");\nfunction invalid(field, expected) {\n    return field.name + \": \" + expected + (field.repeated && expected !== \"array\" ? \"[]\" : field.map && expected !== \"object\" ? \"{k:\" + field.keyType + \"}\" : \"\") + \" expected\";\n}\n/**\n * Generates a partial value verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genVerifyValue(gen, field, fieldIndex, ref) {\n    /* eslint-disable no-unexpected-multiline */ if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) {\n            gen(\"switch(%s){\", ref)(\"default:\")(\"return%j\", invalid(field, \"enum value\"));\n            for(var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j)gen(\"case %i:\", field.resolvedType.values[keys[j]]);\n            gen(\"break\")(\"}\");\n        } else {\n            gen(\"{\")(\"var e=types[%i].verify(%s);\", fieldIndex, ref)(\"if(e)\")(\"return%j+e\", field.name + \".\")(\"}\");\n        }\n    } else {\n        switch(field.type){\n            case \"int32\":\n            case \"uint32\":\n            case \"sint32\":\n            case \"fixed32\":\n            case \"sfixed32\":\n                gen(\"if(!util.isInteger(%s))\", ref)(\"return%j\", invalid(field, \"integer\"));\n                break;\n            case \"int64\":\n            case \"uint64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                gen(\"if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))\", ref, ref, ref, ref)(\"return%j\", invalid(field, \"integer|Long\"));\n                break;\n            case \"float\":\n            case \"double\":\n                gen('if(typeof %s!==\"number\")', ref)(\"return%j\", invalid(field, \"number\"));\n                break;\n            case \"bool\":\n                gen('if(typeof %s!==\"boolean\")', ref)(\"return%j\", invalid(field, \"boolean\"));\n                break;\n            case \"string\":\n                gen(\"if(!util.isString(%s))\", ref)(\"return%j\", invalid(field, \"string\"));\n                break;\n            case \"bytes\":\n                gen('if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))', ref, ref, ref)(\"return%j\", invalid(field, \"buffer\"));\n                break;\n        }\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline */ }\n/**\n * Generates a partial key verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genVerifyKey(gen, field, ref) {\n    /* eslint-disable no-unexpected-multiline */ switch(field.keyType){\n        case \"int32\":\n        case \"uint32\":\n        case \"sint32\":\n        case \"fixed32\":\n        case \"sfixed32\":\n            gen(\"if(!util.key32Re.test(%s))\", ref)(\"return%j\", invalid(field, \"integer key\"));\n            break;\n        case \"int64\":\n        case \"uint64\":\n        case \"sint64\":\n        case \"fixed64\":\n        case \"sfixed64\":\n            gen(\"if(!util.key64Re.test(%s))\", ref) // see comment above: x is ok, d is not\n            (\"return%j\", invalid(field, \"integer|Long key\"));\n            break;\n        case \"bool\":\n            gen(\"if(!util.key2Re.test(%s))\", ref)(\"return%j\", invalid(field, \"boolean key\"));\n            break;\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline */ }\n/**\n * Generates a verifier specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ function verifier(mtype) {\n    /* eslint-disable no-unexpected-multiline */ var gen = util.codegen([\n        \"m\"\n    ], mtype.name + \"$verify\")('if(typeof m!==\"object\"||m===null)')(\"return%j\", \"object expected\");\n    var oneofs = mtype.oneofsArray, seenFirstField = {};\n    if (oneofs.length) gen(\"var p={}\");\n    for(var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i){\n        var field = mtype._fieldsArray[i].resolve(), ref = \"m\" + util.safeProp(field.name);\n        if (field.optional) gen(\"if(%s!=null&&m.hasOwnProperty(%j)){\", ref, field.name); // !== undefined && !== null\n        // map fields\n        if (field.map) {\n            gen(\"if(!util.isObject(%s))\", ref)(\"return%j\", invalid(field, \"object\"))(\"var k=Object.keys(%s)\", ref)(\"for(var i=0;i<k.length;++i){\");\n            genVerifyKey(gen, field, \"k[i]\");\n            genVerifyValue(gen, field, i, ref + \"[k[i]]\")(\"}\");\n        // repeated fields\n        } else if (field.repeated) {\n            gen(\"if(!Array.isArray(%s))\", ref)(\"return%j\", invalid(field, \"array\"))(\"for(var i=0;i<%s.length;++i){\", ref);\n            genVerifyValue(gen, field, i, ref + \"[i]\")(\"}\");\n        // required or present fields\n        } else {\n            if (field.partOf) {\n                var oneofProp = util.safeProp(field.partOf.name);\n                if (seenFirstField[field.partOf.name] === 1) gen(\"if(p%s===1)\", oneofProp)(\"return%j\", field.partOf.name + \": multiple values\");\n                seenFirstField[field.partOf.name] = 1;\n                gen(\"p%s=1\", oneofProp);\n            }\n            genVerifyValue(gen, field, i, ref);\n        }\n        if (field.optional) gen(\"}\");\n    }\n    return gen(\"return null\");\n/* eslint-enable no-unexpected-multiline */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdmVyaWZpZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxPQUFZQyxtQkFBT0EsQ0FBQywyREFBUSxHQUM1QkMsT0FBWUQsbUJBQU9BLENBQUMsMkRBQVE7QUFFaEMsU0FBU0UsUUFBUUMsS0FBSyxFQUFFQyxRQUFRO0lBQzVCLE9BQU9ELE1BQU1FLElBQUksR0FBRyxPQUFPRCxXQUFZRCxDQUFBQSxNQUFNRyxRQUFRLElBQUlGLGFBQWEsVUFBVSxPQUFPRCxNQUFNSSxHQUFHLElBQUlILGFBQWEsV0FBVyxRQUFNRCxNQUFNSyxPQUFPLEdBQUMsTUFBTSxFQUFDLElBQUs7QUFDaEs7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNDLGVBQWVDLEdBQUcsRUFBRVAsS0FBSyxFQUFFUSxVQUFVLEVBQUVDLEdBQUc7SUFDL0MsMENBQTBDLEdBQzFDLElBQUlULE1BQU1VLFlBQVksRUFBRTtRQUNwQixJQUFJVixNQUFNVSxZQUFZLFlBQVlkLE1BQU07WUFBRVcsSUFDckMsZUFBZUUsS0FDWCxZQUNJLFlBQVlWLFFBQVFDLE9BQU87WUFDcEMsSUFBSyxJQUFJVyxPQUFPQyxPQUFPRCxJQUFJLENBQUNYLE1BQU1VLFlBQVksQ0FBQ0csTUFBTSxHQUFHQyxJQUFJLEdBQUdBLElBQUlILEtBQUtJLE1BQU0sRUFBRSxFQUFFRCxFQUFHUCxJQUNoRixZQUFZUCxNQUFNVSxZQUFZLENBQUNHLE1BQU0sQ0FBQ0YsSUFBSSxDQUFDRyxFQUFFLENBQUM7WUFDbkRQLElBQ1MsU0FDUjtRQUNMLE9BQU87WUFDSEEsSUFDQyxLQUNJLCtCQUErQkMsWUFBWUMsS0FDM0MsU0FDSSxjQUFjVCxNQUFNRSxJQUFJLEdBQUcsS0FDbkM7UUFDTDtJQUNKLE9BQU87UUFDSCxPQUFRRixNQUFNZ0IsSUFBSTtZQUNkLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7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QixNQUFNNkIsTUFBTSxDQUFDM0IsSUFBSSxDQUFDLEtBQUssR0FBR0ssSUFDaEQsZUFBZXVCLFdBQ1gsWUFBWTlCLE1BQU02QixNQUFNLENBQUMzQixJQUFJLEdBQUc7Z0JBQ2pDb0IsY0FBYyxDQUFDdEIsTUFBTTZCLE1BQU0sQ0FBQzNCLElBQUksQ0FBQyxHQUFHO2dCQUNwQ0ssSUFDSCxTQUFTdUI7WUFDVjtZQUNBeEIsZUFBZUMsS0FBS1AsT0FBT3VCLEdBQUdkO1FBQ2xDO1FBQ0EsSUFBSVQsTUFBTTRCLFFBQVEsRUFBRXJCLElBQ25CO0lBQ0w7SUFDQSxPQUFPQSxJQUNOO0FBQ0QseUNBQXlDLEdBQzdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy92ZXJpZmllci5qcz81ZDMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB2ZXJpZmllcjtcblxudmFyIEVudW0gICAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuZnVuY3Rpb24gaW52YWxpZChmaWVsZCwgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmllbGQubmFtZSArIFwiOiBcIiArIGV4cGVjdGVkICsgKGZpZWxkLnJlcGVhdGVkICYmIGV4cGVjdGVkICE9PSBcImFycmF5XCIgPyBcIltdXCIgOiBmaWVsZC5tYXAgJiYgZXhwZWN0ZWQgIT09IFwib2JqZWN0XCIgPyBcIntrOlwiK2ZpZWxkLmtleVR5cGUrXCJ9XCIgOiBcIlwiKSArIFwiIGV4cGVjdGVkXCI7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGFydGlhbCB2YWx1ZSB2ZXJpZmllci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWYgVmFyaWFibGUgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBmaWVsZEluZGV4LCByZWYpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xuICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUpIHtcbiAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIHsgZ2VuXG4gICAgICAgICAgICAoXCJzd2l0Y2goJXMpe1wiLCByZWYpXG4gICAgICAgICAgICAgICAgKFwiZGVmYXVsdDpcIilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJlbnVtIHZhbHVlXCIpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzKSwgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSBnZW5cbiAgICAgICAgICAgICAgICAoXCJjYXNlICVpOlwiLCBmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzW2tleXNbal1dKTtcbiAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAoXCJicmVha1wiKVxuICAgICAgICAgICAgKFwifVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgKFwie1wiKVxuICAgICAgICAgICAgICAgIChcInZhciBlPXR5cGVzWyVpXS52ZXJpZnkoJXMpO1wiLCBmaWVsZEluZGV4LCByZWYpXG4gICAgICAgICAgICAgICAgKFwiaWYoZSlcIilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWorZVwiLCBmaWVsZC5uYW1lICsgXCIuXCIpXG4gICAgICAgICAgICAoXCJ9XCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkMzJcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoIXV0aWwuaXNJbnRlZ2VyKCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXJcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwidWludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCF1dGlsLmlzSW50ZWdlciglcykmJiEoJXMmJnV0aWwuaXNJbnRlZ2VyKCVzLmxvdykmJnV0aWwuaXNJbnRlZ2VyKCVzLmhpZ2gpKSlcIiwgcmVmLCByZWYsIHJlZiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXJ8TG9uZ1wiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkb3VibGVcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYodHlwZW9mICVzIT09XFxcIm51bWJlclxcXCIpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJudW1iZXJcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYodHlwZW9mICVzIT09XFxcImJvb2xlYW5cXFwiKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYm9vbGVhblwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCF1dGlsLmlzU3RyaW5nKCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcInN0cmluZ1wiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoISglcyYmdHlwZW9mICVzLmxlbmd0aD09PVxcXCJudW1iZXJcXFwifHx1dGlsLmlzU3RyaW5nKCVzKSkpXCIsIHJlZiwgcmVmLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYnVmZmVyXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VuO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIGtleSB2ZXJpZmllci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtzdHJpbmd9IHJlZiBWYXJpYWJsZSByZWZlcmVuY2VcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGdlblZlcmlmeUtleShnZW4sIGZpZWxkLCByZWYpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xuICAgIHN3aXRjaCAoZmllbGQua2V5VHlwZSkge1xuICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICBjYXNlIFwic2ludDMyXCI6XG4gICAgICAgIGNhc2UgXCJmaXhlZDMyXCI6XG4gICAgICAgIGNhc2UgXCJzZml4ZWQzMlwiOiBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmtleTMyUmUudGVzdCglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXIga2V5XCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICBjYXNlIFwic2ludDY0XCI6XG4gICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6XG4gICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOiBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmtleTY0UmUudGVzdCglcykpXCIsIHJlZikgLy8gc2VlIGNvbW1lbnQgYWJvdmU6IHggaXMgb2ssIGQgaXMgbm90XG4gICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJpbnRlZ2VyfExvbmcga2V5XCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYm9vbFwiOiBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmtleTJSZS50ZXN0KCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYm9vbGVhbiBrZXlcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBnZW47XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHZlcmlmaWVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHZlcmlmaWVyKG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cblxuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wibVwiXSwgbXR5cGUubmFtZSArIFwiJHZlcmlmeVwiKVxuICAgIChcImlmKHR5cGVvZiBtIT09XFxcIm9iamVjdFxcXCJ8fG09PT1udWxsKVwiKVxuICAgICAgICAoXCJyZXR1cm4lalwiLCBcIm9iamVjdCBleHBlY3RlZFwiKTtcbiAgICB2YXIgb25lb2ZzID0gbXR5cGUub25lb2ZzQXJyYXksXG4gICAgICAgIHNlZW5GaXJzdEZpZWxkID0ge307XG4gICAgaWYgKG9uZW9mcy5sZW5ndGgpIGdlblxuICAgIChcInZhciBwPXt9XCIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAvKiBpbml0aWFsaXplcyAqLyBtdHlwZS5maWVsZHNBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgPSBtdHlwZS5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZSgpLFxuICAgICAgICAgICAgcmVmICAgPSBcIm1cIiArIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XG5cbiAgICAgICAgaWYgKGZpZWxkLm9wdGlvbmFsKSBnZW5cbiAgICAgICAgKFwiaWYoJXMhPW51bGwmJm0uaGFzT3duUHJvcGVydHkoJWopKXtcIiwgcmVmLCBmaWVsZC5uYW1lKTsgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxuXG4gICAgICAgIC8vIG1hcCBmaWVsZHNcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkgeyBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmlzT2JqZWN0KCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwib2JqZWN0XCIpKVxuICAgICAgICAgICAgKFwidmFyIGs9T2JqZWN0LmtleXMoJXMpXCIsIHJlZilcbiAgICAgICAgICAgIChcImZvcih2YXIgaT0wO2k8ay5sZW5ndGg7KytpKXtcIik7XG4gICAgICAgICAgICAgICAgZ2VuVmVyaWZ5S2V5KGdlbiwgZmllbGQsIFwia1tpXVwiKTtcbiAgICAgICAgICAgICAgICBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBpLCByZWYgKyBcIltrW2ldXVwiKVxuICAgICAgICAgICAgKFwifVwiKTtcblxuICAgICAgICAvLyByZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgeyBnZW5cbiAgICAgICAgICAgIChcImlmKCFBcnJheS5pc0FycmF5KCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYXJyYXlcIikpXG4gICAgICAgICAgICAoXCJmb3IodmFyIGk9MDtpPCVzLmxlbmd0aDsrK2kpe1wiLCByZWYpO1xuICAgICAgICAgICAgICAgIGdlblZlcmlmeVZhbHVlKGdlbiwgZmllbGQsIGksIHJlZiArIFwiW2ldXCIpXG4gICAgICAgICAgICAoXCJ9XCIpO1xuXG4gICAgICAgIC8vIHJlcXVpcmVkIG9yIHByZXNlbnQgZmllbGRzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZmllbGQucGFydE9mKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9uZW9mUHJvcCA9IHV0aWwuc2FmZVByb3AoZmllbGQucGFydE9mLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChzZWVuRmlyc3RGaWVsZFtmaWVsZC5wYXJ0T2YubmFtZV0gPT09IDEpIGdlblxuICAgICAgICAgICAgKFwiaWYocCVzPT09MSlcIiwgb25lb2ZQcm9wKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGZpZWxkLnBhcnRPZi5uYW1lICsgXCI6IG11bHRpcGxlIHZhbHVlc1wiKTtcbiAgICAgICAgICAgICAgICBzZWVuRmlyc3RGaWVsZFtmaWVsZC5wYXJ0T2YubmFtZV0gPSAxO1xuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgKFwicCVzPTFcIiwgb25lb2ZQcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlblZlcmlmeVZhbHVlKGdlbiwgZmllbGQsIGksIHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkLm9wdGlvbmFsKSBnZW5cbiAgICAgICAgKFwifVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlblxuICAgIChcInJldHVybiBudWxsXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn0iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInZlcmlmaWVyIiwiRW51bSIsInJlcXVpcmUiLCJ1dGlsIiwiaW52YWxpZCIsImZpZWxkIiwiZXhwZWN0ZWQiLCJuYW1lIiwicmVwZWF0ZWQiLCJtYXAiLCJrZXlUeXBlIiwiZ2VuVmVyaWZ5VmFsdWUiLCJnZW4iLCJmaWVsZEluZGV4IiwicmVmIiwicmVzb2x2ZWRUeXBlIiwia2V5cyIsIk9iamVjdCIsInZhbHVlcyIsImoiLCJsZW5ndGgiLCJ0eXBlIiwiZ2VuVmVyaWZ5S2V5IiwibXR5cGUiLCJjb2RlZ2VuIiwib25lb2ZzIiwib25lb2ZzQXJyYXkiLCJzZWVuRmlyc3RGaWVsZCIsImkiLCJmaWVsZHNBcnJheSIsIl9maWVsZHNBcnJheSIsInJlc29sdmUiLCJzYWZlUHJvcCIsIm9wdGlvbmFsIiwicGFydE9mIiwib25lb2ZQcm9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/verifier.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/wrappers.js":
/*!*************************************************!*\
  !*** ./node_modules/protobufjs/src/wrappers.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Wrappers for common types.\n * @type {Object.<string,IWrapper>}\n * @const\n */ var wrappers = exports;\nvar Message = __webpack_require__(/*! ./message */ \"(ssr)/./node_modules/protobufjs/src/message.js\");\n/**\n * From object converter part of an {@link IWrapper}.\n * @typedef WrapperFromObjectConverter\n * @type {function}\n * @param {Object.<string,*>} object Plain object\n * @returns {Message<{}>} Message instance\n * @this Type\n */ /**\n * To object converter part of an {@link IWrapper}.\n * @typedef WrapperToObjectConverter\n * @type {function}\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @this Type\n */ /**\n * Common type wrapper part of {@link wrappers}.\n * @interface IWrapper\n * @property {WrapperFromObjectConverter} [fromObject] From object converter\n * @property {WrapperToObjectConverter} [toObject] To object converter\n */ // Custom wrapper for Any\nwrappers[\".google.protobuf.Any\"] = {\n    fromObject: function(object) {\n        // unwrap value type if mapped\n        if (object && object[\"@type\"]) {\n            // Only use fully qualified type name after the last '/'\n            var name = object[\"@type\"].substring(object[\"@type\"].lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */ if (type) {\n                // type_url does not accept leading \".\"\n                var type_url = object[\"@type\"].charAt(0) === \".\" ? object[\"@type\"].slice(1) : object[\"@type\"];\n                // type_url prefix is optional, but path seperator is required\n                if (type_url.indexOf(\"/\") === -1) {\n                    type_url = \"/\" + type_url;\n                }\n                return this.create({\n                    type_url: type_url,\n                    value: type.encode(type.fromObject(object)).finish()\n                });\n            }\n        }\n        return this.fromObject(object);\n    },\n    toObject: function(message, options) {\n        // Default prefix\n        var googleApi = \"type.googleapis.com/\";\n        var prefix = \"\";\n        var name = \"\";\n        // decode value if requested and unmapped\n        if (options && options.json && message.type_url && message.value) {\n            // Only use fully qualified type name after the last '/'\n            name = message.type_url.substring(message.type_url.lastIndexOf(\"/\") + 1);\n            // Separate the prefix used\n            prefix = message.type_url.substring(0, message.type_url.lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */ if (type) message = type.decode(message.value);\n        }\n        // wrap value if unmapped\n        if (!(message instanceof this.ctor) && message instanceof Message) {\n            var object = message.$type.toObject(message, options);\n            var messageName = message.$type.fullName[0] === \".\" ? message.$type.fullName.slice(1) : message.$type.fullName;\n            // Default to type.googleapis.com prefix if no prefix is used\n            if (prefix === \"\") {\n                prefix = googleApi;\n            }\n            name = prefix + messageName;\n            object[\"@type\"] = name;\n            return object;\n        }\n        return this.toObject(message, options);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JhcHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYjs7OztDQUlDLEdBQ0QsSUFBSUEsV0FBV0M7QUFFZixJQUFJQyxVQUFVQyxtQkFBT0EsQ0FBQyxpRUFBVztBQUVqQzs7Ozs7OztDQU9DLEdBRUQ7Ozs7Ozs7O0NBUUMsR0FFRDs7Ozs7Q0FLQyxHQUVELHlCQUF5QjtBQUN6QkgsUUFBUSxDQUFDLHVCQUF1QixHQUFHO0lBRS9CSSxZQUFZLFNBQVNDLE1BQU07UUFFdkIsOEJBQThCO1FBQzlCLElBQUlBLFVBQVVBLE1BQU0sQ0FBQyxRQUFRLEVBQUU7WUFDMUIsd0RBQXdEO1lBQ3pELElBQUlDLE9BQU9ELE1BQU0sQ0FBQyxRQUFRLENBQUNFLFNBQVMsQ0FBQ0YsTUFBTSxDQUFDLFFBQVEsQ0FBQ0csV0FBVyxDQUFDLE9BQU87WUFDeEUsSUFBSUMsT0FBTyxJQUFJLENBQUNDLE1BQU0sQ0FBQ0o7WUFDdkIsd0JBQXdCLEdBQ3hCLElBQUlHLE1BQU07Z0JBQ04sdUNBQXVDO2dCQUN2QyxJQUFJRSxXQUFXTixNQUFNLENBQUMsUUFBUSxDQUFDTyxNQUFNLENBQUMsT0FBTyxNQUN6Q1AsTUFBTSxDQUFDLFFBQVEsQ0FBQ1EsS0FBSyxDQUFDLEtBQUtSLE1BQU0sQ0FBQyxRQUFRO2dCQUM5Qyw4REFBOEQ7Z0JBQzlELElBQUlNLFNBQVNHLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRztvQkFDOUJILFdBQVcsTUFBTUE7Z0JBQ3JCO2dCQUNBLE9BQU8sSUFBSSxDQUFDSSxNQUFNLENBQUM7b0JBQ2ZKLFVBQVVBO29CQUNWSyxPQUFPUCxLQUFLUSxNQUFNLENBQUNSLEtBQUtMLFVBQVUsQ0FBQ0MsU0FBU2EsTUFBTTtnQkFDdEQ7WUFDSjtRQUNKO1FBRUEsT0FBTyxJQUFJLENBQUNkLFVBQVUsQ0FBQ0M7SUFDM0I7SUFFQWMsVUFBVSxTQUFTQyxPQUFPLEVBQUVDLE9BQU87UUFFL0IsaUJBQWlCO1FBQ2pCLElBQUlDLFlBQVk7UUFDaEIsSUFBSUMsU0FBUztRQUNiLElBQUlqQixPQUFPO1FBRVgseUNBQXlDO1FBQ3pDLElBQUllLFdBQVdBLFFBQVFHLElBQUksSUFBSUosUUFBUVQsUUFBUSxJQUFJUyxRQUFRSixLQUFLLEVBQUU7WUFDOUQsd0RBQXdEO1lBQ3hEVixPQUFPYyxRQUFRVCxRQUFRLENBQUNKLFNBQVMsQ0FBQ2EsUUFBUVQsUUFBUSxDQUFDSCxXQUFXLENBQUMsT0FBTztZQUN0RSwyQkFBMkI7WUFDM0JlLFNBQVNILFFBQVFULFFBQVEsQ0FBQ0osU0FBUyxDQUFDLEdBQUdhLFFBQVFULFFBQVEsQ0FBQ0gsV0FBVyxDQUFDLE9BQU87WUFDM0UsSUFBSUMsT0FBTyxJQUFJLENBQUNDLE1BQU0sQ0FBQ0o7WUFDdkIsd0JBQXdCLEdBQ3hCLElBQUlHLE1BQ0FXLFVBQVVYLEtBQUtnQixNQUFNLENBQUNMLFFBQVFKLEtBQUs7UUFDM0M7UUFFQSx5QkFBeUI7UUFDekIsSUFBSSxDQUFFSSxDQUFBQSxtQkFBbUIsSUFBSSxDQUFDTSxJQUFJLEtBQUtOLG1CQUFtQmxCLFNBQVM7WUFDL0QsSUFBSUcsU0FBU2UsUUFBUU8sS0FBSyxDQUFDUixRQUFRLENBQUNDLFNBQVNDO1lBQzdDLElBQUlPLGNBQWNSLFFBQVFPLEtBQUssQ0FBQ0UsUUFBUSxDQUFDLEVBQUUsS0FBSyxNQUM1Q1QsUUFBUU8sS0FBSyxDQUFDRSxRQUFRLENBQUNoQixLQUFLLENBQUMsS0FBS08sUUFBUU8sS0FBSyxDQUFDRSxRQUFRO1lBQzVELDZEQUE2RDtZQUM3RCxJQUFJTixXQUFXLElBQUk7Z0JBQ2ZBLFNBQVNEO1lBQ2I7WUFDQWhCLE9BQU9pQixTQUFTSztZQUNoQnZCLE1BQU0sQ0FBQyxRQUFRLEdBQUdDO1lBQ2xCLE9BQU9EO1FBQ1g7UUFFQSxPQUFPLElBQUksQ0FBQ2MsUUFBUSxDQUFDQyxTQUFTQztJQUNsQztBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cmFwcGVycy5qcz8zZWY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFdyYXBwZXJzIGZvciBjb21tb24gdHlwZXMuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsSVdyYXBwZXI+fVxuICogQGNvbnN0XG4gKi9cbnZhciB3cmFwcGVycyA9IGV4cG9ydHM7XG5cbnZhciBNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZVwiKTtcblxuLyoqXG4gKiBGcm9tIG9iamVjdCBjb252ZXJ0ZXIgcGFydCBvZiBhbiB7QGxpbmsgSVdyYXBwZXJ9LlxuICogQHR5cGVkZWYgV3JhcHBlckZyb21PYmplY3RDb252ZXJ0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAqIEByZXR1cm5zIHtNZXNzYWdlPHt9Pn0gTWVzc2FnZSBpbnN0YW5jZVxuICogQHRoaXMgVHlwZVxuICovXG5cbi8qKlxuICogVG8gb2JqZWN0IGNvbnZlcnRlciBwYXJ0IG9mIGFuIHtAbGluayBJV3JhcHBlcn0uXG4gKiBAdHlwZWRlZiBXcmFwcGVyVG9PYmplY3RDb252ZXJ0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7TWVzc2FnZTx7fT59IG1lc3NhZ2UgTWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtJQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gKiBAdGhpcyBUeXBlXG4gKi9cblxuLyoqXG4gKiBDb21tb24gdHlwZSB3cmFwcGVyIHBhcnQgb2Yge0BsaW5rIHdyYXBwZXJzfS5cbiAqIEBpbnRlcmZhY2UgSVdyYXBwZXJcbiAqIEBwcm9wZXJ0eSB7V3JhcHBlckZyb21PYmplY3RDb252ZXJ0ZXJ9IFtmcm9tT2JqZWN0XSBGcm9tIG9iamVjdCBjb252ZXJ0ZXJcbiAqIEBwcm9wZXJ0eSB7V3JhcHBlclRvT2JqZWN0Q29udmVydGVyfSBbdG9PYmplY3RdIFRvIG9iamVjdCBjb252ZXJ0ZXJcbiAqL1xuXG4vLyBDdXN0b20gd3JhcHBlciBmb3IgQW55XG53cmFwcGVyc1tcIi5nb29nbGUucHJvdG9idWYuQW55XCJdID0ge1xuXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG5cbiAgICAgICAgLy8gdW53cmFwIHZhbHVlIHR5cGUgaWYgbWFwcGVkXG4gICAgICAgIGlmIChvYmplY3QgJiYgb2JqZWN0W1wiQHR5cGVcIl0pIHtcbiAgICAgICAgICAgICAvLyBPbmx5IHVzZSBmdWxseSBxdWFsaWZpZWQgdHlwZSBuYW1lIGFmdGVyIHRoZSBsYXN0ICcvJ1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBvYmplY3RbXCJAdHlwZVwiXS5zdWJzdHJpbmcob2JqZWN0W1wiQHR5cGVcIl0ubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMubG9va3VwKG5hbWUpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gdHlwZV91cmwgZG9lcyBub3QgYWNjZXB0IGxlYWRpbmcgXCIuXCJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZV91cmwgPSBvYmplY3RbXCJAdHlwZVwiXS5jaGFyQXQoMCkgPT09IFwiLlwiID9cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W1wiQHR5cGVcIl0uc2xpY2UoMSkgOiBvYmplY3RbXCJAdHlwZVwiXTtcbiAgICAgICAgICAgICAgICAvLyB0eXBlX3VybCBwcmVmaXggaXMgb3B0aW9uYWwsIGJ1dCBwYXRoIHNlcGVyYXRvciBpcyByZXF1aXJlZFxuICAgICAgICAgICAgICAgIGlmICh0eXBlX3VybC5pbmRleE9mKFwiL1wiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZV91cmwgPSBcIi9cIiArIHR5cGVfdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlX3VybDogdHlwZV91cmwsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlLmVuY29kZSh0eXBlLmZyb21PYmplY3Qob2JqZWN0KSkuZmluaXNoKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21PYmplY3Qob2JqZWN0KTtcbiAgICB9LFxuXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKG1lc3NhZ2UsIG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBEZWZhdWx0IHByZWZpeFxuICAgICAgICB2YXIgZ29vZ2xlQXBpID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tL1wiO1xuICAgICAgICB2YXIgcHJlZml4ID0gXCJcIjtcbiAgICAgICAgdmFyIG5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8vIGRlY29kZSB2YWx1ZSBpZiByZXF1ZXN0ZWQgYW5kIHVubWFwcGVkXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuanNvbiAmJiBtZXNzYWdlLnR5cGVfdXJsICYmIG1lc3NhZ2UudmFsdWUpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdXNlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIG5hbWUgYWZ0ZXIgdGhlIGxhc3QgJy8nXG4gICAgICAgICAgICBuYW1lID0gbWVzc2FnZS50eXBlX3VybC5zdWJzdHJpbmcobWVzc2FnZS50eXBlX3VybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICAgICAgICAgIC8vIFNlcGFyYXRlIHRoZSBwcmVmaXggdXNlZFxuICAgICAgICAgICAgcHJlZml4ID0gbWVzc2FnZS50eXBlX3VybC5zdWJzdHJpbmcoMCwgbWVzc2FnZS50eXBlX3VybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5sb29rdXAobmFtZSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IHR5cGUuZGVjb2RlKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd3JhcCB2YWx1ZSBpZiB1bm1hcHBlZFxuICAgICAgICBpZiAoIShtZXNzYWdlIGluc3RhbmNlb2YgdGhpcy5jdG9yKSAmJiBtZXNzYWdlIGluc3RhbmNlb2YgTWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IG1lc3NhZ2UuJHR5cGUudG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZU5hbWUgPSBtZXNzYWdlLiR0eXBlLmZ1bGxOYW1lWzBdID09PSBcIi5cIiA/XG4gICAgICAgICAgICAgICAgbWVzc2FnZS4kdHlwZS5mdWxsTmFtZS5zbGljZSgxKSA6IG1lc3NhZ2UuJHR5cGUuZnVsbE5hbWU7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIHR5cGUuZ29vZ2xlYXBpcy5jb20gcHJlZml4IGlmIG5vIHByZWZpeCBpcyB1c2VkXG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gZ29vZ2xlQXBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZSA9IHByZWZpeCArIG1lc3NhZ2VOYW1lO1xuICAgICAgICAgICAgb2JqZWN0W1wiQHR5cGVcIl0gPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOlsid3JhcHBlcnMiLCJleHBvcnRzIiwiTWVzc2FnZSIsInJlcXVpcmUiLCJmcm9tT2JqZWN0Iiwib2JqZWN0IiwibmFtZSIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwidHlwZSIsImxvb2t1cCIsInR5cGVfdXJsIiwiY2hhckF0Iiwic2xpY2UiLCJpbmRleE9mIiwiY3JlYXRlIiwidmFsdWUiLCJlbmNvZGUiLCJmaW5pc2giLCJ0b09iamVjdCIsIm1lc3NhZ2UiLCJvcHRpb25zIiwiZ29vZ2xlQXBpIiwicHJlZml4IiwianNvbiIsImRlY29kZSIsImN0b3IiLCIkdHlwZSIsIm1lc3NhZ2VOYW1lIiwiZnVsbE5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/wrappers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Writer;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/protobufjs/src/util/minimal.js\");\nvar BufferWriter; // cyclic\nvar LongBits = util.LongBits, base64 = util.base64, utf8 = util.utf8;\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */ function Op(fn, len, val) {\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */ this.fn = fn;\n    /**\n     * Value byte length.\n     * @type {number}\n     */ this.len = len;\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */ this.next = undefined;\n    /**\n     * Value to write.\n     * @type {*}\n     */ this.val = val; // type varies\n}\n/* istanbul ignore next */ function noop() {} // eslint-disable-line no-empty-function\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */ function State(writer) {\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */ this.head = writer.head;\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */ this.tail = writer.tail;\n    /**\n     * Current buffer length.\n     * @type {number}\n     */ this.len = writer.len;\n    /**\n     * Next state.\n     * @type {State|null}\n     */ this.next = writer.states;\n}\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */ function Writer() {\n    /**\n     * Current length.\n     * @type {number}\n     */ this.len = 0;\n    /**\n     * Operations head.\n     * @type {Object}\n     */ this.head = new Op(noop, 0, 0);\n    /**\n     * Operations tail\n     * @type {Object}\n     */ this.tail = this.head;\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */ this.states = null;\n// When a value is written, the writer calculates its byte length and puts it into a linked\n// list of operations to perform when finish() is called. This both allows us to allocate\n// buffers of the exact required size and reduces the amount of work we have to do compared\n// to first calculating over objects and then encoding over objects. In our case, the encoding\n// part is just a linked list walk calling operations with already prepared values.\n}\nvar create = function create() {\n    return util.Buffer ? function create_buffer_setup() {\n        return (Writer.create = function create_buffer() {\n            return new BufferWriter();\n        })();\n    } : function create_array() {\n        return new Writer();\n    };\n};\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */ Writer.create = create();\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */ Writer.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */ if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */ Writer.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\nfunction writeVarint32(val, buf, pos) {\n    while(val > 127){\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */ function VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;\n    return this;\n};\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.int32 = function write_int32(value) {\n    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n     : this.uint32(value);\n};\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\nfunction writeVarint64(val, buf, pos) {\n    while(val.hi){\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while(val.lo > 127){\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.int64 = Writer.prototype.uint64;\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\nfunction writeFixed32(val, buf, pos) {\n    buf[pos] = val & 255;\n    buf[pos + 1] = val >>> 8 & 255;\n    buf[pos + 2] = val >>> 16 & 255;\n    buf[pos + 3] = val >>> 24;\n}\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.sfixed32 = Writer.prototype.fixed32;\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.sfixed64 = Writer.prototype.fixed64;\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\nvar writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n    buf.set(val, pos); // also works for plain array values\n} : function writeBytes_for(val, buf, pos) {\n    for(var i = 0; i < val.length; ++i)buf[pos + i] = val[i];\n};\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */ Writer.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len) return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);\n};\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */ Writer.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */ Writer.prototype.reset = function reset() {\n    if (this.states) {\n        this.head = this.states.head;\n        this.tail = this.states.tail;\n        this.len = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len = 0;\n    }\n    return this;\n};\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */ Writer.prototype.ldelim = function ldelim() {\n    var head = this.head, tail = this.tail, len = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */ Writer.prototype.finish = function finish() {\n    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;\n    while(head){\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsT0FBWUMsbUJBQU9BLENBQUMsMkVBQWdCO0FBRXhDLElBQUlDLGNBQWMsU0FBUztBQUUzQixJQUFJQyxXQUFZSCxLQUFLRyxRQUFRLEVBQ3pCQyxTQUFZSixLQUFLSSxNQUFNLEVBQ3ZCQyxPQUFZTCxLQUFLSyxJQUFJO0FBRXpCOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0MsR0FBR0MsRUFBRSxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFFcEI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDRixFQUFFLEdBQUdBO0lBRVY7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxHQUFHLEdBQUdBO0lBRVg7OztLQUdDLEdBQ0QsSUFBSSxDQUFDRSxJQUFJLEdBQUdDO0lBRVo7OztLQUdDLEdBQ0QsSUFBSSxDQUFDRixHQUFHLEdBQUdBLEtBQUssY0FBYztBQUNsQztBQUVBLHdCQUF3QixHQUN4QixTQUFTRyxRQUFRLEVBQUUsd0NBQXdDO0FBRTNEOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxNQUFNQyxNQUFNO0lBRWpCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsSUFBSSxHQUFHRCxPQUFPQyxJQUFJO0lBRXZCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsSUFBSSxHQUFHRixPQUFPRSxJQUFJO0lBRXZCOzs7S0FHQyxHQUNELElBQUksQ0FBQ1IsR0FBRyxHQUFHTSxPQUFPTixHQUFHO0lBRXJCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0UsSUFBSSxHQUFHSSxPQUFPRyxNQUFNO0FBQzdCO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNsQjtJQUVMOzs7S0FHQyxHQUNELElBQUksQ0FBQ1MsR0FBRyxHQUFHO0lBRVg7OztLQUdDLEdBQ0QsSUFBSSxDQUFDTyxJQUFJLEdBQUcsSUFBSVQsR0FBR00sTUFBTSxHQUFHO0lBRTVCOzs7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Ly9teS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlci5qcz83NjUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBXcml0ZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJXcml0ZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICBiYXNlNjQgICAgPSB1dGlsLmJhc2U2NCxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBVaW50OEFycmF5LCBudW1iZXIpfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBPcChmbiwgbGVuLCB2YWwpIHtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9XG4gICAgICovXG4gICAgdGhpcy5mbiA9IGZuO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgYnl0ZSBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHRoaXMudmFsID0gdmFsOyAvLyB0eXBlIHZhcmllc1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBzdGF0ZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQ29waWVkIHdyaXRlciBzdGF0ZS5cbiAqIEBtZW1iZXJvZiBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXcml0ZXJ9IHdyaXRlciBXcml0ZXIgdG8gY29weSBzdGF0ZSBmcm9tXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFN0YXRlKHdyaXRlcikge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBoZWFkLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gd3JpdGVyLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHRhaWwuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB3cml0ZXIudGFpbDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gd3JpdGVyLmxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgc3RhdGUuXG4gICAgICogQHR5cGUge1N0YXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gd3JpdGVyLnN0YXRlcztcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdyaXRlcigpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSAwO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyBoZWFkLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyB0YWlsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBMaW5rZWQgZm9ya2VkIHN0YXRlcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBudWxsO1xuXG4gICAgLy8gV2hlbiBhIHZhbHVlIGlzIHdyaXR0ZW4sIHRoZSB3cml0ZXIgY2FsY3VsYXRlcyBpdHMgYnl0ZSBsZW5ndGggYW5kIHB1dHMgaXQgaW50byBhIGxpbmtlZFxuICAgIC8vIGxpc3Qgb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtIHdoZW4gZmluaXNoKCkgaXMgY2FsbGVkLiBUaGlzIGJvdGggYWxsb3dzIHVzIHRvIGFsbG9jYXRlXG4gICAgLy8gYnVmZmVycyBvZiB0aGUgZXhhY3QgcmVxdWlyZWQgc2l6ZSBhbmQgcmVkdWNlcyB0aGUgYW1vdW50IG9mIHdvcmsgd2UgaGF2ZSB0byBkbyBjb21wYXJlZFxuICAgIC8vIHRvIGZpcnN0IGNhbGN1bGF0aW5nIG92ZXIgb2JqZWN0cyBhbmQgdGhlbiBlbmNvZGluZyBvdmVyIG9iamVjdHMuIEluIG91ciBjYXNlLCB0aGUgZW5jb2RpbmdcbiAgICAvLyBwYXJ0IGlzIGp1c3QgYSBsaW5rZWQgbGlzdCB3YWxrIGNhbGxpbmcgb3BlcmF0aW9ucyB3aXRoIGFscmVhZHkgcHJlcGFyZWQgdmFsdWVzLlxufVxuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFdyaXRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIoKTtcbiAgICAgICAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB3cml0ZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ8V3JpdGVyfSBBIHtAbGluayBCdWZmZXJXcml0ZXJ9IHdoZW4gQnVmZmVycyBhcmUgc3VwcG9ydGVkLCBvdGhlcndpc2UgYSB7QGxpbmsgV3JpdGVyfVxuICovXG5Xcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cbi8qKlxuICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyXG4gKi9cbldyaXRlci5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUpIHtcbiAgICByZXR1cm4gbmV3IHV0aWwuQXJyYXkoc2l6ZSk7XG59O1xuXG4vLyBVc2UgVWludDhBcnJheSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlciwganVzdCBsaWtlIG5vZGUgZG9lcyB3aXRoIGJ1ZmZlcnNcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAodXRpbC5BcnJheSAhPT0gQXJyYXkpXG4gICAgV3JpdGVyLmFsbG9jID0gdXRpbC5wb29sKFdyaXRlci5hbGxvYywgdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpO1xuXG4vKipcbiAqIFB1c2hlcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlLlxuICogQHBhcmFtIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEBwcml2YXRlXG4gKi9cbldyaXRlci5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiBwdXNoKGZuLCBsZW4sIHZhbCkge1xuICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IE9wKGZuLCBsZW4sIHZhbCk7XG4gICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVCeXRlKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcbn1cblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbCA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwgPj4+PSA3O1xuICAgIH1cbiAgICBidWZbcG9zXSA9IHZhbDtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHZhcmludCB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgdmFyaW50IHdyaXRlciBvcGVyYXRpb24uXG4gKiBAZXh0ZW5kcyBPcFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFZhcmludE9wKGxlbiwgdmFsKSB7XG4gICAgdGhpcy5sZW4gPSBsZW47XG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsID0gdmFsO1xufVxuXG5WYXJpbnRPcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wLnByb3RvdHlwZSk7XG5WYXJpbnRPcC5wcm90b3R5cGUuZm4gPSB3cml0ZVZhcmludDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQzMih2YWx1ZSkge1xuICAgIC8vIGhlcmUsIHRoZSBjYWxsIHRvIHRoaXMucHVzaCBoYXMgYmVlbiBpbmxpbmVkIGFuZCBhIHZhcmludCBzcGVjaWZpYyBPcCBzdWJjbGFzcyBpcyB1c2VkLlxuICAgIC8vIHVpbnQzMiBpcyBieSBmYXIgdGhlIG1vc3QgZnJlcXVlbnRseSB1c2VkIG9wZXJhdGlvbiBhbmQgYmVuZWZpdHMgc2lnbmlmaWNhbnRseSBmcm9tIHRoaXMuXG4gICAgdGhpcy5sZW4gKz0gKHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IFZhcmludE9wKFxuICAgICAgICAodmFsdWUgPSB2YWx1ZSA+Pj4gMClcbiAgICAgICAgICAgICAgICA8IDEyOCAgICAgICA/IDFcbiAgICAgICAgOiB2YWx1ZSA8IDE2Mzg0ICAgICA/IDJcbiAgICAgICAgOiB2YWx1ZSA8IDIwOTcxNTIgICA/IDNcbiAgICAgICAgOiB2YWx1ZSA8IDI2ODQzNTQ1NiA/IDRcbiAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgdmFsdWUpKS5sZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9pbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8IDBcbiAgICAgICAgPyB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIDEwLCBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKSkgLy8gMTAgYnl0ZXMgcGVyIHNwZWNcbiAgICAgICAgOiB0aGlzLnVpbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9zaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQ2NCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbC5oaSkge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSAodmFsLmxvID4+PiA3IHwgdmFsLmhpIDw8IDI1KSA+Pj4gMDtcbiAgICAgICAgdmFsLmhpID4+Pj0gNztcbiAgICB9XG4gICAgd2hpbGUgKHZhbC5sbyA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSB2YWwubG8gPj4+IDc7XG4gICAgfVxuICAgIGJ1Zltwb3MrK10gPSB2YWwubG87XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDY0ID0gV3JpdGVyLnByb3RvdHlwZS51aW50NjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDY0ID0gZnVuY3Rpb24gd3JpdGVfc2ludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKS56ekVuY29kZSgpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBib29saXNoIHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHdyaXRlX2Jvb2wodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIHZhbHVlID8gMSA6IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVGaXhlZDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICAmIDI1NTtcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCB2YWx1ZSA+Pj4gMCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0ID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmxvKS5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMuaGkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDY0ID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIGZsb2F0ICgzMiBiaXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gd3JpdGVfZmxvYXQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRmxvYXRMRSwgNCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gd3JpdGVfZG91YmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSk7XG59O1xuXG52YXIgd3JpdGVCeXRlcyA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnNldFxuICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc19zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzX2Zvcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdmFsW2ldO1xuICAgIH07XG5cbi8qKlxuICogV3JpdGVzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSB2YWx1ZSBCdWZmZXIgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAoIWxlbilcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IFdyaXRlci5hbGxvYyhsZW4gPSBiYXNlNjQubGVuZ3RoKHZhbHVlKSk7XG4gICAgICAgIGJhc2U2NC5kZWNvZGUodmFsdWUsIGJ1ZiwgMCk7XG4gICAgICAgIHZhbHVlID0gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51aW50MzIobGVuKS5fcHVzaCh3cml0ZUJ5dGVzLCBsZW4sIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmcodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRmOC5sZW5ndGgodmFsdWUpO1xuICAgIHJldHVybiBsZW5cbiAgICAgICAgPyB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHV0Zjgud3JpdGUsIGxlbiwgdmFsdWUpXG4gICAgICAgIDogdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xufTtcblxuLyoqXG4gKiBGb3JrcyB0aGlzIHdyaXRlcidzIHN0YXRlIGJ5IHB1c2hpbmcgaXQgdG8gYSBzdGFjay5cbiAqIENhbGxpbmcge0BsaW5rIFdyaXRlciNyZXNldHxyZXNldH0gb3Ige0BsaW5rIFdyaXRlciNsZGVsaW18bGRlbGltfSByZXNldHMgdGhlIHdyaXRlciB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gZm9yaygpIHtcbiAgICB0aGlzLnN0YXRlcyA9IG5ldyBTdGF0ZSh0aGlzKTtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgdGhpcy5sZW4gPSAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhpcyBpbnN0YW5jZSB0byB0aGUgbGFzdCBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuaGVhZCAgID0gdGhpcy5zdGF0ZXMuaGVhZDtcbiAgICAgICAgdGhpcy50YWlsICAgPSB0aGlzLnN0YXRlcy50YWlsO1xuICAgICAgICB0aGlzLmxlbiAgICA9IHRoaXMuc3RhdGVzLmxlbjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnN0YXRlcy5uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICAgICAgdGhpcy5sZW4gID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0byB0aGUgbGFzdCBzdGF0ZSBhbmQgYXBwZW5kcyB0aGUgZm9yayBzdGF0ZSdzIGN1cnJlbnQgd3JpdGUgbGVuZ3RoIGFzIGEgdmFyaW50IGZvbGxvd2VkIGJ5IGl0cyBvcGVyYXRpb25zLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUubGRlbGltID0gZnVuY3Rpb24gbGRlbGltKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLFxuICAgICAgICB0YWlsID0gdGhpcy50YWlsLFxuICAgICAgICBsZW4gID0gdGhpcy5sZW47XG4gICAgdGhpcy5yZXNldCgpLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy50YWlsLm5leHQgPSBoZWFkLm5leHQ7IC8vIHNraXAgbm9vcFxuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgICAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZC5uZXh0LCAvLyBza2lwIG5vb3BcbiAgICAgICAgYnVmICA9IHRoaXMuY29uc3RydWN0b3IuYWxsb2ModGhpcy5sZW4pLFxuICAgICAgICBwb3MgID0gMDtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgICBoZWFkLmZuKGhlYWQudmFsLCBidWYsIHBvcyk7XG4gICAgICAgIHBvcyArPSBoZWFkLmxlbjtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICB9XG4gICAgLy8gdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICByZXR1cm4gYnVmO1xufTtcblxuV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJXcml0ZXJfKSB7XG4gICAgQnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyXztcbiAgICBXcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIldyaXRlciIsInV0aWwiLCJyZXF1aXJlIiwiQnVmZmVyV3JpdGVyIiwiTG9uZ0JpdHMiLCJiYXNlNjQiLCJ1dGY4IiwiT3AiLCJmbiIsImxlbiIsInZhbCIsIm5leHQiLCJ1bmRlZmluZWQiLCJub29wIiwiU3RhdGUiLCJ3cml0ZXIiLCJoZWFkIiwidGFpbCIsInN0YXRlcyIsImNyZWF0ZSIsIkJ1ZmZlciIsImNyZWF0ZV9idWZmZXJfc2V0dXAiLCJjcmVhdGVfYnVmZmVyIiwiY3JlYXRlX2FycmF5IiwiYWxsb2MiLCJzaXplIiwiQXJyYXkiLCJwb29sIiwicHJvdG90eXBlIiwic3ViYXJyYXkiLCJfcHVzaCIsInB1c2giLCJ3cml0ZUJ5dGUiLCJidWYiLCJwb3MiLCJ3cml0ZVZhcmludDMyIiwiVmFyaW50T3AiLCJPYmplY3QiLCJ1aW50MzIiLCJ3cml0ZV91aW50MzIiLCJ2YWx1ZSIsImludDMyIiwid3JpdGVfaW50MzIiLCJ3cml0ZVZhcmludDY0IiwiZnJvbU51bWJlciIsInNpbnQzMiIsIndyaXRlX3NpbnQzMiIsImhpIiwibG8iLCJ1aW50NjQiLCJ3cml0ZV91aW50NjQiLCJiaXRzIiwiZnJvbSIsImxlbmd0aCIsImludDY0Iiwic2ludDY0Iiwid3JpdGVfc2ludDY0IiwienpFbmNvZGUiLCJib29sIiwid3JpdGVfYm9vbCIsIndyaXRlRml4ZWQzMiIsImZpeGVkMzIiLCJ3cml0ZV9maXhlZDMyIiwic2ZpeGVkMzIiLCJmaXhlZDY0Iiwid3JpdGVfZml4ZWQ2NCIsInNmaXhlZDY0IiwiZmxvYXQiLCJ3cml0ZV9mbG9hdCIsIndyaXRlRmxvYXRMRSIsImRvdWJsZSIsIndyaXRlX2RvdWJsZSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZUJ5dGVzIiwic2V0Iiwid3JpdGVCeXRlc19zZXQiLCJ3cml0ZUJ5dGVzX2ZvciIsImkiLCJieXRlcyIsIndyaXRlX2J5dGVzIiwiaXNTdHJpbmciLCJkZWNvZGUiLCJzdHJpbmciLCJ3cml0ZV9zdHJpbmciLCJ3cml0ZSIsImZvcmsiLCJyZXNldCIsImxkZWxpbSIsImZpbmlzaCIsImNvbnN0cnVjdG9yIiwiX2NvbmZpZ3VyZSIsIkJ1ZmZlcldyaXRlcl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/writer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = BufferWriter;\n// extends Writer\nvar Writer = __webpack_require__(/*! ./writer */ \"(ssr)/./node_modules/protobufjs/src/writer.js\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */ function BufferWriter() {\n    Writer.call(this);\n}\nBufferWriter._configure = function() {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */ BufferWriter.alloc = util._Buffer_allocUnsafe;\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n    // also works for plain array values\n    } : function writeBytesBuffer_copy(val, buf, pos) {\n        if (val.copy) val.copy(buf, pos, 0, val.length);\n        else for(var i = 0; i < val.length;)buf[pos++] = val[i++];\n    };\n};\n/**\n * @override\n */ BufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value)) value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len) this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write) buf.utf8Write(val, pos);\n    else buf.write(val, pos);\n}\n/**\n * @override\n */ BufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len) this._push(writeStringBuffer, len, value);\n    return this;\n};\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */ BufferWriter._configure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyX2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLGlCQUFpQjtBQUNqQixJQUFJQyxTQUFTQyxtQkFBT0EsQ0FBQywrREFBVTtBQUM5QkYsQ0FBQUEsYUFBYUcsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLE9BQU9FLFNBQVMsR0FBR0csV0FBVyxHQUFHTjtBQUV6RSxJQUFJTyxPQUFPTCxtQkFBT0EsQ0FBQywyRUFBZ0I7QUFFbkM7Ozs7O0NBS0MsR0FDRCxTQUFTRjtJQUNMQyxPQUFPTyxJQUFJLENBQUMsSUFBSTtBQUNwQjtBQUVBUixhQUFhUyxVQUFVLEdBQUc7SUFDdEI7Ozs7O0tBS0MsR0FDRFQsYUFBYVUsS0FBSyxHQUFHSCxLQUFLSSxtQkFBbUI7SUFFN0NYLGFBQWFZLGdCQUFnQixHQUFHTCxLQUFLTSxNQUFNLElBQUlOLEtBQUtNLE1BQU0sQ0FBQ1YsU0FBUyxZQUFZVyxjQUFjUCxLQUFLTSxNQUFNLENBQUNWLFNBQVMsQ0FBQ1ksR0FBRyxDQUFDQyxJQUFJLEtBQUssUUFDM0gsU0FBU0MscUJBQXFCQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztRQUMzQ0QsSUFBSUosR0FBRyxDQUFDRyxLQUFLRSxNQUFNLHNHQUFzRztJQUN6SCxvQ0FBb0M7SUFDdEMsSUFFRSxTQUFTQyxzQkFBc0JILEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO1FBQzVDLElBQUlGLElBQUlJLElBQUksRUFDVkosSUFBSUksSUFBSSxDQUFDSCxLQUFLQyxLQUFLLEdBQUdGLElBQUlLLE1BQU07YUFDN0IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLElBQUlLLE1BQU0sRUFDakNKLEdBQUcsQ0FBQ0MsTUFBTSxHQUFHRixHQUFHLENBQUNNLElBQUk7SUFDekI7QUFDUjtBQUdBOztDQUVDLEdBQ0R4QixhQUFhRyxTQUFTLENBQUNzQixLQUFLLEdBQUcsU0FBU0MsbUJBQW1CQyxLQUFLO0lBQzVELElBQUlwQixLQUFLcUIsUUFBUSxDQUFDRCxRQUNkQSxRQUFRcEIsS0FBS3NCLFlBQVksQ0FBQ0YsT0FBTztJQUNyQyxJQUFJRyxNQUFNSCxNQUFNSixNQUFNLEtBQUs7SUFDM0IsSUFBSSxDQUFDUSxNQUFNLENBQUNEO0lBQ1osSUFBSUEsS0FDQSxJQUFJLENBQUNFLEtBQUssQ0FBQ2hDLGFBQWFZLGdCQUFnQixFQUFFa0IsS0FBS0g7SUFDbkQsT0FBTyxJQUFJO0FBQ2Y7QUFFQSxTQUFTTSxrQkFBa0JmLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBQ3BDLElBQUlGLElBQUlLLE1BQU0sR0FBRyxJQUNiaEIsS0FBSzJCLElBQUksQ0FBQ0MsS0FBSyxDQUFDakIsS0FBS0MsS0FBS0M7U0FDekIsSUFBSUQsSUFBSWlCLFNBQVMsRUFDbEJqQixJQUFJaUIsU0FBUyxDQUFDbEIsS0FBS0U7U0FFbkJELElBQUlnQixLQUFLLENBQUNqQixLQUFLRTtBQUN2QjtBQUVBOztDQUVDLEdBQ0RwQixhQUFhRyxTQUFTLENBQUNrQyxNQUFNLEdBQUcsU0FBU0Msb0JBQW9CWCxLQUFLO0lBQzlELElBQUlHLE1BQU12QixLQUFLTSxNQUFNLENBQUMwQixVQUFVLENBQUNaO0lBQ2pDLElBQUksQ0FBQ0ksTUFBTSxDQUFDRDtJQUNaLElBQUlBLEtBQ0EsSUFBSSxDQUFDRSxLQUFLLENBQUNDLG1CQUFtQkgsS0FBS0g7SUFDdkMsT0FBTyxJQUFJO0FBQ2Y7QUFHQTs7Ozs7Q0FLQyxHQUVEM0IsYUFBYVMsVUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXByb2plY3QvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyX2J1ZmZlci5qcz8yMGQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJXcml0ZXI7XG5cbi8vIGV4dGVuZHMgV3JpdGVyXG52YXIgV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xuKEJ1ZmZlcldyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlcldyaXRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQnVmZmVyV3JpdGVyKCkge1xuICAgIFdyaXRlci5jYWxsKHRoaXMpO1xufVxuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gQnVmZmVyXG4gICAgICovXG4gICAgQnVmZmVyV3JpdGVyLmFsbG9jID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlO1xuXG4gICAgQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIgPSB1dGlsLkJ1ZmZlciAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZSA9PT0gXCJzZXRcIlxuICAgICAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gZmFzdGVyIHRoYW4gY29weSAocmVxdWlyZXMgbm9kZSA+PSA0IHdoZXJlIEJ1ZmZlcnMgZXh0ZW5kIFVpbnQ4QXJyYXkgYW5kIHNldCBpcyBwcm9wZXJseSBpbmhlcml0ZWQpXG4gICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX2NvcHkodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGlmICh2YWwuY29weSkgLy8gQnVmZmVyIHZhbHVlc1xuICAgICAgICAgICAgdmFsLmNvcHkoYnVmLCBwb3MsIDAsIHZhbC5sZW5ndGgpO1xuICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOykgLy8gcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgICAgICBidWZbcG9zKytdID0gdmFsW2krK107XG4gICAgICAgIH07XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlc19idWZmZXIodmFsdWUpIHtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpXG4gICAgICAgIHZhbHVlID0gdXRpbC5fQnVmZmVyX2Zyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nQnVmZmVyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA8IDQwKSAvLyBwbGFpbiBqcyBpcyBmYXN0ZXIgZm9yIHNob3J0IHN0cmluZ3MgKHByb2JhYmx5IGR1ZSB0byByZWR1bmRhbnQgYXNzZXJ0aW9ucylcbiAgICAgICAgdXRpbC51dGY4LndyaXRlKHZhbCwgYnVmLCBwb3MpO1xuICAgIGVsc2UgaWYgKGJ1Zi51dGY4V3JpdGUpXG4gICAgICAgIGJ1Zi51dGY4V3JpdGUodmFsLCBwb3MpO1xuICAgIGVsc2VcbiAgICAgICAgYnVmLndyaXRlKHZhbCwgcG9zKTtcbn1cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmdfYnVmZmVyKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0aWwuQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEBuYW1lIEJ1ZmZlcldyaXRlciNmaW5pc2hcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gRmluaXNoZWQgYnVmZmVyXG4gKi9cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiQnVmZmVyV3JpdGVyIiwiV3JpdGVyIiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwidXRpbCIsImNhbGwiLCJfY29uZmlndXJlIiwiYWxsb2MiLCJfQnVmZmVyX2FsbG9jVW5zYWZlIiwid3JpdGVCeXRlc0J1ZmZlciIsIkJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJuYW1lIiwid3JpdGVCeXRlc0J1ZmZlcl9zZXQiLCJ2YWwiLCJidWYiLCJwb3MiLCJ3cml0ZUJ5dGVzQnVmZmVyX2NvcHkiLCJjb3B5IiwibGVuZ3RoIiwiaSIsImJ5dGVzIiwid3JpdGVfYnl0ZXNfYnVmZmVyIiwidmFsdWUiLCJpc1N0cmluZyIsIl9CdWZmZXJfZnJvbSIsImxlbiIsInVpbnQzMiIsIl9wdXNoIiwid3JpdGVTdHJpbmdCdWZmZXIiLCJ1dGY4Iiwid3JpdGUiLCJ1dGY4V3JpdGUiLCJzdHJpbmciLCJ3cml0ZV9zdHJpbmdfYnVmZmVyIiwiYnl0ZUxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/protobufjs/src/writer_buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/google/protobuf/api.json":
/*!**********************************************************!*\
  !*** ./node_modules/protobufjs/google/protobuf/api.json ***!
  \**********************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"Api":{"fields":{"name":{"type":"string","id":1},"methods":{"rule":"repeated","type":"Method","id":2},"options":{"rule":"repeated","type":"Option","id":3},"version":{"type":"string","id":4},"sourceContext":{"type":"SourceContext","id":5},"mixins":{"rule":"repeated","type":"Mixin","id":6},"syntax":{"type":"Syntax","id":7}}},"Method":{"fields":{"name":{"type":"string","id":1},"requestTypeUrl":{"type":"string","id":2},"requestStreaming":{"type":"bool","id":3},"responseTypeUrl":{"type":"string","id":4},"responseStreaming":{"type":"bool","id":5},"options":{"rule":"repeated","type":"Option","id":6},"syntax":{"type":"Syntax","id":7}}},"Mixin":{"fields":{"name":{"type":"string","id":1},"root":{"type":"string","id":2}}},"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}},"Option":{"fields":{"name":{"type":"string","id":1},"value":{"type":"Any","id":2}}},"Syntax":{"values":{"SYNTAX_PROTO2":0,"SYNTAX_PROTO3":1}}}}}}}}');

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/google/protobuf/descriptor.json":
/*!*****************************************************************!*\
  !*** ./node_modules/protobufjs/google/protobuf/descriptor.json ***!
  \*****************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"FileDescriptorSet":{"fields":{"file":{"rule":"repeated","type":"FileDescriptorProto","id":1}}},"FileDescriptorProto":{"fields":{"name":{"type":"string","id":1},"package":{"type":"string","id":2},"dependency":{"rule":"repeated","type":"string","id":3},"publicDependency":{"rule":"repeated","type":"int32","id":10,"options":{"packed":false}},"weakDependency":{"rule":"repeated","type":"int32","id":11,"options":{"packed":false}},"messageType":{"rule":"repeated","type":"DescriptorProto","id":4},"enumType":{"rule":"repeated","type":"EnumDescriptorProto","id":5},"service":{"rule":"repeated","type":"ServiceDescriptorProto","id":6},"extension":{"rule":"repeated","type":"FieldDescriptorProto","id":7},"options":{"type":"FileOptions","id":8},"sourceCodeInfo":{"type":"SourceCodeInfo","id":9},"syntax":{"type":"string","id":12}}},"DescriptorProto":{"fields":{"name":{"type":"string","id":1},"field":{"rule":"repeated","type":"FieldDescriptorProto","id":2},"extension":{"rule":"repeated","type":"FieldDescriptorProto","id":6},"nestedType":{"rule":"repeated","type":"DescriptorProto","id":3},"enumType":{"rule":"repeated","type":"EnumDescriptorProto","id":4},"extensionRange":{"rule":"repeated","type":"ExtensionRange","id":5},"oneofDecl":{"rule":"repeated","type":"OneofDescriptorProto","id":8},"options":{"type":"MessageOptions","id":7},"reservedRange":{"rule":"repeated","type":"ReservedRange","id":9},"reservedName":{"rule":"repeated","type":"string","id":10}},"nested":{"ExtensionRange":{"fields":{"start":{"type":"int32","id":1},"end":{"type":"int32","id":2}}},"ReservedRange":{"fields":{"start":{"type":"int32","id":1},"end":{"type":"int32","id":2}}}}},"FieldDescriptorProto":{"fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":3},"label":{"type":"Label","id":4},"type":{"type":"Type","id":5},"typeName":{"type":"string","id":6},"extendee":{"type":"string","id":2},"defaultValue":{"type":"string","id":7},"oneofIndex":{"type":"int32","id":9},"jsonName":{"type":"string","id":10},"options":{"type":"FieldOptions","id":8}},"nested":{"Type":{"values":{"TYPE_DOUBLE":1,"TYPE_FLOAT":2,"TYPE_INT64":3,"TYPE_UINT64":4,"TYPE_INT32":5,"TYPE_FIXED64":6,"TYPE_FIXED32":7,"TYPE_BOOL":8,"TYPE_STRING":9,"TYPE_GROUP":10,"TYPE_MESSAGE":11,"TYPE_BYTES":12,"TYPE_UINT32":13,"TYPE_ENUM":14,"TYPE_SFIXED32":15,"TYPE_SFIXED64":16,"TYPE_SINT32":17,"TYPE_SINT64":18}},"Label":{"values":{"LABEL_OPTIONAL":1,"LABEL_REQUIRED":2,"LABEL_REPEATED":3}}}},"OneofDescriptorProto":{"fields":{"name":{"type":"string","id":1},"options":{"type":"OneofOptions","id":2}}},"EnumDescriptorProto":{"fields":{"name":{"type":"string","id":1},"value":{"rule":"repeated","type":"EnumValueDescriptorProto","id":2},"options":{"type":"EnumOptions","id":3}}},"EnumValueDescriptorProto":{"fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":2},"options":{"type":"EnumValueOptions","id":3}}},"ServiceDescriptorProto":{"fields":{"name":{"type":"string","id":1},"method":{"rule":"repeated","type":"MethodDescriptorProto","id":2},"options":{"type":"ServiceOptions","id":3}}},"MethodDescriptorProto":{"fields":{"name":{"type":"string","id":1},"inputType":{"type":"string","id":2},"outputType":{"type":"string","id":3},"options":{"type":"MethodOptions","id":4},"clientStreaming":{"type":"bool","id":5},"serverStreaming":{"type":"bool","id":6}}},"FileOptions":{"fields":{"javaPackage":{"type":"string","id":1},"javaOuterClassname":{"type":"string","id":8},"javaMultipleFiles":{"type":"bool","id":10},"javaGenerateEqualsAndHash":{"type":"bool","id":20,"options":{"deprecated":true}},"javaStringCheckUtf8":{"type":"bool","id":27},"optimizeFor":{"type":"OptimizeMode","id":9,"options":{"default":"SPEED"}},"goPackage":{"type":"string","id":11},"ccGenericServices":{"type":"bool","id":16},"javaGenericServices":{"type":"bool","id":17},"pyGenericServices":{"type":"bool","id":18},"deprecated":{"type":"bool","id":23},"ccEnableArenas":{"type":"bool","id":31},"objcClassPrefix":{"type":"string","id":36},"csharpNamespace":{"type":"string","id":37},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[38,38]],"nested":{"OptimizeMode":{"values":{"SPEED":1,"CODE_SIZE":2,"LITE_RUNTIME":3}}}},"MessageOptions":{"fields":{"messageSetWireFormat":{"type":"bool","id":1},"noStandardDescriptorAccessor":{"type":"bool","id":2},"deprecated":{"type":"bool","id":3},"mapEntry":{"type":"bool","id":7},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[8,8]]},"FieldOptions":{"fields":{"ctype":{"type":"CType","id":1,"options":{"default":"STRING"}},"packed":{"type":"bool","id":2},"jstype":{"type":"JSType","id":6,"options":{"default":"JS_NORMAL"}},"lazy":{"type":"bool","id":5},"deprecated":{"type":"bool","id":3},"weak":{"type":"bool","id":10},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[4,4]],"nested":{"CType":{"values":{"STRING":0,"CORD":1,"STRING_PIECE":2}},"JSType":{"values":{"JS_NORMAL":0,"JS_STRING":1,"JS_NUMBER":2}}}},"OneofOptions":{"fields":{"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"EnumOptions":{"fields":{"allowAlias":{"type":"bool","id":2},"deprecated":{"type":"bool","id":3},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"EnumValueOptions":{"fields":{"deprecated":{"type":"bool","id":1},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"ServiceOptions":{"fields":{"deprecated":{"type":"bool","id":33},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"MethodOptions":{"fields":{"deprecated":{"type":"bool","id":33},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"UninterpretedOption":{"fields":{"name":{"rule":"repeated","type":"NamePart","id":2},"identifierValue":{"type":"string","id":3},"positiveIntValue":{"type":"uint64","id":4},"negativeIntValue":{"type":"int64","id":5},"doubleValue":{"type":"double","id":6},"stringValue":{"type":"bytes","id":7},"aggregateValue":{"type":"string","id":8}},"nested":{"NamePart":{"fields":{"namePart":{"rule":"required","type":"string","id":1},"isExtension":{"rule":"required","type":"bool","id":2}}}}},"SourceCodeInfo":{"fields":{"location":{"rule":"repeated","type":"Location","id":1}},"nested":{"Location":{"fields":{"path":{"rule":"repeated","type":"int32","id":1},"span":{"rule":"repeated","type":"int32","id":2},"leadingComments":{"type":"string","id":3},"trailingComments":{"type":"string","id":4},"leadingDetachedComments":{"rule":"repeated","type":"string","id":6}}}}},"GeneratedCodeInfo":{"fields":{"annotation":{"rule":"repeated","type":"Annotation","id":1}},"nested":{"Annotation":{"fields":{"path":{"rule":"repeated","type":"int32","id":1},"sourceFile":{"type":"string","id":2},"begin":{"type":"int32","id":3},"end":{"type":"int32","id":4}}}}}}}}}}}');

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/google/protobuf/source_context.json":
/*!*********************************************************************!*\
  !*** ./node_modules/protobufjs/google/protobuf/source_context.json ***!
  \*********************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}}}}}}}}');

/***/ }),

/***/ "(ssr)/./node_modules/protobufjs/google/protobuf/type.json":
/*!***********************************************************!*\
  !*** ./node_modules/protobufjs/google/protobuf/type.json ***!
  \***********************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"Type":{"fields":{"name":{"type":"string","id":1},"fields":{"rule":"repeated","type":"Field","id":2},"oneofs":{"rule":"repeated","type":"string","id":3},"options":{"rule":"repeated","type":"Option","id":4},"sourceContext":{"type":"SourceContext","id":5},"syntax":{"type":"Syntax","id":6}}},"Field":{"fields":{"kind":{"type":"Kind","id":1},"cardinality":{"type":"Cardinality","id":2},"number":{"type":"int32","id":3},"name":{"type":"string","id":4},"typeUrl":{"type":"string","id":6},"oneofIndex":{"type":"int32","id":7},"packed":{"type":"bool","id":8},"options":{"rule":"repeated","type":"Option","id":9},"jsonName":{"type":"string","id":10},"defaultValue":{"type":"string","id":11}},"nested":{"Kind":{"values":{"TYPE_UNKNOWN":0,"TYPE_DOUBLE":1,"TYPE_FLOAT":2,"TYPE_INT64":3,"TYPE_UINT64":4,"TYPE_INT32":5,"TYPE_FIXED64":6,"TYPE_FIXED32":7,"TYPE_BOOL":8,"TYPE_STRING":9,"TYPE_GROUP":10,"TYPE_MESSAGE":11,"TYPE_BYTES":12,"TYPE_UINT32":13,"TYPE_ENUM":14,"TYPE_SFIXED32":15,"TYPE_SFIXED64":16,"TYPE_SINT32":17,"TYPE_SINT64":18}},"Cardinality":{"values":{"CARDINALITY_UNKNOWN":0,"CARDINALITY_OPTIONAL":1,"CARDINALITY_REQUIRED":2,"CARDINALITY_REPEATED":3}}}},"Enum":{"fields":{"name":{"type":"string","id":1},"enumvalue":{"rule":"repeated","type":"EnumValue","id":2},"options":{"rule":"repeated","type":"Option","id":3},"sourceContext":{"type":"SourceContext","id":4},"syntax":{"type":"Syntax","id":5}}},"EnumValue":{"fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":2},"options":{"rule":"repeated","type":"Option","id":3}}},"Option":{"fields":{"name":{"type":"string","id":1},"value":{"type":"Any","id":2}}},"Syntax":{"values":{"SYNTAX_PROTO2":0,"SYNTAX_PROTO3":1}},"Any":{"fields":{"type_url":{"type":"string","id":1},"value":{"type":"bytes","id":2}}},"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}}}}}}}}');

/***/ })

};
;